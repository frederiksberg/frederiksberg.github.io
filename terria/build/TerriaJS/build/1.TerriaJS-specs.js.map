{"version":3,"sources":["webpack:///./node_modules/terriajs-cesium/Source/Core/CornerType.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositeProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositePositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ReferenceProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ScaledPositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/OrderedGroundPrimitiveCollection.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BillboardVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BoxGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CorridorGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CylinderGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipseGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipsoidGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PlaneGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolygonGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVolumeGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/RectangleGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/RectangleGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/quickselect.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/rbush.js","webpack:///./node_modules/terriajs-cesium/Source/Core/RectangleCollisionChecker.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticOutlineGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/WallGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/LabelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ModelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PathVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PointVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DataSourceDisplay.js"],"names":["ROUNDED","MITERED","BEVELED","CompositeProperty","this","_eventHelper","_definitionChanged","_intervals","changedEvent","addEventListener","prototype","_intervalsChanged","isConstant","get","isEmpty","definitionChanged","intervals","getValue","time","result","innerProperty","findDataForIntervalContainingDate","equals","other","property","eventHelper","callback","raiseEvent","items","removeAll","length","i","interval","data","indexOf","add","subscribeAll","CompositePositionProperty","referenceFrame","_referenceFrame","FIXED","_composite","_raiseDefinitionChanged","set","value","getValueInReferenceFrame","resolve","that","targetProperty","_targetProperty","_resolveProperty","entityIsResolved","_resolveEntity","targetEntity","_targetCollection","getById","_targetId","ReferenceProperty","_onTargetEntityDefinitionChanged","_targetEntity","resolveEntity","names","_targetPropertyNames","join","targetCollection","targetId","targetPropertyNames","undefined","collectionChanged","_onCollectionChanged","resolvedProperty","fromString","referenceString","identifier","values","inIdentifier","isEscaped","token","c","charAt","push","getType","otherNames","name","oldValue","collection","added","removed","removeEventListener","ScaledPositionProperty","_value","_removeSubscription","setValue","WGS84","scaleToGeodeticSurface","OrderedGroundPrimitiveCollection","_length","_collections","_collectionsArray","show","defineProperties","primitive","zIndex","defaultValue","defined","PrimitiveCollection","destroyPrimitives","_zIndex","array","splice","remove","doNotDestroy","contains","index","removeAndDestroy","destroy","collections","update","frameState","isDestroyed","destroyObject","defaultColor","Color","WHITE","defaultEyeOffset","Cartesian3","ZERO","defaultHeightReference","HeightReference","NONE","defaultPixelOffset","Cartesian2","defaultAlignedAxis","defaultHorizontalOrigin","HorizontalOrigin","CENTER","defaultVerticalOrigin","VerticalOrigin","positionScratch","colorScratch","eyeOffsetScratch","pixelOffsetScratch","scaleByDistanceScratch","NearFarScalar","translucencyByDistanceScratch","pixelOffsetScaleByDistanceScratch","boundingRectangleScratch","BoundingRectangle","distanceDisplayConditionScratch","DistanceDisplayCondition","EntityData","entity","billboard","textureValue","BillboardVisualizer","entityCluster","entityCollection","_cluster","_entityCollection","_items","AssociativeArray","returnPrimitive","item","cluster","removeBillboard","len","position","billboardGraphics","_billboard","isShowing","isAvailable","Property","getValueOrDefault","_show","getValueOrUndefined","_position","_image","_clusterDirty","getBillboard","id","image","color","_color","eyeOffset","_eyeOffset","heightReference","_heightReference","pixelOffset","_pixelOffset","scale","_scale","rotation","_rotation","alignedAxis","_alignedAxis","horizontalOrigin","_horizontalOrigin","verticalOrigin","_verticalOrigin","width","_width","height","_height","scaleByDistance","_scaleByDistance","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","sizeInMeters","_sizeInMeters","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","subRegion","_imageSubRegion","setImageSubRegion","_imageId","getBoundingSphere","BoundingSphereState","FAILED","center","clone","_clampedPosition","PENDING","radius","DONE","entities","changed","MaterialAppearance","options","EMPTY_OBJECT","translucent","closed","materialSupport","MaterialSupport","TEXTURED","material","Material","fromType","ColorType","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","Appearance","getDefaultRenderState","renderState","_closed","_materialSupport","_vertexFormat","vertexFormat","_flat","flat","_faceForward","faceForward","getFragmentShaderSource","isTranslucent","getRenderState","BASIC","freezeObject","VertexFormat","POSITION_AND_NORMAL","POSITION_NORMAL_AND_ST","ALL","DistanceDisplayConditionGeometryInstanceAttribute","near","far","Number","MAX_VALUE","Float32Array","componentDatatype","ComponentDatatype","FLOAT","componentsPerAttribute","normalize","fromDistanceDisplayCondition","toValue","MaterialProperty","DeveloperError","throwInstantiationError","materialProperty","type","uniforms","DynamicGeometryUpdater","geometryUpdater","primitives","orderedGroundPrimitives","_primitives","_orderedGroundPrimitives","_primitive","_outlinePrimitive","_geometryUpdater","_options","_entity","_material","_isHidden","geometry","_setOptions","onTerrain","_onTerrain","_geometryPropertyName","shadows","shadowsProperty","fill","appearance","fillMaterialProperty","isColorAppearance","ColorMaterialProperty","_getIsClosed","PerInstanceColorAppearance","_supportsMaterialsforEntitiesOnTerrain","VERTEX_FORMAT","GroundPrimitive","geometryInstances","createFillGeometryInstance","asynchronous","classificationType","classificationTypeProperty","fillInstance","attributes","Primitive","outline","outlineInstance","createOutlineGeometryInstance","outlineWidth","lineWidth","_scene","clampLineWidth","outlinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","BoundingSphere","defaultMaterial","defaultShow","ConstantProperty","defaultFill","defaultOutline","defaultOutlineColor","BLACK","defaultShadows","ShadowMode","DISABLED","defaultDistanceDisplayCondition","defaultClassificationType","ClassificationType","BOTH","GeometryUpdater","geometryPropertyName","scene","_fillEnabled","_isClosed","_dynamic","_outlineEnabled","_geometryChanged","Event","_showProperty","_materialProperty","_showOutlineProperty","_outlineColorProperty","_outlineWidth","_shadowsProperty","_distanceDisplayConditionProperty","_classificationTypeProperty","geometryOptions","_id","_observedPropertyNames","observedPropertyNames","Entity","supportsMaterialsforEntitiesOnTerrain","fillEnabled","hasConstantFill","availability","_fillProperty","outlineEnabled","hasConstantOutline","outlineColorProperty","distanceDisplayConditionProperty","isDynamic","isClosed","geometryChanged","isOutlineVisible","visible","isFilled","Iso8601","MINIMUM_VALUE","_isOnTerrain","_isDynamic","_setStaticOptions","_onEntityPropertyChanged","propertyName","newValue","fillProperty","outlineProperty","outlineColor","oneTimeWarning","geometryOutlines","createDynamicUpdater","groundPrimitives","constructor","scratchPosition","scratchCarto","Cartographic","TerrainOffsetProperty","positionProperty","heightReferenceProperty","extrudedHeightReferenceProperty","_extrudedHeightReference","_positionProperty","_cartographicPosition","_normal","_terrainHeight","_removeCallbackFunc","_removeEventListener","_removeModeListener","globe","terrainProviderChanged","_updateClamping","morphComplete","ellipsoid","geodeticSurfaceNormal","surface","_surface","cartographicPosition","cartesianToCartographic","getHeight","updateHeight","clampedPosition","mode","SceneMode","SCENE3D","carto","x","extrudedHeightReference","RELATIVE_TO_GROUND","multiplyByScalar","equalsEpsilon","EPSILON10","normal","call","_terrainOffsetProperty","centerPosition","CallbackProperty","_computeCenter","bind","defaultOffset","offsetScratch","scratchColor","BoxGeometryOptions","dimensions","offsetAttribute","BoxGeometryUpdater","box","DynamicBoxGeometryUpdater","Object","create","terrainOffsetProperty","currentColor","ShowGeometryInstanceAttribute","offset","ColorGeometryInstanceAttribute","fromColor","OffsetGeometryInstanceAttribute","fromCartesian3","GeometryInstance","BoxGeometry","fromDimensions","modelMatrix","computeModelMatrixForHeightReference","z","mapProjection","BoxOutlineGeometry","orientation","GeometryOffsetAttribute","scratch2Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","subdivideHeights","points","h0","h1","granularity","p0","p1","angleBetween","numPoints","Math","ceil","heights","Array","heightPerVertex","h","nextScratch","prevScratch","negativeX","Matrix4","rotationZ","Matrix3","scaleMatrix","IDENTITY","westScratch","finalPosScratch","Cartesian4","heightCartesian","addPosition","left","shape","finalPositions","xScalar","repeat","west","finalPosition","Transforms","eastNorthUpToFixedFrame","multiplyByPointAsVector","angle","start","end","tangentPlane","EllipsoidTangentPlane","next","projectPointOntoPlane","prev","y","computeRotationAngle","fromRotationZ","multiplyTransformation","fromRotationTranslation","j","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3D","shape2D","boundingRectangle","xOffset","yOffset","quaterion","Quaternion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","m","subtract","CornerType","toRadians","fromQuaternion","fromAxisAngle","negate","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","positions","_ellipsoid","pos","scaleToSurface","_granularity","_cornerType","shapeForSides","point","convertShapeTo3DDuplicate","shapeForEnds","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","cross","subdividedHeights","forwardProjection","dot","backwardProjection","abs","EPSILON7","scalar","max","magnitude","PolylinePipeline","generateArc","posLength","combinedPositions","Float64Array","CorridorGeometryLibrary","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","cornerPoint","size","computeMiteredCorner","leftCornerDirection","lastPoint","addShiftedPositions","calculatedPositions","rightPositions","leftPositions","scaledLeft","scaledRight","rightIndex","leftIndex","rightPos","leftPos","addAttribute","attribute","front","back","params","saveAttributes","previousPos","calculatedLefts","calculatedNormals","endPositions","corners","leftEdge","firstEndCap","midpoint","rightEdge","addEndCaps","lefts","normals","addNormals","attr","tangents","bitangents","tangent","bitangent","combine","computedPositions","corner","computedLefts","computedNormals","GeometryAttributes","leftCount","rightCount","indicesLength","leftSide","endPositionLength","addEndPositions","UL","LL","UR","LR","halfLength","indices","IndexDatatype","createTypedArray","firstEndPositions","rightNormal","leftNormal","posIndex","compIndex","l","r","outsidePoint","previousPoint","nextPoint","lastEndPositions","GeometryAttribute","DOUBLE","st","rightSt","leftSt","stIndex","a","theta","PI","halfEndPos","PI_OVER_TWO","cos","sin","addWallPositions","wallPositions","computePositionsExtruded","topVertexFormat","shadowVolume","extrudedHeight","newPositions","extrudedPositions","PolygonPipeline","scaleToGeodeticHeight","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","extrudedAttributes","extrudeNormals","extrudeDirection","applyOffset","Uint8Array","TOP","arrayFill","applyOffsetValue","UNSIGNED_BYTE","iLength","newIndices","v2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","min","direction","offsetDirection","minLat","latitude","minLon","longitude","maxLat","maxLon","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","cleanPositions","arrayRemoveDuplicates","Rectangle","POSITIVE_INFINITY","NEGATIVE_INFINITY","first","last","rectangle","north","south","east","CorridorGeometry","_positions","Ellipsoid","DEFAULT","_extrudedHeight","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","createGeometry","corridorGeometry","extrude","EPSILON2","fromVertices","Geometry","primitiveType","PrimitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","wallIndices","floor","CorridorOutlineGeometry","corridorOutlineGeometry","offsetValue","LINES","defaultZIndex","GroundGeometryUpdater","isSupported","geometryZIndex","getGeometryHeight","CLAMP_TO_GROUND","geometryHeightReference","getGeometryExtrudedHeight","geometryExtrudedHeightReference","computeGeometryOffsetAttribute","n","scratchRectangle","CorridorGeometryOptions","CorridorGeometryUpdater","corridor","DynamicCorridorGeometryUpdater","heightValue","heightReferenceValue","extrudedHeightValue","extrudedHeightReferenceValue","ApproximateTerrainHeights","getMinimumMaximumHeights","minimumTerrainHeight","CylinderGeometryLibrary","topRadius","bottomRadius","slices","topZ","bottomZ","twoSlice","tbIndex","bottomOffset","topOffset","TWO_PI","bottomX","bottomY","topX","topY","radiusScratch","normalScratch","bitangentScratch","tangentScratch","CylinderGeometry","_topRadius","_bottomRadius","_slices","unitCylinderGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","atan2","normalScale","UNIT_Z","numIndices","textureCoordIndex","rad","getUnitCylinder","CylinderOutlineGeometry","numberOfVerticalLines","_numberOfVerticalLines","numSide","numSideLines","round","CylinderGeometryOptions","CylinderGeometryUpdater","cylinder","DynamicCylinderGeometryUpdater","DynamicGeometryBatch","_dynamicUpdaters","updater","dynamicUpdater","geometries","removeAllPrimitives","EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","azimuth","cosThetaSquared","sinThetaSquared","sqrt","scratchNormal","raisePositionsToHeight","i2","extrudedPosition","scaledNormal","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","numPts","deltaTheta","numInterior","interiorPosition","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","lerp","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","scratchTangent","scratchBitangent","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","stRotation","textureCoordinates","projection","GeographicProjection","projectedCenter","project","geodeticNormal","textureMatrix","tangentMatrix","minTexCoord","fromElements","maxTexCoord","stOffset","rotatedPoint","projectedPoint","k","topIndices","prevIndex","indicesIndex","boundingSphereCenter","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","cep","union","topBottomAttributes","topBottomIndices","topBottomGeo","wallAttributes","bottom","computeWallAttributes","computeWallIndices","wallGeo","geo","GeometryPipeline","combineInstances","positionsFlat","positionsCount","fromCartesianArray","EllipseGeometry","_center","_semiMajorAxis","_semiMinorAxis","_stRotation","_textureCoordinateRotationPoints","scratchCenter","ellipseGeometry","computeEllipse","EllipseOutlineGeometry","clamp","maxI","EllipseGeometryOptions","EllipseGeometryUpdater","ellipse","DynamicEllipseGeometryUpdater","radiiScratch","innerRadiiScratch","unitSphere","EllipsoidGeometryOptions","radii","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","subdivisions","EllipsoidGeometryUpdater","DynamicEllipsoidGeometryUpdater","_modelMatrix","_attributes","_outlineAttributes","_lastSceneMode","_lastShow","_lastOutlineShow","_lastOutlineWidth","_lastOutlineColor","_lastOffset","skipModelMatrix","modelMatrixResult","EllipsoidGeometry","EllipsoidOutlineGeometry","showFill","showOutline","getValueOrClonedDefault","sceneMode","in3D","_lastDistanceDisplayCondition","outlineAttributes","multiplyByScale","PlaneGeometry","planeGeometry","texCoords","Uint16Array","PlaneOutlineGeometry","PlaneGeometryOptions","plane","PlaneGeometryUpdater","DynamicPlaneGeometryUpdater","distanceDisplayConditionAttribute","planeGraphics","computeModelMatrix","createPrimitiveMatrix","isColorMaterial","scratchAxis","scratchAxis2","scratchTranslation","scratchScale","scratchQuaternion","scratchMatrix3","transform","distance","translation","transformedNormal","up","EPSILON8","rotationMatrix","setColumn","fromRotationMatrix","fromTranslationQuaternionRotationScale","CoplanarPolygonGeometryLibrary","scratchIntersectionPoint","scratchXAxis","scratchYAxis","scratchZAxis","obbScratch","OrientedBoundingBox","projectTo2D","axis1","axis2","v","validOutline","halfAxes","fromPoints","xAxis","getColumn","yAxis","zAxis","xMag","yMag","zMag","computeProjectTo2DArguments","centerResult","planeAxis1Result","planeAxis2Result","planeAxis1","planeAxis2","orientedBoundingBox","createProjectPointsTo2DFunction","positionResults","createProjectPointTo2DFunction","scratchBR","stScratch","textureCoordinatesOrigin","axis1Scratch","axis2Scratch","tangentRotationScratch","surfaceNormalScratch","createGeometryFromPolygon","polygon","projectPointTo2D","triangulate","positions2D","holes","tangentRotation","stOrigin","flatPositions","stx","sty","CoplanarPolygonGeometry","polygonHierarchy","_polygonHierarchy","PolygonGeometryLibrary","computeHierarchyPackedLength","fromPositions","packPolygonHierarchy","unpackPolygonHierarchy","polygonGeometry","EPSILON6","projectPoints","projectPoint","results","polygonsFromHierarchy","hierarchy","polygons","outerRing","computeBoundingRectangle","geometryInstance","createGeometryFromPositions","CoplanarPolygonOutlineGeometry","polygonOutlinesFromHierarchy","scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","p2","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","computeAttributes","wall","top","perPositionHeight","origin","recomputeNormal","tangentRotationMatrix","_plane","bottomOffset2","p","attrIndex1","attrIndex2","startCartographicScratch","endCartographicScratch","westOverIDL","eastOverIDL","EllipsoidGeodesic","arcType","ArcType","RHUMB","swap","inverseChordLength","chordLength","maximumRadius","positionsLength","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","interpolatedCartographicScratch","ellipsoidGeodesic","idlCross","segmentLength","surfaceDistance","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","closeTop","closeBottom","geos","walls","numPositions","topGeo","edgePoints","topBottomPositions","concat","ilength","topAndBottom","projectPointsOntoPlane","windingOrder","computeWindingOrder2D","WindingOrder","CLOCKWISE","slice","reverse","computeWallGeometry","hole","COUNTER_CLOCKWISE","PolygonGeometry","perPositionHeightExtrude","_closeTop","_closeBottom","_perPositionHeight","_perPositionHeightExtrude","_arcType","GEODESIC","dummyOptions","splitGeometry","scaleToGeodeticHeightExtruded","createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","minDistance","subdividedPositions","subdivideLineCount","subdivideRhumbLineCount","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","indicesSize","cornersLength","PolygonOutlineGeometry","scratch2DPositions","cart2Scratch","PolygonGeometryOptions","PolygonGeometryUpdater","DyanmicPolygonGeometryUpdater","area","centroid2D","f","sum","projectPointOntoEllipsoid","perPositionHeightProperty","perPositionHeightEnabled","hierarchyValue","perPositionHeightValue","isExtruded","PolylineVolumeGeometry","polylinePositions","_shape","numComponents","brScratch","polylineVolumeGeometry","ll","ul","ur","lr","shapeLength","vertexCount","firstEndIndices","indicesCount","lengthSt","heightSt","stindex","endOffset","computeTangentAndBitangent","e","PolylineVolumeOutlineGeometry","polylineVolumeOutlineGeometry","shapeCount","firstOffset","secondOffset","PolylineVolumeGeometryOptions","PolylineVolumeGeometryUpdater","polylineVolume","DynamicPolylineVolumeGeometryUpdater","rectangleScratch","createAttributes","v1Scratch","v2Scratch","constructRectangle","rectangleGeometry","computedOptions","northCap","southCap","rowStart","rowEnd","rowHeight","minX","minY","maxX","maxY","row","col","RectangleGeometryLibrary","computePosition","calculateAttributes","upperLeft","lowerLeft","lowerRight","upperRight","northIndex","southIndex","topPositions","bottomPositions","addWallTextureCoordinates","wallTextures","constructExtrudedRectangle","offsetAttributeValue","_surfaceHeight","newVertexFormat","newLength","textures","hasOffsets","widthMultiplier","perimeterPositions","dupliateCorners","wallCount","wallExtrudeNormals","wallOffsetAttribute","computeTopOffsets","threeI","extrudeNormalIndex","wallOffsetIndex","calculateAttributesWall","scratchRectanglePoints","nwScratch","stNwScratch","computeOptions","RectangleGeometry","_rotatedRectangle","surfaceHeight","tangentRotationMatrixScratch","axis","geodeticSurfaceNormalCartographic","lonScalar","latScalar","topBS","fromRectangle3D","bottomBS","unrotatedTextureRectangleScratch","points2DScratch","rotation2DScratch","Matrix2","rectangleCenterScratch","unrotatedTextureRectangle","points2D","toDesiredInComputed","fromRotation","boundingRectangleCenter","point2D","minXYCorner","maxYCorner","maxXCorner","scratchCenterRect","RectangleGeometryOptions","RectangleGeometryUpdater","DynamicRectangleGeometryUpdater","RectangleOutlineGeometry","rect","coordinates","toCartesian","Batch","appearanceType","depthFailAppearanceType","depthFailMaterialProperty","removeMaterialSubscription","depthFailMaterial","createPrimitive","waitingOnCreate","oldPrimitive","updaters","updatersWithAttributes","subscriptions","showsUpdated","itemsToRemove","invalidated","onMaterialChanged","StaticGeometryColorBatch","_solidItems","_translucentItems","_appearanceType","_depthFailAppearanceType","_shadows","removeItem","moveItems","batch","itemsMoved","itemsToMoveLength","updateItems","isUpdated","updatersLength","isMaterial","updaterMaterial","instance","unsubscribe","removedCount","depthFailAppearance","colorProperty","resultColor","_lastColor","depthFailColorProperty","depthColor","_lastDepthFailColor","depthFailColor","offsetProperty","updateShows","solidsMoved","translucentsMoved","updaterDepthFailMaterial","StaticGeometryPerMaterialBatch","key","isDirty","scratchArray","StaticGroundGeometryColorBatch","_batches","_classificationType","fillColor","newColor","toBytes","bs","batches","batchKey","Uint32Array","buffer","batchesArray","count","batchCount","oldBatch","newBatch","batchesArrayCopy","batchesCopyCount","arr","tmp","defaultCompare","b","right","compare","quickselectStep","log","exp","sd","newLeft","newRight","rbush","maxEntries","format","_maxEntries","_minEntries","_initFormat","clear","findItem","equalsFn","calcBBox","node","toBBox","distBBox","children","destNode","createNode","Infinity","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersects","multiSelect","mid","stack","pop","all","_all","search","bbox","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","parent","goingUp","path","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","RectangleCollisionChecker","_tree","RectangleWithId","idCompare","fromRectangleAndId","withId","removalScratch","collisionScratch","usingSphericalTextureCoordinates","rectangleCollisionCheck","StaticGroundGeometryPerMaterialBatch","overlapping","ShadowVolumeAppearance","shouldUseSphericalCoordinates","StaticOutlineGeometryBatch","_solidBatches","_translucentBatches","solidBatches","solidBatchesLength","translucentBatches","translucentBatchesLength","needUpdate","solidsToMoveLength","translucentToMoveLength","solidBatch","translucentBatch","WallGeometryLibrary","latLonEquals","c0","c1","EPSILON14","scratchCartographic1","scratchCartographic2","positionsArrayScratch","heightsArrayScratch","generateArcOptionsScratch","maximumHeights","minimumHeights","duplicateCorners","o","topHeights","bottomHeights","hasBottomHeights","hasTopHeights","hasAllZeroHeights","cleanedTopHeights","cleanedBottomHeights","removeDuplicates","numCorners","generateArcOptions","numberOfPoints","generateArcPositions","generateArcHeights","scratchCartesian3Position1","scratchCartesian3Position2","scratchCartesian3Position3","scratchCartesian3Position4","scratchCartesian3Position5","WallGeometry","_minimumHeights","_maximumHeights","fromConstantHeights","minHeights","maxHeights","minimumHeight","maximumHeight","doMin","doMax","wallGeometry","ds","i3","nextTop","groundPosition","scalednextPosition","scaledGroundPosition","edgeIndex","pl","pr","WallOutlineGeometry","WallGeometryOptions","WallGeometryUpdater","DynamicWallGeometryUpdater","emptyArray","geometryUpdaters","GeometryUpdaterSet","EventHelper","_removeEntitySubscription","GeometryVisualizer","_groundPrimitives","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","NUMBER_OF_SHADOW_MODES","_outlineBatches","_closedColorBatches","_closedMaterialBatches","_openColorBatches","_openMaterialBatches","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","groundColorBatches","groundMaterialBatches","_groundColorBatches","_groundMaterialBatches","_dynamicBatch","_subscriptions","_updaterSets","forEach","updaterSet","addedObjects","removedObjects","changedObjects","_removeUpdater","_insertUpdaterIntoBatch","_onGeometryChanged","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","boundingSpheres","state","batchesLength","fromBoundingSpheres","updaterSets","defaultStyle","LabelStyle","FILL","defaultFillColor","defaultBackgroundColor","defaultBackgroundPadding","fillColorScratch","outlineColorScratch","backgroundColorScratch","backgroundPaddingScratch","label","LabelVisualizer","removeLabel","text","labelGraphics","_label","_text","updateClamping","getLabel","font","_font","style","_style","_fillColor","_outlineColor","showBackground","_showBackground","backgroundColor","_backgroundColor","backgroundPadding","_backgroundPadding","ENABLED","defaultSilhouetteColor","RED","defaultColorBlendMode","ColorBlendMode","HIGHLIGHT","defaultImageBasedLightingFactor","defaultUpAxis","Axis","Y","modelMatrixScratch","nodeMatrixScratch","ModelVisualizer","_modelHash","_entitiesToVisualize","removeModel","visualizer","modelHash","modelData","modelPrimitive","clearNodeTransformationsArticulationsScratch","nodeTransformationsScratch","articulationsScratch","checkModelLoad","model","readyPromise","otherwise","error","console","loadFail","resource","modelGraphics","_model","Resource","createIfNeeded","_uri","url","Model","fromGltf","incrementallyLoadTextures","_incrementallyLoadTextures","animationsRunning","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","silhouetteColor","_silhouetteColor","silhouetteSize","_silhouetteSize","colorBlendMode","_colorBlendMode","colorBlendAmount","_colorBlendAmount","clippingPlanes","_clippingPlanes","clampAnimations","_clampAnimations","imageBasedLightingFactor","_imageBasedLightingFactor","lightColor","_lightColor","_upAxis","_forwardAxis","runAnimations","_runAnimations","activeAnimations","addAll","loop","ModelAnimationLoop","REPEAT","nodeTransformations","_nodeTransformations","nodeNames","keys","nodeIndex","nodeLength","nodeName","nodeTransformation","modelNode","getNode","transformationMatrix","fromTranslationRotationScale","matrix","multiply","originalMatrix","anyArticulationUpdated","articulations","_articulations","articulationStageKeys","numKeys","articulationStageValue","setArticulationStage","applyArticulations","_clampedModelMatrix","_heightChanged","scratchTimeInterval","TimeInterval","subSampleCompositePropertyScratch","subSampleIntervalPropertyScratch","polyline","reallySubSample","stop","updateTime","maximumStep","SampledPositionProperty","times","sampleStepsToTake","sampleStepsTaken","sampleStepSize","steppedOnNow","JulianDate","lessThanOrEquals","greaterThanOrEquals","current","loopStop","sampling","greaterThan","lessThan","secondsUntilNext","secondsDifference","addSeconds","subSampleSampledProperty","_property","_times","intersect","intervalStart","intervalStop","sampleStart","sampleStop","subSampleCompositeProperty","TimeIntervalCollectionPositionProperty","isStartIncluded","isStopIncluded","subSampleIntervalProperty","ConstantPositionProperty","subSampleConstantProperty","stepSize","subSampleGenericProperty","subSample","toFixedScratch","PolylineUpdater","_unusedIndexes","_polylineCollection","PolylineCollection","PathVisualizer","_updaters","ReferenceFrame","INERTIAL","toFixed","computeIcrfToFixedMatrix","computeTemeToPseudoFixedMatrix","updateObject","pathGraphics","_path","showProperty","leadTime","_leadTime","trailTime","_trailTime","_availability","hasAvailability","hasLeadTime","hasTrailTime","unusedIndexes","resolution","_resolution","removeObject","hasOwnProperty","u","lastUpdater","frameToVisualize","currentUpdater","_subSample","pointPrimitive","pixelSize","PointVisualizer","removePoint","pointGraphics","_point","needsRedraw","getPoint","_pixelSize","newOutlineColor","newOutlineWidth","newPixelSize","centerAlpha","alpha","cssColor","toCssColorString","cssOutlineColor","textureId","JSON","stringify","setImage","createBillboardPointCallback","scratchInterpolateColorsArray","interpolateColors","color0","color1","colors","r0","red","g0","green","b0","blue","a0","r1","g1","b1","a1","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","PolylineGeometry","colorsPerVertex","_colors","_colorsPerVertex","scratchPrevPosition","scratchNextPosition","polylineGeometry","subdivisionSize","numberOfPointsFunction","numberOfPointsRhumbLine","extractHeights","colorLength","newColors","newColorIndex","numColors","interpolatedColors","interpolatedColorsLength","generateCartesianArc","generateCartesianRhumbArc","prevPositions","nextPositions","expandAndWidth","finalColors","expandAndWidthIndex","colorIndex","endK","floatToByte","prevPosition","geometryType","GeometryType","POLYLINES","polylineCollections","GeometryOptions","GroundGeometryOptions","PolylineGeometryUpdater","_entitySubscription","_depthFailMaterialProperty","_geometryOptions","_groundGeometryOptions","_clampToGround","_supportsPolylinesOnTerrain","supportsPolylinesOnTerrain","clampToGround","GroundPolylineGeometry","positionsProperty","PolylineColorAppearance","PolylineMaterialAppearance","groundGeometryOptions","generateCartesianArcOptions","_line","_groundPolylinePrimitive","getLine","dynamicGeometryUpdater","sceneId","polylineCollection","line","GroundPolylinePrimitive","groundPolylinePrimitive","_asynchronous","StaticGroundPolylinePerMaterialBatch","removeUpdater","insertUpdaterIntoBatch","_groundBatches","multiplier","_colorBatches","_materialBatches","PolylineVisualizer","DataSourceDisplay","_displayID","createGuid","initializeTerrainHeights","dataSourceCollection","dataSourceAdded","_onDataSourceAdded","dataSourceRemoved","_onDataSourceRemoved","dataSourceMoved","_onDataSourceMoved","postRender","_postRender","_dataSourceCollection","_visualizersCallback","visualizersCallback","defaultVisualizersCallback","primitivesAdded","removeDefaultDataSourceListener","removeDataSourceCollectionListener","defaultDataSource","CustomDataSource","_defaultDataSource","addPrimitives","_removeDefaultDataSourceListener","_removeDataSourceCollectionListener","_ready","dataSource","dataSources","initialized","visualizers","vLength","_visualizersByDisplayID","credit","creditDisplay","addCredit","credits","_resourceCredits","creditCount","allowPartial","d","_visualizers","visualizersLength","displayPrimitives","displayGroundPrimitives","clustering","_initialize","newIndex","oldIndex","raise","lower","lowerToBottom","raiseToTop"],"mappings":"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","file":"1.TerriaJS-specs.js","sourcesContent":["import freezeObject from './freezeObject.js';\n\n    /**\n     * Style options for corners.\n     *\n     * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\n     * demonstrates the three corner types, as used by {@link CorridorGraphics}.\n     *\n     * @exports CornerType\n     */\n    var CornerType = {\n        /**\n         * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner has a smooth edge.\n         * @type {Number}\n         * @constant\n         */\n        ROUNDED : 0,\n\n        /**\n         * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner point is the intersection of adjacent edges.\n         * @type {Number}\n         * @constant\n         */\n        MITERED : 1,\n\n        /**\n         * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner is clipped.\n         * @type {Number}\n         * @constant\n         */\n        BEVELED : 2\n    };\nexport default freezeObject(CornerType);\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport TimeIntervalCollection from '../Core/TimeIntervalCollection.js';\nimport Property from './Property.js';\n\n    function subscribeAll(property, eventHelper, definitionChanged, intervals) {\n        function callback() {\n            definitionChanged.raiseEvent(property);\n        }\n        var items = [];\n        eventHelper.removeAll();\n        var length = intervals.length;\n        for (var i = 0; i < length; i++) {\n            var interval = intervals.get(i);\n            if (defined(interval.data) && items.indexOf(interval.data) === -1) {\n                eventHelper.add(interval.data.definitionChanged, callback);\n            }\n        }\n    }\n\n    /**\n     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the\n     * data property of each {@link TimeInterval} is another Property instance which is\n     * evaluated at the provided time.\n     *\n     * @alias CompositeProperty\n     * @constructor\n     *\n     *\n     * @example\n     * var constantProperty = ...;\n     * var sampledProperty = ...;\n     *\n     * //Create a composite property from two previously defined properties\n     * //where the property is valid on August 1st, 2012 and uses a constant\n     * //property for the first half of the day and a sampled property for the\n     * //remaining half.\n     * var composite = new Cesium.CompositeProperty();\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',\n     *     data : constantProperty\n     * }));\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',\n     *     isStartIncluded : false,\n     *     isStopIncluded : false,\n     *     data : sampledProperty\n     * }));\n     *\n     * @see CompositeMaterialProperty\n     * @see CompositePositionProperty\n     */\n    function CompositeProperty() {\n        this._eventHelper = new EventHelper();\n        this._definitionChanged = new Event();\n        this._intervals = new TimeIntervalCollection();\n        this._intervals.changedEvent.addEventListener(CompositeProperty.prototype._intervalsChanged, this);\n    }\n\n    defineProperties(CompositeProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._intervals.isEmpty;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._intervals;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositeProperty.prototype.getValue = function(time, result) {\n        \n\n        var innerProperty = this._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValue(time, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositeProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositeProperty && //\n                this._intervals.equals(other._intervals, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositeProperty.prototype._intervalsChanged = function() {\n        subscribeAll(this, this._eventHelper, this._definitionChanged, this._intervals);\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default CompositeProperty;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport CompositeProperty from './CompositeProperty.js';\nimport Property from './Property.js';\n\n    /**\n     * A {@link CompositeProperty} which is also a {@link PositionProperty}.\n     *\n     * @alias CompositePositionProperty\n     * @constructor\n     *\n     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.\n     */\n    function CompositePositionProperty(referenceFrame) {\n        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n        this._definitionChanged = new Event();\n        this._composite = new CompositeProperty();\n        this._composite.definitionChanged.addEventListener(CompositePositionProperty.prototype._raiseDefinitionChanged, this);\n    }\n\n    defineProperties(CompositePositionProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._composite.isConstant;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._composite.intervals;\n            }\n        },\n        /**\n         * Gets or sets the reference frame which this position presents itself as.\n         * Each PositionProperty making up this object has it's own reference frame,\n         * so this property merely exposes a \"preferred\" reference frame for clients\n         * to use.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {ReferenceFrame}\n         */\n        referenceFrame : {\n            get : function() {\n                return this._referenceFrame;\n            },\n            set : function(value) {\n                this._referenceFrame = value;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time in the fixed frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValueInReferenceFrame(time, referenceFrame, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositePositionProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositePositionProperty && //\n                this._referenceFrame === other._referenceFrame && //\n                this._composite.equals(other._composite, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositePositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default CompositePositionProperty;\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Event from '../Core/Event.js';\nimport RuntimeError from '../Core/RuntimeError.js';\nimport Property from './Property.js';\n\n    function resolveEntity(that) {\n        var entityIsResolved = true;\n        if (that._resolveEntity) {\n            var targetEntity = that._targetCollection.getById(that._targetId);\n\n            if (defined(targetEntity)) {\n                targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);\n                that._targetEntity = targetEntity;\n                that._resolveEntity = false;\n            } else {\n                //The property has become detached.  It has a valid value but is not currently resolved to an entity in the collection\n                targetEntity = that._targetEntity;\n                entityIsResolved = false;\n            }\n\n            if (!defined(targetEntity)) {\n                throw new RuntimeError('target entity \"' + that._targetId + '\" could not be resolved.');\n            }\n        }\n        return entityIsResolved;\n    }\n\n    function resolve(that) {\n        var targetProperty = that._targetProperty;\n\n        if (that._resolveProperty) {\n            var entityIsResolved = resolveEntity(that);\n\n            var names = that._targetPropertyNames;\n            targetProperty = that._targetEntity;\n            var length = names.length;\n            for (var i = 0; i < length && defined(targetProperty); i++) {\n                targetProperty = targetProperty[names[i]];\n            }\n\n            if (defined(targetProperty)) {\n                that._targetProperty = targetProperty;\n                that._resolveProperty = !entityIsResolved;\n            } else if (!defined(that._targetProperty)) {\n                throw new RuntimeError('targetProperty \"' + that._targetId + '.' + names.join('.') + '\" could not be resolved.');\n            }\n        }\n\n        return targetProperty;\n    }\n\n    /**\n     * A {@link Property} which transparently links to another property on a provided object.\n     *\n     * @alias ReferenceProperty\n     * @constructor\n     *\n     * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.\n     * @param {String} targetId The id of the entity which is being referenced.\n     * @param {String[]} targetPropertyNames The names of the property on the target entity which we will use.\n     *\n     * @example\n     * var collection = new Cesium.EntityCollection();\n     *\n     * //Create a new entity and assign a billboard scale.\n     * var object1 = new Cesium.Entity({id:'object1'});\n     * object1.billboard = new Cesium.BillboardGraphics();\n     * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object1);\n     *\n     * //Create a second entity and reference the scale from the first one.\n     * var object2 = new Cesium.Entity({id:'object2'});\n     * object2.model = new Cesium.ModelGraphics();\n     * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n     * collection.add(object2);\n     *\n     * //Create a third object, but use the fromString helper function.\n     * var object3 = new Cesium.Entity({id:'object3'});\n     * object3.billboard = new Cesium.BillboardGraphics();\n     * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n     * collection.add(object3);\n     *\n     * //You can refer to an entity with a # or . in id and property names by escaping them.\n     * var object4 = new Cesium.Entity({id:'#object.4'});\n     * object4.billboard = new Cesium.BillboardGraphics();\n     * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object4);\n     *\n     * var object5 = new Cesium.Entity({id:'object5'});\n     * object5.billboard = new Cesium.BillboardGraphics();\n     * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n     * collection.add(object5);\n     */\n    function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {\n        \n\n        this._targetCollection = targetCollection;\n        this._targetId = targetId;\n        this._targetPropertyNames = targetPropertyNames;\n        this._targetProperty = undefined;\n        this._targetEntity = undefined;\n        this._definitionChanged = new Event();\n        this._resolveEntity = true;\n        this._resolveProperty = true;\n\n        targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);\n    }\n\n    defineProperties(ReferenceProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof ReferenceProperty.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(resolve(this));\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever the referenced property's definition is changed.\n         * @memberof ReferenceProperty.prototype\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the reference frame that the position is defined in.\n         * This property is only valid if the referenced property is a {@link PositionProperty}.\n         * @memberof ReferenceProperty.prototype\n         * @type {ReferenceFrame}\n         * @readonly\n         */\n        referenceFrame : {\n            get : function() {\n                return resolve(this).referenceFrame;\n            }\n        },\n        /**\n         * Gets the id of the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {String}\n         * @readonly\n         */\n        targetId : {\n            get : function() {\n                return this._targetId;\n            }\n        },\n        /**\n         * Gets the collection containing the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {EntityCollection}\n         * @readonly\n         */\n        targetCollection : {\n            get : function() {\n                return this._targetCollection;\n            }\n        },\n        /**\n         * Gets the array of property names used to retrieve the referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {String[]}\n         * @readonly\n         */\n        targetPropertyNames : {\n            get : function() {\n                return this._targetPropertyNames;\n            }\n        },\n        /**\n         * Gets the resolved instance of the underlying referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {Property}\n         * @readonly\n         */\n        resolvedProperty : {\n            get : function() {\n                return resolve(this);\n            }\n        }\n    });\n\n    /**\n     * Creates a new instance given the entity collection that will\n     * be used to resolve it and a string indicating the target entity id and property.\n     * The format of the string is \"objectId#foo.bar\", where # separates the id from\n     * property path and . separates sub-properties.  If the reference identifier or\n     * or any sub-properties contains a # . or \\ they must be escaped.\n     *\n     * @param {EntityCollection} targetCollection\n     * @param {String} referenceString\n     * @returns {ReferenceProperty} A new instance of ReferenceProperty.\n     *\n     * @exception {DeveloperError} invalid referenceString.\n     */\n    ReferenceProperty.fromString = function(targetCollection, referenceString) {\n        \n\n        var identifier;\n        var values = [];\n\n        var inIdentifier = true;\n        var isEscaped = false;\n        var token = '';\n        for (var i = 0; i < referenceString.length; ++i) {\n            var c = referenceString.charAt(i);\n\n            if (isEscaped) {\n                token += c;\n                isEscaped = false;\n            } else if (c === '\\\\') {\n                isEscaped = true;\n            } else if (inIdentifier && c === '#') {\n                identifier = token;\n                inIdentifier = false;\n                token = '';\n            } else if (!inIdentifier && c === '.') {\n                values.push(token);\n                token = '';\n            } else {\n                token += c;\n            }\n        }\n        values.push(token);\n\n        return new ReferenceProperty(targetCollection, identifier, values);\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValue = function(time, result) {\n        return resolve(this).getValue(time, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     * This method is only valid if the property being referenced is a {@link PositionProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);\n    };\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * This method is only valid if the property being referenced is a {@link MaterialProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    ReferenceProperty.prototype.getType = function(time) {\n        return resolve(this).getType(time);\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    ReferenceProperty.prototype.equals = function(other) {\n        if (this === other) {\n            return true;\n        }\n\n        var names = this._targetPropertyNames;\n        var otherNames = other._targetPropertyNames;\n\n        if (this._targetCollection !== other._targetCollection || //\n            this._targetId !== other._targetId || //\n            names.length !== otherNames.length) {\n            return false;\n        }\n\n        var length = this._targetPropertyNames.length;\n        for (var i = 0; i < length; i++) {\n            if (names[i] !== otherNames[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {\n        if (this._targetPropertyNames[0] === name) {\n            this._resolveProperty = true;\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {\n        var targetEntity = this._targetEntity;\n        if (defined(targetEntity)) {\n            if (removed.indexOf(targetEntity) !== -1) {\n                targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);\n                this._resolveEntity = true;\n                this._resolveProperty = true;\n            } else if (this._resolveEntity) {\n                //If targetEntity is defined but resolveEntity is true, then the entity is detached\n                //and any change to the collection needs to incur an attempt to resolve in order to re-attach.\n                //without this if block, a reference that becomes re-attached will not signal definitionChanged\n                resolve(this);\n                if (!this._resolveEntity) {\n                    this._definitionChanged.raiseEvent(this);\n                }\n            }\n        }\n    };\nexport default ReferenceProperty;\n","import defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Ellipsoid from '../Core/Ellipsoid.js';\nimport Event from '../Core/Event.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport Property from './Property.js';\n\n    /**\n     * This is a temporary class for scaling position properties to the WGS84 surface.\n     * It will go away or be refactored to support data with arbitrary height references.\n     * @private\n     */\n    function ScaledPositionProperty(value) {\n        this._definitionChanged = new Event();\n        this._value = undefined;\n        this._removeSubscription = undefined;\n        this.setValue(value);\n    }\n\n    defineProperties(ScaledPositionProperty.prototype, {\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._value);\n            }\n        },\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        referenceFrame : {\n            get : function() {\n                return defined(this._value) ? this._value.referenceFrame : ReferenceFrame.FIXED;\n            }\n        }\n    });\n\n    ScaledPositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    ScaledPositionProperty.prototype.setValue = function(value) {\n        if (this._value !== value) {\n            this._value = value;\n\n            if (defined(this._removeSubscription)) {\n                this._removeSubscription();\n                this._removeSubscription = undefined;\n            }\n\n            if (defined(value)) {\n                this._removeSubscription = value.definitionChanged.addEventListener(this._raiseDefinitionChanged, this);\n            }\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ScaledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        if (!defined(this._value)) {\n            return undefined;\n        }\n\n        result = this._value.getValueInReferenceFrame(time, referenceFrame, result);\n        return defined(result) ? Ellipsoid.WGS84.scaleToGeodeticSurface(result, result) : undefined;\n    };\n\n    ScaledPositionProperty.prototype.equals = function(other) {\n        return this === other || (other instanceof ScaledPositionProperty && this._value === other._value);\n    };\n\n    ScaledPositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\nexport default ScaledPositionProperty;\n","import Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport PrimitiveCollection from './PrimitiveCollection.js';\n\n    /**\n     * A primitive collection for helping maintain the order or ground primitives based on a z-index\n     *\n     * @private\n     */\n    function OrderedGroundPrimitiveCollection() {\n        this._length = 0;\n        this._collections = {};\n        this._collectionsArray = [];\n\n        this.show = true;\n    }\n\n    defineProperties(OrderedGroundPrimitiveCollection.prototype, {\n        /**\n         * Gets the number of primitives in the collection.\n         *\n         * @memberof OrderedGroundPrimitiveCollection.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        length : {\n            get : function() {\n                return this._length;\n            }\n        }\n    });\n\n    /**\n     * Adds a primitive to the collection.\n     *\n     * @param {GroundPrimitive} primitive The primitive to add.\n     * @param {Number} [zIndex = 0] The index of the primitive\n     * @returns {GroundPrimitive} The primitive added to the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.add = function(primitive, zIndex) {\n        \n\n        zIndex = defaultValue(zIndex, 0);\n        var collection = this._collections[zIndex];\n        if (!defined(collection)) {\n            collection = new PrimitiveCollection({ destroyPrimitives: false });\n            collection._zIndex = zIndex;\n            this._collections[zIndex] = collection;\n            var array = this._collectionsArray;\n            var i = 0;\n            while (i < array.length && array[i]._zIndex < zIndex) {\n                i++;\n            }\n            array.splice(i, 0, collection);\n        }\n\n        collection.add(primitive);\n        this._length++;\n        primitive._zIndex = zIndex;\n\n        return primitive;\n    };\n\n    /**\n     * Adjusts the z-index\n     * @param {GroundPrimitive} primitive\n     * @param {Number} zIndex\n     */\n    OrderedGroundPrimitiveCollection.prototype.set = function(primitive, zIndex) {\n        \n\n        if (zIndex === primitive._zIndex) {\n            return primitive;\n        }\n\n        this.remove(primitive, true);\n        this.add(primitive, zIndex);\n\n        return primitive;\n    };\n\n    /**\n     * Removes a primitive from the collection.\n     *\n     * @param {Object} primitive The primitive to remove.\n     * @param {Boolean} [doNotDestroy = false]\n     * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.remove = function(primitive, doNotDestroy) {\n        if (this.contains(primitive)) {\n            var index = primitive._zIndex;\n            var collection = this._collections[index];\n            var result;\n            if (doNotDestroy) {\n                result = collection.remove(primitive);\n            } else {\n                result = collection.removeAndDestroy(primitive);\n            }\n\n            if (result) {\n                this._length--;\n            }\n\n            if (collection.length === 0) {\n                this._collectionsArray.splice(this._collectionsArray.indexOf(collection), 1);\n                this._collections[index] = undefined;\n                collection.destroy();\n            }\n\n            return result;\n        }\n\n        return false;\n    };\n\n    /**\n     * Removes all primitives in the collection.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroyPrimitives\n     */\n    OrderedGroundPrimitiveCollection.prototype.removeAll = function() {\n        var collections = this._collectionsArray;\n        for (var i = 0; i < collections.length; i++) {\n            var collection = collections[i];\n            collection.destroyPrimitives = true;\n            collection.destroy();\n        }\n\n        this._collections = {};\n        this._collectionsArray = [];\n        this._length = 0;\n    };\n\n    /**\n     * Determines if this collection contains a primitive.\n     *\n     * @param {Object} primitive The primitive to check for.\n     * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.contains = function(primitive) {\n        if (!defined(primitive)) {\n            return false;\n        }\n        var collection = this._collections[primitive._zIndex];\n        return defined(collection) && collection.contains(primitive);\n    };\n\n    /**\n     * @private\n     */\n    OrderedGroundPrimitiveCollection.prototype.update = function(frameState) {\n        if (!this.show) {\n            return;\n        }\n\n        var collections = this._collectionsArray;\n        for (var i = 0 ; i < collections.length; i++) {\n            collections[i].update(frameState);\n        }\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroy\n     */\n    OrderedGroundPrimitiveCollection.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this\n     * collection allows for deterministic release of WebGL resources, instead of relying on the garbage\n     * collector to destroy this collection.\n     * <br /><br />\n     * Since destroying a collection destroys all the contained primitives, only destroy a collection\n     * when you are sure no other code is still using any of the contained primitives.\n     * <br /><br />\n     * Once this collection is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * primitives = primitives && primitives.destroy();\n     *\n     * @see OrderedGroundPrimitiveCollection#isDestroyed\n     */\n    OrderedGroundPrimitiveCollection.prototype.destroy = function() {\n        this.removeAll();\n        return destroyObject(this);\n    };\nexport default OrderedGroundPrimitiveCollection;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingRectangle from '../Core/BoundingRectangle.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport HorizontalOrigin from '../Scene/HorizontalOrigin.js';\nimport VerticalOrigin from '../Scene/VerticalOrigin.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultColor = Color.WHITE;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultScale = 1.0;\n    var defaultRotation = 0.0;\n    var defaultAlignedAxis = Cartesian3.ZERO;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n    var defaultSizeInMeters = false;\n\n    var positionScratch = new Cartesian3();\n    var colorScratch = new Color();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var boundingRectangleScratch = new BoundingRectangle();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.billboard = undefined;\n        this.textureValue = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.\n     * @alias BillboardVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function BillboardVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    BillboardVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var billboardGraphics = entity._billboard;\n            var textureValue;\n            var billboard = item.billboard;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(billboardGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                textureValue = Property.getValueOrUndefined(billboardGraphics._image, time);\n                show = defined(position) && defined(textureValue);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            if (!defined(billboard)) {\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n            }\n\n            billboard.show = show;\n            if (!defined(billboard.image) || item.textureValue !== textureValue) {\n                billboard.image = textureValue;\n                item.textureValue = textureValue;\n            }\n            billboard.position = position;\n            billboard.color = Property.getValueOrDefault(billboardGraphics._color, time, defaultColor, colorScratch);\n            billboard.eyeOffset = Property.getValueOrDefault(billboardGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            billboard.heightReference = Property.getValueOrDefault(billboardGraphics._heightReference, time, defaultHeightReference);\n            billboard.pixelOffset = Property.getValueOrDefault(billboardGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            billboard.scale = Property.getValueOrDefault(billboardGraphics._scale, time, defaultScale);\n            billboard.rotation = Property.getValueOrDefault(billboardGraphics._rotation, time, defaultRotation);\n            billboard.alignedAxis = Property.getValueOrDefault(billboardGraphics._alignedAxis, time, defaultAlignedAxis);\n            billboard.horizontalOrigin = Property.getValueOrDefault(billboardGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            billboard.verticalOrigin = Property.getValueOrDefault(billboardGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            billboard.width = Property.getValueOrUndefined(billboardGraphics._width, time);\n            billboard.height = Property.getValueOrUndefined(billboardGraphics._height, time);\n            billboard.scaleByDistance = Property.getValueOrUndefined(billboardGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            billboard.translucencyByDistance = Property.getValueOrUndefined(billboardGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            billboard.pixelOffsetScaleByDistance = Property.getValueOrUndefined(billboardGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            billboard.sizeInMeters = Property.getValueOrDefault(billboardGraphics._sizeInMeters, time, defaultSizeInMeters);\n            billboard.distanceDisplayCondition = Property.getValueOrUndefined(billboardGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            billboard.disableDepthTestDistance = Property.getValueOrUndefined(billboardGraphics._disableDepthTestDistance, time);\n\n            var subRegion = Property.getValueOrUndefined(billboardGraphics._imageSubRegion, time, boundingRectangleScratch);\n            if (defined(subRegion)) {\n                billboard.setImageSubRegion(billboard._imageId, subRegion);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    BillboardVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.billboard)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var billboard = item.billboard;\n        if (billboard.heightReference === HeightReference.NONE) {\n            result.center = Cartesian3.clone(billboard.position, result.center);\n        } else {\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    BillboardVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    BillboardVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeBillboard(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    BillboardVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.billboard = undefined;\n            cluster.removeBillboard(entity);\n        }\n    }\nexport default BillboardVisualizer;\n","import defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport freezeObject from '../Core/freezeObject.js';\nimport VertexFormat from '../Core/VertexFormat.js';\nimport AllMaterialAppearanceFS from '../Shaders/Appearances/AllMaterialAppearanceFS.js';\nimport AllMaterialAppearanceVS from '../Shaders/Appearances/AllMaterialAppearanceVS.js';\nimport BasicMaterialAppearanceFS from '../Shaders/Appearances/BasicMaterialAppearanceFS.js';\nimport BasicMaterialAppearanceVS from '../Shaders/Appearances/BasicMaterialAppearanceVS.js';\nimport TexturedMaterialAppearanceFS from '../Shaders/Appearances/TexturedMaterialAppearanceFS.js';\nimport TexturedMaterialAppearanceVS from '../Shaders/Appearances/TexturedMaterialAppearanceVS.js';\nimport Appearance from './Appearance.js';\nimport Material from './Material.js';\n\n    /**\n     * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)\n     * that supports shading with materials.\n     *\n     * @alias MaterialAppearance\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.\n     * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.\n     * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.\n     * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.\n     * @param {MaterialAppearance.MaterialSupport} [options.materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] The type of materials that will be supported.\n     * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n     * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n     * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n     * @param {RenderState} [options.renderState] Optional render state to override the default render state.\n     *\n     * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Materials.html|Cesium Sandcastle Material Appearance Demo}\n     *\n     * @example\n     * var primitive = new Cesium.Primitive({\n     *   geometryInstances : new Cesium.GeometryInstance({\n     *     geometry : new Cesium.WallGeometry({\n            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,\n     *       // ...\n     *     })\n     *   }),\n     *   appearance : new Cesium.MaterialAppearance({\n     *     material : Cesium.Material.fromType('Color'),\n     *     faceForward : true\n     *   })\n     *\n     * });\n     */\n    function MaterialAppearance(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var translucent = defaultValue(options.translucent, true);\n        var closed = defaultValue(options.closed, false);\n        var materialSupport = defaultValue(options.materialSupport, MaterialAppearance.MaterialSupport.TEXTURED);\n\n        /**\n         * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}\n         * properties, this is not read-only, so an appearance's material can change on the fly.\n         *\n         * @type Material\n         *\n         * @default {@link Material.ColorType}\n         *\n         * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n         */\n        this.material = (defined(options.material)) ? options.material : Material.fromType(Material.ColorType);\n\n        /**\n         * When <code>true</code>, the geometry is expected to appear translucent.\n         *\n         * @type {Boolean}\n         *\n         * @default true\n         */\n        this.translucent = translucent;\n\n        this._vertexShaderSource = defaultValue(options.vertexShaderSource, materialSupport.vertexShaderSource);\n        this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, materialSupport.fragmentShaderSource);\n        this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);\n        this._closed = closed;\n\n        // Non-derived members\n\n        this._materialSupport = materialSupport;\n        this._vertexFormat = materialSupport.vertexFormat;\n        this._flat = defaultValue(options.flat, false);\n        this._faceForward = defaultValue(options.faceForward, !closed);\n    }\n\n    defineProperties(MaterialAppearance.prototype, {\n        /**\n         * The GLSL source code for the vertex shader.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        vertexShaderSource : {\n            get : function() {\n                return this._vertexShaderSource;\n            }\n        },\n\n        /**\n         * The GLSL source code for the fragment shader.  The full fragment shader\n         * source is built procedurally taking into account {@link MaterialAppearance#material},\n         * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n         * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        fragmentShaderSource : {\n            get : function() {\n                return this._fragmentShaderSource;\n            }\n        },\n\n        /**\n         * The WebGL fixed-function state to use when rendering the geometry.\n         * <p>\n         * The render state can be explicitly defined when constructing a {@link MaterialAppearance}\n         * instance, or it is set implicitly via {@link MaterialAppearance#translucent}\n         * and {@link MaterialAppearance#closed}.\n         * </p>\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Object}\n         * @readonly\n         */\n        renderState : {\n            get : function() {\n                return this._renderState;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the geometry is expected to be closed so\n         * {@link MaterialAppearance#renderState} has backface culling enabled.\n         * If the viewer enters the geometry, it will not be visible.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        closed : {\n            get : function() {\n                return this._closed;\n            }\n        },\n\n        /**\n         * The type of materials supported by this instance.  This impacts the required\n         * {@link VertexFormat} and the complexity of the vertex and fragment shaders.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {MaterialAppearance.MaterialSupport}\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED}\n         */\n        materialSupport : {\n            get : function() {\n                return this._materialSupport;\n            }\n        },\n\n        /**\n         * The {@link VertexFormat} that this appearance instance is compatible with.\n         * A geometry can have more vertex attributes and still be compatible - at a\n         * potential performance cost - but it can't have less.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type VertexFormat\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat}\n         */\n        vertexFormat : {\n            get : function() {\n                return this._vertexFormat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, flat shading is used in the fragment shader,\n         * which means lighting is not taking into account.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        flat : {\n            get : function() {\n                return this._flat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the fragment shader flips the surface normal\n         * as needed to ensure that the normal faces the viewer to avoid\n         * dark spots.  This is useful when both sides of a geometry should be\n         * shaded like {@link WallGeometry}.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default true\n         */\n        faceForward : {\n            get : function() {\n                return this._faceForward;\n            }\n        }\n    });\n\n    /**\n     * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},\n     * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},\n     * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n     *\n     * @function\n     *\n     * @returns {String} The full GLSL fragment shader source.\n     */\n    MaterialAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;\n\n    /**\n     * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.\n     *\n     * @function\n     *\n     * @returns {Boolean} <code>true</code> if the appearance is translucent.\n     */\n    MaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;\n\n    /**\n     * Creates a render state.  This is not the final render state instance; instead,\n     * it can contain a subset of render state properties identical to the render state\n     * created in the context.\n     *\n     * @function\n     *\n     * @returns {Object} The render state.\n     */\n    MaterialAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;\n\n    /**\n     * Determines the type of {@link Material} that is supported by a\n     * {@link MaterialAppearance} instance.  This is a trade-off between\n     * flexibility (a wide array of materials) and memory/performance\n     * (required vertex format and GLSL shader complexity.\n     * @exports MaterialAppearance.MaterialSupport\n     */\n    MaterialAppearance.MaterialSupport = {\n        /**\n         * Only basic materials, which require just <code>position</code> and\n         * <code>normal</code> vertex attributes, are supported.\n         *\n         * @constant\n         */\n        BASIC : freezeObject({\n            vertexFormat : VertexFormat.POSITION_AND_NORMAL,\n            vertexShaderSource : BasicMaterialAppearanceVS,\n            fragmentShaderSource : BasicMaterialAppearanceFS\n        }),\n        /**\n         * Materials with textures, which require <code>position</code>,\n         * <code>normal</code>, and <code>st</code> vertex attributes,\n         * are supported.  The vast majority of materials fall into this category.\n         *\n         * @constant\n         */\n        TEXTURED : freezeObject({\n            vertexFormat : VertexFormat.POSITION_NORMAL_AND_ST,\n            vertexShaderSource : TexturedMaterialAppearanceVS,\n            fragmentShaderSource : TexturedMaterialAppearanceFS\n        }),\n        /**\n         * All materials, including those that work in tangent space, are supported.\n         * This requires <code>position</code>, <code>normal</code>, <code>st</code>,\n         * <code>tangent</code>, and <code>bitangent</code> vertex attributes.\n         *\n         * @constant\n         */\n        ALL : freezeObject({\n            vertexFormat : VertexFormat.ALL,\n            vertexShaderSource : AllMaterialAppearanceVS,\n            fragmentShaderSource : AllMaterialAppearanceFS\n        })\n    };\nexport default MaterialAppearance;\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec3 tangent;\\n\\\nattribute vec3 bitangent;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\\n\\\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","import ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\n\n    /**\n     * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.\n     *\n     * @alias DistanceDisplayConditionGeometryInstanceAttribute\n     * @constructor\n     *\n     * @param {Number} [near=0.0] The near distance.\n     * @param {Number} [far=Number.MAX_VALUE] The far distance.\n     *\n     * @exception {DeveloperError} far must be greater than near.\n     *\n     * @example\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : new Cesium.BoxGeometry({\n     *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n     *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n     *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n     *   }),\n     *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n     *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n     *   id : 'box',\n     *   attributes : {\n     *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n     *   }\n     * });\n     *\n     * @see GeometryInstance\n     * @see GeometryInstanceAttribute\n     */\n    function DistanceDisplayConditionGeometryInstanceAttribute(near, far) {\n        near = defaultValue(near, 0.0);\n        far = defaultValue(far, Number.MAX_VALUE);\n\n        \n\n        /**\n         * The values for the attributes stored in a typed array.\n         *\n         * @type Float32Array\n         *\n         * @default [0.0, 0.0, Number.MAX_VALUE]\n         */\n        this.value = new Float32Array([near, far]);\n    }\n\n    defineProperties(DistanceDisplayConditionGeometryInstanceAttribute.prototype, {\n        /**\n         * The datatype of each component in the attribute, e.g., individual elements in\n         * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {ComponentDatatype}\n         * @readonly\n         *\n         * @default {@link ComponentDatatype.FLOAT}\n         */\n        componentDatatype : {\n            get : function() {\n                return ComponentDatatype.FLOAT;\n            }\n        },\n\n        /**\n         * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Number}\n         * @readonly\n         *\n         * @default 3\n         */\n        componentsPerAttribute : {\n            get : function() {\n                return 2;\n            }\n        },\n\n        /**\n         * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n         * indicate that the components should be mapped to the range [0, 1] (unsigned)\n         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        normalize : {\n            get : function() {\n                return false;\n            }\n        }\n    });\n\n    /**\n     * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.\n     * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.\n     *\n     * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n     *\n     * @example\n     * var distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : geometry,\n     *   attributes : {\n     *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n     *   }\n     * });\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition = function(distanceDisplayCondition) {\n        \n\n        return new DistanceDisplayConditionGeometryInstanceAttribute(distanceDisplayCondition.near, distanceDisplayCondition.far);\n    };\n\n    /**\n     * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.\n     * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n     * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n     *\n     * @example\n     * var attributes = primitive.getGeometryInstanceAttributes('an id');\n     * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.toValue = function(distanceDisplayCondition, result) {\n        \n\n        if (!defined(result)) {\n            return new Float32Array([distanceDisplayCondition.near, distanceDisplayCondition.far]);\n        }\n        result[0] = distanceDisplayCondition.near;\n        result[1] = distanceDisplayCondition.far;\n        return result;\n    };\nexport default DistanceDisplayConditionGeometryInstanceAttribute;\n","import Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Material from '../Scene/Material.js';\n\n    /**\n     * The interface for all {@link Property} objects that represent {@link Material} uniforms.\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias MaterialProperty\n     * @constructor\n     * @abstract\n     *\n     * @see ColorMaterialProperty\n     * @see CompositeMaterialProperty\n     * @see GridMaterialProperty\n     * @see ImageMaterialProperty\n     * @see PolylineGlowMaterialProperty\n     * @see PolylineOutlineMaterialProperty\n     * @see StripeMaterialProperty\n     */\n    function MaterialProperty() {\n        DeveloperError.throwInstantiationError();\n    }\n\n    defineProperties(MaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : DeveloperError.throwInstantiationError\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : DeveloperError.throwInstantiationError\n        }\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    MaterialProperty.prototype.getType = DeveloperError.throwInstantiationError;\n\n    /**\n     * Gets the value of the property at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    MaterialProperty.prototype.getValue = DeveloperError.throwInstantiationError;\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     * @function\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    MaterialProperty.prototype.equals = DeveloperError.throwInstantiationError;\n\n    /**\n     * @private\n     */\n    MaterialProperty.getValue = function(time, materialProperty, material) {\n        var type;\n\n        if (defined(materialProperty)) {\n            type = materialProperty.getType(time);\n            if (defined(type)) {\n                if (!defined(material) || (material.type !== type)) {\n                    material = Material.fromType(type);\n                }\n                materialProperty.getValue(time, material.uniforms);\n                return material;\n            }\n        }\n\n        if (!defined(material) || (material.type !== Material.ColorType)) {\n            material = Material.fromType(Material.ColorType);\n        }\n        Color.clone(Color.WHITE, material.uniforms.color);\n\n        return material;\n    };\nexport default MaterialProperty;\n","import BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    /**\n     * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n     * is responsible for handling visualization of a specific type of geometry\n     * that needs to be recomputed based on simulation time.\n     * This object is never used directly by client code, but is instead created by\n     * {@link GeometryUpdater} implementations which contain dynamic geometry.\n     *\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias DynamicGeometryUpdater\n     * @constructor\n     * @private\n     * @abstract\n     */\n    function DynamicGeometryUpdater(geometryUpdater, primitives, orderedGroundPrimitives) {\n        \n\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._primitive = undefined;\n        this._outlinePrimitive = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._options = geometryUpdater._options;\n        this._entity = geometryUpdater._entity;\n        this._material = undefined;\n    }\n\n    DynamicGeometryUpdater.prototype._isHidden = function(entity, geometry, time) {\n        return !entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(geometry.show, time, true);\n    };\n\n    DynamicGeometryUpdater.prototype._setOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * Updates the geometry to the specified time.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @param {JulianDate} time The current time.\n     */\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        \n\n        var geometryUpdater = this._geometryUpdater;\n        var onTerrain = geometryUpdater._onTerrain;\n\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._outlinePrimitive = undefined;\n        }\n        this._primitive = undefined;\n\n        var entity = this._entity;\n        var geometry = entity[this._geometryUpdater._geometryPropertyName];\n        this._setOptions(entity, geometry, time);\n        if (this._isHidden(entity, geometry, time)) {\n            return;\n        }\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n        var options = this._options;\n        if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var isColorAppearance = fillMaterialProperty instanceof ColorMaterialProperty;\n            var appearance;\n            var closed = geometryUpdater._getIsClosed(options);\n            if (isColorAppearance) {\n                appearance = new PerInstanceColorAppearance({\n                    closed: closed,\n                    flat : onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain\n                });\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                this._material = material;\n                appearance = new MaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent(),\n                    closed : closed\n                });\n            }\n\n            if (onTerrain) {\n                options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n                this._primitive = orderedGroundPrimitives.add(new GroundPrimitive({\n                    geometryInstances : this._geometryUpdater.createFillGeometryInstance(time),\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows,\n                    classificationType : this._geometryUpdater.classificationTypeProperty.getValue(time)\n                }), Property.getValueOrUndefined(this._geometryUpdater.zIndex, time));\n            } else {\n                options.vertexFormat = appearance.vertexFormat;\n\n                var fillInstance = this._geometryUpdater.createFillGeometryInstance(time);\n\n                if (isColorAppearance) {\n                    appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n                }\n\n                this._primitive = primitives.add(new Primitive({\n                    geometryInstances : fillInstance,\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows\n                }));\n            }\n        }\n\n        if (!onTerrain && defined(geometry.outline) && geometry.outline.getValue(time)) {\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time);\n            var outlineWidth = Property.getValueOrDefault(geometry.outlineWidth, time, 1.0);\n\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n        }\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     * @function\n     *\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n        var entity = this._entity;\n        var primitive = this._primitive;\n        var outlinePrimitive = this._outlinePrimitive;\n\n        var attributes;\n\n        //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n        if (defined(primitive) && primitive.show && primitive.ready) {\n            attributes = primitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if (defined(outlinePrimitive) && outlinePrimitive.show && outlinePrimitive.ready) {\n            attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if ((defined(primitive) && !primitive.ready) || (defined(outlinePrimitive) && !outlinePrimitive.ready)) {\n            return BoundingSphereState.PENDING;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (this._geometryUpdater._onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n        }\n        primitives.removeAndDestroy(this._outlinePrimitive);\n        destroyObject(this);\n    };\nexport default DynamicGeometryUpdater;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport Event from '../Core/Event.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport Entity from './Entity.js';\nimport Property from './Property.js';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultFill = new ConstantProperty(true);\n    var defaultOutline = new ConstantProperty(false);\n    var defaultOutlineColor = new ConstantProperty(Color.BLACK);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    /**\n     * An abstract class for updating geometry entities.\n     * @alias GeometryUpdater\n     * @constructor\n     *\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GeometryUpdater(options) {\n        \n\n        var entity = options.entity;\n        var geometryPropertyName = options.geometryPropertyName;\n\n        this._entity = entity;\n        this._scene = options.scene;\n        this._fillEnabled = false;\n        this._isClosed = false;\n        this._onTerrain = false;\n        this._dynamic = false;\n        this._outlineEnabled = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._showOutlineProperty = undefined;\n        this._outlineColorProperty = undefined;\n        this._outlineWidth = 1.0;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._options = options.geometryOptions;\n        this._geometryPropertyName = geometryPropertyName;\n        this._id = geometryPropertyName + '-' + entity.id;\n        this._observedPropertyNames = options.observedPropertyNames;\n        this._supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(options.scene);\n    }\n\n    defineProperties(GeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof GeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id : {\n            get : function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._fillProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            get : function() {\n                return this._outlineEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            get : function() {\n                return !this._outlineEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._showOutlineProperty));\n            }\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            get : function() {\n                return this._outlineColorProperty;\n            }\n        },\n        /**\n         * Gets the constant with of the geometry outline, in pixels.\n         * This value is only valid if isDynamic is false.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        outlineWidth : {\n            get : function() {\n                return this._outlineWidth;\n            }\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from each light source.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to a DynamicGeometryUpdater\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            get : function() {\n                return this._isClosed;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry should be drawn on terrain.\n         * @memberof EllipseGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        onTerrain : {\n            get : function() {\n                return this._onTerrain;\n            }\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isOutlineVisible = function(time) {\n        var entity = this._entity;\n        var visible = this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    GeometryUpdater.prototype.createFillGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    GeometryUpdater.prototype.createOutlineGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GeometryUpdater.prototype.destroy = function() {\n        destroyObject(this);\n    };\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isHidden = function(entity, geometry) {\n        var show = geometry.show;\n        return defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE);\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return false;\n    };\n\n    /**\n     * @param {GeometryOptions} options\n     * @private\n     */\n    GeometryUpdater.prototype._getIsClosed = function(options) {\n        return true;\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isDynamic = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._setStaticOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {String} propertyName\n     * @param {*} newValue\n     * @param {*} oldValue\n     * @private\n     */\n    GeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n\n        if (!defined(geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var fillProperty = geometry.fill;\n        var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;\n\n        var outlineProperty = geometry.outline;\n        var outlineEnabled = defined(outlineProperty);\n        if (outlineEnabled && outlineProperty.isConstant) {\n            outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);\n        }\n\n        if (!fillEnabled && !outlineEnabled) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var show = geometry.show;\n        if (this._isHidden(entity, geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        this._materialProperty = defaultValue(geometry.material, defaultMaterial);\n        this._fillProperty = defaultValue(fillProperty, defaultFill);\n        this._showProperty = defaultValue(show, defaultShow);\n        this._showOutlineProperty = defaultValue(geometry.outline, defaultOutline);\n        this._outlineColorProperty = outlineEnabled ? defaultValue(geometry.outlineColor, defaultOutlineColor) : undefined;\n        this._shadowsProperty = defaultValue(geometry.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(geometry.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(geometry.classificationType, defaultClassificationType);\n\n        this._fillEnabled = fillEnabled;\n\n        var onTerrain = this._isOnTerrain(entity, geometry) &&\n            (this._supportsMaterialsforEntitiesOnTerrain || this._materialProperty instanceof ColorMaterialProperty);\n\n        if (outlineEnabled && onTerrain) {\n            oneTimeWarning(oneTimeWarning.geometryOutlines);\n            outlineEnabled = false;\n        }\n\n        this._onTerrain = onTerrain;\n        this._outlineEnabled = outlineEnabled;\n\n        if (this._isDynamic(entity, geometry)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            this._setStaticOptions(entity, geometry);\n            this._isClosed = this._getIsClosed(this._options);\n            var outlineWidth = geometry.outlineWidth;\n            this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1.0;\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection} [groundPrimitives] The primitive collection to use for ground primitives.\n     *\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    GeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new this.constructor.DynamicGeometryUpdater(this, primitives, groundPrimitives);\n    };\nexport default GeometryUpdater;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Check from '../Core/Check.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport Event from '../Core/Event.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport CesiumMath from '../Core/Math.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport Property from './Property.js';\n\n    var scratchPosition = new Cartesian3();\n    var scratchCarto = new Cartographic();\n\n    /**\n     * @private\n     */\n    function TerrainOffsetProperty(scene, positionProperty, heightReferenceProperty, extrudedHeightReferenceProperty) {\n        \n\n        this._scene = scene;\n        this._heightReference = heightReferenceProperty;\n        this._extrudedHeightReference = extrudedHeightReferenceProperty;\n        this._positionProperty = positionProperty;\n\n        this._position = new Cartesian3();\n        this._cartographicPosition = new Cartographic();\n        this._normal = new Cartesian3();\n\n        this._definitionChanged = new Event();\n        this._terrainHeight = 0;\n        this._removeCallbackFunc = undefined;\n        this._removeEventListener = undefined;\n        this._removeModeListener = undefined;\n\n        var that = this;\n        if (defined(scene.globe)) {\n            this._removeEventListener = scene.terrainProviderChanged.addEventListener(function() {\n                that._updateClamping();\n            });\n            this._removeModeListener = scene.morphComplete.addEventListener(function() {\n                that._updateClamping();\n            });\n        }\n\n        if (positionProperty.isConstant) {\n            var position = positionProperty.getValue(Iso8601.MINIMUM_VALUE, scratchPosition);\n            if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n                return;\n            }\n            this._position = Cartesian3.clone(position, this._position);\n\n            this._updateClamping();\n\n            this._normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        }\n    }\n\n    defineProperties(TerrainOffsetProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return false;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        }\n    });\n\n    /**\n     * @private\n     */\n    TerrainOffsetProperty.prototype._updateClamping = function() {\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n\n        var scene = this._scene;\n        var globe = scene.globe;\n        var position = this._position;\n\n        if (!defined(globe) || Cartesian3.equals(position, Cartesian3.ZERO)) {\n            this._terrainHeight = 0;\n            return;\n        }\n        var ellipsoid = globe.ellipsoid;\n        var surface = globe._surface;\n\n        var that = this;\n        var cartographicPosition = ellipsoid.cartesianToCartographic(position, this._cartographicPosition);\n        var height = globe.getHeight(cartographicPosition);\n        if (defined(height)) {\n            this._terrainHeight = height;\n        } else {\n            this._terrainHeight = 0;\n        }\n\n        function updateFunction(clampedPosition) {\n            if (scene.mode === SceneMode.SCENE3D) {\n                var carto = ellipsoid.cartesianToCartographic(clampedPosition, scratchCarto);\n                that._terrainHeight = carto.height;\n            } else {\n                that._terrainHeight = clampedPosition.x;\n            }\n            that.definitionChanged.raiseEvent();\n        }\n        this._removeCallbackFunc = surface.updateHeight(cartographicPosition, updateFunction);\n    };\n\n    /**\n     * Gets the height relative to the terrain based on the positions.\n     *\n     * @returns {Cartesian3} The offset\n     */\n    TerrainOffsetProperty.prototype.getValue = function(time, result) {\n        var heightReference = Property.getValueOrDefault(this._heightReference, time, HeightReference.NONE);\n        var extrudedHeightReference = Property.getValueOrDefault(this._extrudedHeightReference, time, HeightReference.NONE);\n\n        if (heightReference === HeightReference.NONE && extrudedHeightReference !== HeightReference.RELATIVE_TO_GROUND) {\n            this._position = Cartesian3.clone(Cartesian3.ZERO, this._position);\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (this._positionProperty.isConstant) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        var scene = this._scene;\n        var position = this._positionProperty.getValue(time, scratchPosition);\n        if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (Cartesian3.equalsEpsilon(this._position, position, CesiumMath.EPSILON10)) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        this._position = Cartesian3.clone(position, this._position);\n\n        this._updateClamping();\n\n        var normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        return Cartesian3.multiplyByScalar(normal, this._terrainHeight, result);\n    };\n\n    TerrainOffsetProperty.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    TerrainOffsetProperty.prototype.destroy = function() {\n        if (defined(this._removeEventListener)) {\n            this._removeEventListener();\n        }\n        if (defined(this._removeModeListener)) {\n            this._removeModeListener();\n        }\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * A function which creates one or more providers.\n     * @callback TerrainOffsetProperty~PositionFunction\n     * @param {JulianDate} time The clock time at which to retrieve the position\n     * @param {Cartesian3} result The result position\n     * @returns {Cartesian3} The position at which to do the terrain height check\n     */\nexport default TerrainOffsetProperty;\n","import defined from '../Core/defined.js';\nimport CallbackProperty from './CallbackProperty.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport TerrainOffsetProperty from './TerrainOffsetProperty.js';\n\n    function heightReferenceOnEntityPropertyChanged(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n\n        if (defined(heightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty);\n        }\n    }\nexport default heightReferenceOnEntityPropertyChanged;\n","import BoxGeometry from '../Core/BoxGeometry.js';\nimport BoxOutlineGeometry from '../Core/BoxOutlineGeometry.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport Property from './Property.js';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function BoxGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.dimensions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for boxes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias BoxGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function BoxGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new BoxGeometryOptions(entity),\n            geometryPropertyName : 'box',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'box']\n        });\n\n        this._onEntityPropertyChanged(entity, 'box', entity.box, undefined);\n    }\n\n    if (defined(Object.create)) {\n        BoxGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        BoxGeometryUpdater.prototype.constructor = BoxGeometryUpdater;\n    }\n\n    defineProperties(BoxGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof BoxGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    BoxGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    BoxGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxOutlineGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    BoxGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    BoxGeometryUpdater.prototype._isHidden = function(entity, box) {\n        return !defined(box.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, box);\n    };\n\n    BoxGeometryUpdater.prototype._isDynamic = function(entity, box) {\n        return !entity.position.isConstant ||  !Property.isConstant(entity.orientation) ||  !box.dimensions.isConstant ||  !Property.isConstant(box.outlineWidth);\n    };\n\n    BoxGeometryUpdater.prototype._setStaticOptions = function(entity, box) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.dimensions = box.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    BoxGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    BoxGeometryUpdater.DynamicGeometryUpdater = DynamicBoxGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicBoxGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicBoxGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicBoxGeometryUpdater.prototype.constructor = DynamicBoxGeometryUpdater;\n    }\n\n    DynamicBoxGeometryUpdater.prototype._isHidden = function(entity, box, time) {\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        var dimensions = this._options.dimensions;\n        return !defined(position) || !defined(dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, box, time);\n    };\n\n    DynamicBoxGeometryUpdater.prototype._setOptions = function(entity, box, time) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.dimensions = Property.getValueOrUndefined(box.dimensions, time, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\nexport default BoxGeometryUpdater;\n","import Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartesian4 from './Cartesian4.js';\nimport Cartographic from './Cartographic.js';\nimport CornerType from './CornerType.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Matrix4 from './Matrix4.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport Quaternion from './Quaternion.js';\nimport Transforms from './Transforms.js';\n\n    var scratch2Array = [new Cartesian3(), new Cartesian3()];\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var scratchCartesian5 = new Cartesian3();\n    var scratchCartesian6 = new Cartesian3();\n    var scratchCartesian7 = new Cartesian3();\n    var scratchCartesian8 = new Cartesian3();\n    var scratchCartesian9 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    /**\n     * @private\n     */\n    var PolylineVolumeGeometryLibrary = {};\n\n    var cartographic = new Cartographic();\n    function scaleToSurface(positions, ellipsoid) {\n        var heights = new Array(positions.length);\n        for (var i = 0; i < positions.length; i++) {\n            var pos = positions[i];\n            cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n            heights[i] = cartographic.height;\n            positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n        }\n        return heights;\n    }\n\n    function subdivideHeights(points, h0, h1, granularity) {\n        var p0 = points[0];\n        var p1 = points[1];\n        var angleBetween = Cartesian3.angleBetween(p0, p1);\n        var numPoints = Math.ceil(angleBetween / granularity);\n        var heights = new Array(numPoints);\n        var i;\n        if (h0 === h1) {\n            for (i = 0; i < numPoints; i++) {\n                heights[i] = h0;\n            }\n            heights.push(h1);\n            return heights;\n        }\n\n        var dHeight = h1 - h0;\n        var heightPerVertex = dHeight / (numPoints);\n\n        for (i = 1; i < numPoints; i++) {\n            var h = h0 + i * heightPerVertex;\n            heights[i] = h;\n        }\n\n        heights[0] = h0;\n        heights.push(h1);\n        return heights;\n    }\n\n    var nextScratch = new Cartesian3();\n    var prevScratch = new Cartesian3();\n\n    function computeRotationAngle(start, end, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);\n        var angle = Cartesian2.angleBetween(next, prev);\n\n        return (prev.x * next.y - prev.y * next.x >= 0.0) ? -angle : angle;\n    }\n\n    var negativeX = new Cartesian3(-1, 0, 0);\n    var transform = new Matrix4();\n    var translation = new Matrix4();\n    var rotationZ = new Matrix3();\n    var scaleMatrix = Matrix3.IDENTITY.clone();\n    var westScratch = new Cartesian3();\n    var finalPosScratch = new Cartesian4();\n    var heightCartesian = new Cartesian3();\n    function addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {\n        var west = westScratch;\n        var finalPosition = finalPosScratch;\n        transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n        west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n        west = Cartesian3.normalize(west, west);\n        var angle = computeRotationAngle(west, left, center, ellipsoid);\n        rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n        heightCartesian.z = height;\n        transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);\n        var scale = scaleMatrix;\n        scale[0] = xScalar;\n\n        for (var j = 0; j < repeat; j++) {\n            for (var i = 0; i < shape.length; i += 3) {\n                finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n                finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);\n                finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);\n                finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n            }\n        }\n\n        return finalPositions;\n    }\n\n    var centerScratch = new Cartesian3();\n    function addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {\n        for (var i = 0; i < centers.length; i += 3) {\n            var center = Cartesian3.fromArray(centers, i, centerScratch);\n            finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);\n        }\n        return finalPositions;\n    }\n\n    function convertShapeTo3DDuplicate(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n        var length = shape2D.length;\n        var shape = new Array(length * 6);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        var point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n        for (var i = 1; i < length; i++) {\n            point = shape2D[i];\n            var x = point.x - xOffset;\n            var z = point.y - yOffset;\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n        }\n        point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n\n        return shape;\n    }\n\n    function convertShapeTo3D(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0)\n        var length = shape2D.length;\n        var shape = new Array(length * 3);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        for (var i = 0; i < length; i++) {\n            shape[index++] = shape2D[i].x - xOffset;\n            shape[index++] = 0;\n            shape[index++] = shape2D[i].y - yOffset;\n        }\n\n        return shape;\n    }\n\n    var quaterion = new Quaternion();\n    var startPointScratch = new Cartesian3();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);\n        }\n\n        var left;\n        var surfacePoint;\n        startPoint = Cartesian3.clone(startPoint, startPointScratch);\n        if (granularity > 0) {\n            var repeat = duplicatePoints ? 2 : 1;\n            for (var i = 0; i < granularity; i++) {\n                startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n                left = Cartesian3.subtract(startPoint, pivot, scratch1);\n                left = Cartesian3.normalize(left, left);\n                if (!leftIsOutside) {\n                    left = Cartesian3.negate(left, left);\n                }\n                surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n                finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);\n            }\n        } else {\n            left = Cartesian3.subtract(startPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n\n            endPoint = Cartesian3.clone(endPoint, startPointScratch);\n            left = Cartesian3.subtract(endPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n        }\n\n        return finalPositions;\n    }\n\n    PolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function(shapePositions) {\n        var length = shapePositions.length;\n        var cleanedPositions = [];\n        for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n            var v0 = shapePositions[i0];\n            var v1 = shapePositions[i1];\n\n            if (!Cartesian2.equals(v0, v1)) {\n                cleanedPositions.push(v1); // Shallow copy!\n            }\n        }\n\n        return cleanedPositions;\n    };\n\n    PolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function(forward, backward, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);\n\n        return ((prev.x * next.y) - (prev.y * next.x)) >= 0.0;\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    PolylineVolumeGeometryLibrary.computePositions = function(positions, shape2D, boundingRectangle, geometry, duplicatePoints) {\n        var ellipsoid = geometry._ellipsoid;\n        var heights = scaleToSurface(positions, ellipsoid);\n        var granularity = geometry._granularity;\n        var cornerType = geometry._cornerType;\n        var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);\n        var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;\n        var heightOffset = boundingRectangle.height / 2;\n        var width = boundingRectangle.width / 2;\n        var length = positions.length;\n        var finalPositions = [];\n        var ends = duplicatePoints ? [] : undefined;\n\n        var forward = scratchCartesian1;\n        var backward = scratchCartesian2;\n        var cornerDirection = scratchCartesian3;\n        var surfaceNormal = scratchCartesian4;\n        var pivot = scratchCartesian5;\n        var start = scratchCartesian6;\n        var end = scratchCartesian7;\n        var left = scratchCartesian8;\n        var previousPosition = scratchCartesian9;\n\n        var position = positions[0];\n        var nextPosition = positions[1];\n        surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n        forward = Cartesian3.subtract(nextPosition, position, forward);\n        forward = Cartesian3.normalize(forward, forward);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        var h0 = heights[0];\n        var h1 = heights[1];\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);\n        }\n        previousPosition = Cartesian3.clone(position, previousPosition);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n        var subdividedHeights;\n        var subdividedPositions;\n        for (var i = 1; i < length - 1; i++) {\n            var repeat = duplicatePoints ? 2 : 1;\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.subtract(nextPosition, position, forward);\n            forward = Cartesian3.normalize(forward, forward);\n            cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n            cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n            surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);\n                cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = 1 / Math.max(0.25, (Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1))));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                if (leftIsOutside) {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                } else {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                }\n                backward = Cartesian3.negate(forward, backward);\n            } else {\n                finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);\n                previousPosition = position;\n            }\n            h0 = h1;\n            h1 = heights[i + 1];\n            position = nextPosition;\n        }\n\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scratch2Array,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);\n        }\n\n        length = finalPositions.length;\n        var posLength = duplicatePoints ? length + ends.length : length;\n        var combinedPositions = new Float64Array(posLength);\n        combinedPositions.set(finalPositions);\n        if (duplicatePoints) {\n            combinedPositions.set(ends, length);\n        }\n\n        return combinedPositions;\n    };\nexport default PolylineVolumeGeometryLibrary;\n","import Cartesian3 from './Cartesian3.js';\nimport CornerType from './CornerType.js';\nimport defined from './defined.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport Quaternion from './Quaternion.js';\n\n    /**\n     * @private\n     */\n    var CorridorGeometryLibrary = {};\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n    var scratch3 = new Cartesian3();\n    var scratch4 = new Cartesian3();\n\n    var scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n    var cartesian7 = new Cartesian3();\n    var cartesian8 = new Cartesian3();\n    var cartesian9 = new Cartesian3();\n    var cartesian10 = new Cartesian3();\n\n    var quaterion = new Quaternion();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n        var size = granularity * 3;\n        var array = new Array(size);\n\n        array[size - 3] = endPoint.x;\n        array[size - 2] = endPoint.y;\n        array[size - 1] = endPoint.z;\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);\n        }\n\n        var index = 0;\n        startPoint = Cartesian3.clone(startPoint, scratch1);\n        for (var i = 0; i < granularity; i++) {\n            startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n            array[index++] = startPoint.x;\n            array[index++] = startPoint.y;\n            array[index++] = startPoint.z;\n        }\n\n        return array;\n    }\n\n    function addEndCaps(calculatedPositions) {\n        var cornerPoint = cartesian1;\n        var startPoint = cartesian2;\n        var endPoint = cartesian3;\n\n        var leftEdge = calculatedPositions[1];\n        startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        var length = calculatedPositions.length - 1;\n        var rightEdge = calculatedPositions[length - 1];\n        leftEdge = calculatedPositions[length];\n        startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        return [firstEndCap, lastEndCap];\n    }\n\n    function computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {\n        var cornerPoint = scratch1;\n        if (leftIsOutside) {\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        } else {\n            leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        }\n        return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];\n    }\n\n    function addShiftedPositions(positions, left, scalar, calculatedPositions) {\n        var rightPositions = new Array(positions.length);\n        var leftPositions = new Array(positions.length);\n        var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n        var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n        var rightIndex = 0;\n        var leftIndex = positions.length - 1;\n\n        for (var i = 0; i < positions.length; i += 3) {\n            var pos = Cartesian3.fromArray(positions, i, scratch3);\n            var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n            rightPositions[rightIndex++] = rightPos.x;\n            rightPositions[rightIndex++] = rightPos.y;\n            rightPositions[rightIndex++] = rightPos.z;\n\n            var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n            leftPositions[leftIndex--] = leftPos.z;\n            leftPositions[leftIndex--] = leftPos.y;\n            leftPositions[leftIndex--] = leftPos.x;\n        }\n        calculatedPositions.push(rightPositions, leftPositions);\n\n        return calculatedPositions;\n    }\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.addAttribute = function(attribute, value, front, back) {\n        var x = value.x;\n        var y = value.y;\n        var z = value.z;\n        if (defined(front)) {\n            attribute[front] = x;\n            attribute[front + 1] = y;\n            attribute[front + 2] = z;\n        }\n        if (defined(back)) {\n            attribute[back] = z;\n            attribute[back - 1] = y;\n            attribute[back - 2] = x;\n        }\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.computePositions = function(params) {\n        var granularity = params.granularity;\n        var positions = params.positions;\n        var ellipsoid = params.ellipsoid;\n        var width = params.width / 2;\n        var cornerType = params.cornerType;\n        var saveAttributes = params.saveAttributes;\n        var normal = cartesian1;\n        var forward = cartesian2;\n        var backward = cartesian3;\n        var left = cartesian4;\n        var cornerDirection = cartesian5;\n        var startPoint = cartesian6;\n        var previousPos = cartesian7;\n        var rightPos = cartesian8;\n        var leftPos = cartesian9;\n        var center = cartesian10;\n        var calculatedPositions = [];\n        var calculatedLefts = (saveAttributes) ? [] : undefined;\n        var calculatedNormals = (saveAttributes) ? [] : undefined;\n        var position = positions[0]; //add first point\n        var nextPosition = positions[1];\n\n        forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        previousPos = Cartesian3.clone(position, previousPos);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n\n        var subdividedPositions;\n        var corners = [];\n        var i;\n        var length = positions.length;\n        for (i = 1; i < length - 1; i++) { // add middle points and corners\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n            cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);\n                cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);\n                if (leftIsOutside) {\n                    rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n                    center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(leftPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            leftPositions : computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            leftPositions : computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)\n                        });\n                    }\n                } else {\n                    leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n                    center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(rightPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            rightPositions : computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            rightPositions : computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)\n                        });\n                    }\n                }\n                backward = Cartesian3.negate(forward, backward);\n            }\n            position = nextPosition;\n        }\n\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scaleArray2,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n\n        var endPositions;\n        if (cornerType === CornerType.ROUNDED) {\n            endPositions = addEndCaps(calculatedPositions);\n        }\n\n        return {\n            positions : calculatedPositions,\n            corners : corners,\n            lefts : calculatedLefts,\n            normals : calculatedNormals,\n            endPositions : endPositions\n        };\n    };\nexport default CorridorGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport CorridorGeometryLibrary from './CorridorGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function addNormals(attr, normal, left, front, back, vertexFormat) {\n        var normals = attr.normals;\n        var tangents = attr.tangents;\n        var bitangents = attr.bitangents;\n        var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);\n        if (vertexFormat.normal) {\n            CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n        }\n        if (vertexFormat.tangent) {\n            CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n        }\n        if (vertexFormat.bitangent) {\n            CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n        }\n    }\n\n    function combine(computedPositions, vertexFormat, ellipsoid) {\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var computedLefts = computedPositions.lefts;\n        var computedNormals = computedPositions.normals;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length*2;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 6;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var normals = (vertexFormat.normal) ? new Float32Array(size) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size) : undefined;\n        var attr = {\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        };\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var normal = cartesian1;\n        var left = cartesian2;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n        var index = 0;\n        if (addEndPositions) { // add rounded end\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var firstEndPositions = endPositions[0];\n            normal = Cartesian3.fromArray(computedNormals, 0, normal);\n            left = Cartesian3.fromArray(computedLefts, 0, left);\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var compIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        left = Cartesian3.fromArray(computedLefts, compIndex, left);\n        var rightNormal;\n        var leftNormal;\n        length = leftEdge.length - 3;\n        for (i = 0; i < length; i += 3) {\n            rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);\n            leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);\n            normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n            addNormals(attr, normal, left, front, back, vertexFormat);\n\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);\n        leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);\n        normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n        compIndex += 3;\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var pivot;\n            var start;\n            var outsidePoint = cartesian6;\n            var previousPoint = cartesian3;\n            var nextPoint = cartesian4;\n            normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n            if (defined(l)) {\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n                pivot = LR;\n                start = UR;\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, undefined, back, vertexFormat);\n                    back -= 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n            } else {\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n                pivot = UR;\n                start = LR;\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, front, undefined, vertexFormat);\n                    front += 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            compIndex += 3;\n            left = Cartesian3.fromArray(computedLefts, compIndex, left);\n            for (j = 0; j < leftEdge.length; j += 3) {\n                rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);\n                leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);\n                normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n        }\n        normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);\n        addNormals(attr, normal, left, front, back, vertexFormat);\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        if (vertexFormat.st) {\n            var st = new Float32Array(size / 3 * 2);\n            var rightSt;\n            var leftSt;\n            var stIndex = 0;\n            if (addEndPositions) {\n                leftCount /= 3;\n                rightCount /= 3;\n                var theta = Math.PI / (endPositionLength + 1);\n                leftSt = 1 / (leftCount - endPositionLength + 1);\n                rightSt = 1 / (rightCount - endPositionLength + 1);\n                var a;\n                var halfEndPos = endPositionLength / 2;\n                for (i = halfEndPos + 1; i < endPositionLength + 1; i++) { // lower left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = 1; i < rightCount - endPositionLength + 1; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = endPositionLength; i > halfEndPos; i--) { // lower right rounded end\n                    a = CesiumMath.PI_OVER_TWO - i * theta;\n                    st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = halfEndPos; i > 0; i--) { // upper right rounded end\n                    a = CesiumMath.PI_OVER_TWO - theta * i;\n                    st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = leftCount - endPositionLength; i > 0; i--) { // top edge\n                    st[stIndex++] = i * leftSt;\n                    st[stIndex++] = 1;\n                }\n                for (i = 1; i < halfEndPos + 1; i++) { // upper left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n            } else {\n                leftCount /= 3;\n                rightCount /= 3;\n                leftSt = 1 / (leftCount - 1);\n                rightSt = 1 / (rightCount - 1);\n                for (i = 0; i < rightCount; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = leftCount; i > 0; i--) { // top edge\n                    st[stIndex++] = (i - 1) * leftSt;\n                    st[stIndex++] = 1;\n                }\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.bitangents\n            });\n        }\n\n        return {\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function extrudedAttributes(attributes, vertexFormat) {\n        if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {\n            return attributes;\n        }\n        var positions = attributes.position.values;\n        var topNormals;\n        var topBitangents;\n        if (vertexFormat.normal || vertexFormat.bitangent) {\n            topNormals = attributes.normal.values;\n            topBitangents = attributes.bitangent.values;\n        }\n        var size = attributes.position.values.length / 18;\n        var threeSize = size * 3;\n        var twoSize = size * 2;\n        var sixSize = threeSize * 2;\n        var i;\n        if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n            var normals = (vertexFormat.normal) ? new Float32Array(threeSize * 6) : undefined;\n            var tangents = (vertexFormat.tangent) ? new Float32Array(threeSize * 6) : undefined;\n            var bitangents = (vertexFormat.bitangent) ? new Float32Array(threeSize * 6) : undefined;\n            var topPosition = cartesian1;\n            var bottomPosition = cartesian2;\n            var previousPosition = cartesian3;\n            var normal = cartesian4;\n            var tangent = cartesian5;\n            var bitangent = cartesian6;\n            var attrIndex = sixSize;\n            for (i = 0; i < threeSize; i += 3) {\n                var attrIndexOffset = attrIndex + sixSize;\n                topPosition      = Cartesian3.fromArray(positions, i, topPosition);\n                bottomPosition   = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);\n                previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);\n                bottomPosition   = Cartesian3.subtract(bottomPosition,   topPosition, bottomPosition);\n                previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);\n                normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);\n                if (vertexFormat.normal) {\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n                }\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n                    if (vertexFormat.bitangent) {\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);\n                    }\n                }\n                attrIndex += 6;\n            }\n\n            if (vertexFormat.normal) {\n                normals.set(topNormals); //top\n                for (i = 0; i < threeSize; i += 3) { //bottom normals\n                    normals[i + threeSize] = -topNormals[i];\n                    normals[i + threeSize + 1] = -topNormals[i + 1];\n                    normals[i + threeSize + 2] = -topNormals[i + 2];\n                }\n                attributes.normal.values = normals;\n            } else {\n                attributes.normal = undefined;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents.set(topBitangents); //top\n                bitangents.set(topBitangents, threeSize); //bottom\n                attributes.bitangent.values = bitangents;\n            } else {\n                attributes.bitangent = undefined;\n            }\n\n            if (vertexFormat.tangent) {\n                var topTangents = attributes.tangent.values;\n                tangents.set(topTangents); //top\n                tangents.set(topTangents, threeSize); //bottom\n                attributes.tangent.values = tangents;\n            }\n        }\n        if (vertexFormat.st) {\n            var topSt = attributes.st.values;\n            var st = new Float32Array(twoSize * 6);\n            st.set(topSt); //top\n            st.set(topSt, twoSize); //bottom\n            var index = twoSize * 2;\n\n            for ( var j = 0; j < 2; j++) {\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n                for (i = 2; i < twoSize; i += 2) {\n                    var s = topSt[i];\n                    var t = topSt[i + 1];\n                    st[index++] = s;\n                    st[index++] = t;\n                    st[index++] = s;\n                    st[index++] = t;\n                }\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n            }\n            attributes.st.values = st;\n        }\n\n        return attributes;\n    }\n\n    function addWallPositions(positions, index, wallPositions) {\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n        for ( var i = 3; i < positions.length; i += 3) {\n            var x = positions[i];\n            var y = positions[i + 1];\n            var z = positions[i + 2];\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n        }\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n\n        return wallPositions;\n    }\n\n    function computePositionsExtruded(params, vertexFormat) {\n        var topVertexFormat = new VertexFormat({\n            position : vertexFormat.position,\n            normal : (vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume),\n            tangent : vertexFormat.tangent,\n            bitangent : (vertexFormat.normal || vertexFormat.bitangent),\n            st : vertexFormat.st\n        });\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, topVertexFormat, ellipsoid);\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var newPositions = new Float64Array(length * 6);\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var wallPositions = new Float64Array(length * 4);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        wallPositions = addWallPositions(positions, 0, wallPositions);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        newPositions.set(wallPositions, length * 2);\n        attributes.position.values = newPositions;\n\n        attributes = extrudedAttributes(attributes, vertexFormat);\n        var i;\n        var size = length / 3;\n        if (params.shadowVolume) {\n            var topNormals = attributes.normal.values;\n            length = topNormals.length;\n\n            var extrudeNormals = new Float32Array(length * 6);\n            for (i = 0; i < length; i ++) {\n                topNormals[i] = -topNormals[i];\n            }\n            //only get normals for bottom layer that's going to be pushed down\n            extrudeNormals.set(topNormals, length); //bottom face\n            extrudeNormals = addWallPositions(topNormals, length*4, extrudeNormals); //bottom wall\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n            if (!vertexFormat.normal) {\n                attributes.normal = undefined;\n            }\n        }\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(size * 6);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n                applyOffset = arrayFill(applyOffset, 1, size*2, size * 4); // top wall\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var iLength = indices.length;\n        var twoSize = size + size;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 3) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            var v2 = indices[i + 2];\n            newIndices[index++] = v2 + size;\n            newIndices[index++] = v1 + size;\n            newIndices[index++] = v0 + size;\n        }\n\n        var UL, LL, UR, LR;\n\n        for (i = 0; i < twoSize; i += 2) { //wall indices\n            UL = i + twoSize;\n            LL = UL + twoSize;\n            UR = UL + 1;\n            LR = LL + 1;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n            newIndices[index++] = UR;\n            newIndices[index++] = UR;\n            newIndices[index++] = LL;\n            newIndices[index++] = LR;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartographic = new Cartographic();\n\n    function computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {\n        // Compute direction of offset the point\n        var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n        Cartesian3.normalize(direction, direction);\n        var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n        var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n        Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n        var minLat = min.latitude;\n        var minLon = min.longitude;\n        var maxLat = max.latitude;\n        var maxLon = max.longitude;\n\n        // Compute 2 offset points\n        Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        var lat = scratchCartographic.latitude;\n        var lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        lat = scratchCartographic.latitude;\n        lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        min.latitude = minLat;\n        min.longitude = minLon;\n        max.latitude = maxLat;\n        max.longitude = maxLon;\n    }\n\n    var scratchCartesianOffset = new Cartesian3();\n    var scratchCartesianEnds = new Cartesian3();\n    var scratchCartographicMin = new Cartographic();\n    var scratchCartographicMax = new Cartographic();\n\n    function computeRectangle(positions, ellipsoid, width, cornerType, result) {\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var length = cleanPositions.length;\n        if (length < 2 || width <= 0) {\n            return new Rectangle();\n        }\n        var halfWidth = width * 0.5;\n\n        scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n        scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n        var lat, lon;\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute start cap\n            var first = cleanPositions[0];\n            Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n            Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n            Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n            Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        // Compute the rest\n        for (var i = 0; i < length-1; ++i) {\n            computeOffsetPoints(cleanPositions[i], cleanPositions[i+1], ellipsoid, halfWidth,\n                scratchCartographicMin, scratchCartographicMax);\n        }\n\n        // Compute ending point\n        var last = cleanPositions[length-1];\n        Cartesian3.subtract(last, cleanPositions[length-2], scratchCartesianOffset);\n        Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n        Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n        Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n        computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth,\n            scratchCartographicMin, scratchCartographicMax);\n\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute end cap\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        var rectangle = defined(result) ? result : new Rectangle();\n        rectangle.north = scratchCartographicMax.latitude;\n        rectangle.south = scratchCartographicMin.latitude;\n        rectangle.east = scratchCartographicMax.longitude;\n        rectangle.west = scratchCartographicMin.longitude;\n\n        return rectangle;\n    }\n\n    /**\n     * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias CorridorGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorGeometry.createGeometry\n     * @see Packable\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n     *\n     * @example\n     * var corridor = new Cesium.CorridorGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createCorridorGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._rectangle = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorGeometry} [result] The object into which to store the result.\n     * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n     */\n    CorridorGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new CorridorGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle.\n     */\n    CorridorGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n        return computeRectangle(positions, ellipsoid, width, cornerType, result);\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorGeometry.createGeometry = function(corridorGeometry) {\n        var positions = corridorGeometry._positions;\n        var width = corridorGeometry._width;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorGeometry._height;\n        var extrudedHeight = corridorGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var vertexFormat = corridorGeometry._vertexFormat;\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorGeometry._cornerType,\n            granularity : corridorGeometry._granularity,\n            saveAttributes: true\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.shadowVolume = corridorGeometry._shadowVolume;\n            params.offsetAttribute = corridorGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params, vertexFormat);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, vertexFormat, ellipsoid);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorGeometry._offsetAttribute)) {\n                var applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                arrayFill(applyOffset, applyOffsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n        if (!vertexFormat.position) {\n            attr.attributes.position.values = undefined;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    CorridorGeometry.createShadowVolume = function(corridorGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = corridorGeometry._granularity;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new CorridorGeometry({\n            positions : corridorGeometry._positions,\n            width : corridorGeometry._width,\n            cornerType : corridorGeometry._cornerType,\n            ellipsoid : ellipsoid,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    defineProperties(CorridorGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n         *\n         * Corridors don't support stRotation,\n         * so just return the corners of the original system.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                return [0, 0, 0, 1, 1, 0];\n            }\n        }\n    });\nexport default CorridorGeometry;\n","import arrayFill from './arrayFill.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport CorridorGeometryLibrary from './CorridorGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function combine(computedPositions, cornerType) {\n        var wallIndices = [];\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length / 3 * 4;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length / 3 * 2;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length / 3 * 2;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 4;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n        var index = 0;\n\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n        if (addEndPositions) { // add rounded end\n            wallIndices.push(front / 3);\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var firstEndPositions = endPositions[0];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        length = leftEdge.length - 3;\n        wallIndices.push(front / 3, (back - 2) / 3);\n        for (i = 0; i < length; i += 3) {\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var start;\n            var outsidePoint = cartesian3;\n            if (defined(l)) {\n                back -= 3;\n                start = UR;\n                wallIndices.push(LR);\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    back -= 3;\n                }\n                wallIndices.push(start - Math.floor(l.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push((back - 2) / 3 + 1);\n                }\n                front += 3;\n            } else {\n                front += 3;\n                start = LR;\n                wallIndices.push(UR);\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    front += 3;\n                }\n                wallIndices.push(start + Math.floor(r.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push(front / 3 - 1);\n                }\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            for (j = 0; j < leftEdge.length; j += 3) {\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n\n            wallIndices.push(front / 3);\n        } else {\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        return {\n            attributes : attributes,\n            indices : indices,\n            wallIndices : wallIndices\n        };\n    }\n\n    function computePositionsExtruded(params) {\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, params.cornerType);\n        var wallIndices = attr.wallIndices;\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var newPositions = new Float64Array(length * 2);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        attributes.position.values = newPositions;\n\n        length /= 3;\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length * 2);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length);\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var i;\n        var iLength = indices.length;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 2) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            newIndices[index++] = v0 + length;\n            newIndices[index++] = v1 + length;\n        }\n\n        var UL, LL;\n        for (i = 0; i < wallIndices.length; i++) { //wall indices\n            UL = wallIndices[i];\n            LL = UL + length;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    /**\n     * A description of a corridor outline.\n     *\n     * @alias CorridorOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n     * @param {Number} options.width The distance between the edges of the corridor outline.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorOutlineGeometry.createGeometry\n     *\n     * @example\n     * var corridor = new Cesium.CorridorOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCorridorOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n     */\n    CorridorOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CorridorOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorOutlineGeometry.createGeometry = function(corridorOutlineGeometry) {\n        var positions = corridorOutlineGeometry._positions;\n        var width = corridorOutlineGeometry._width;\n        var ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorOutlineGeometry._height;\n        var extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorOutlineGeometry._cornerType,\n            granularity : corridorOutlineGeometry._granularity,\n            saveAttributes : false\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, params.cornerType);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorOutlineGeometry._offsetAttribute)) {\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = corridorOutlineGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorOutlineGeometry._offsetAttribute\n        });\n    };\nexport default CorridorOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport CallbackProperty from './CallbackProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport TerrainOffsetProperty from './TerrainOffsetProperty.js';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    /**\n     * An abstract class for updating ground geometry entities.\n     * @constructor\n     * @alias GroundGeometryUpdater\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GroundGeometryUpdater(options) {\n        GeometryUpdater.call(this, options);\n\n        this._zIndex = 0;\n        this._terrainOffsetProperty = undefined;\n    }\n\n    if (defined(Object.create)) {\n        GroundGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        GroundGeometryUpdater.prototype.constructor = GroundGeometryUpdater;\n    }\n\n    defineProperties(GroundGeometryUpdater.prototype, {\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        },\n\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    GroundGeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return this._fillEnabled && !defined(geometry.height) && !defined(geometry.extrudedHeight) && GroundPrimitive.isSupported(this._scene);\n    };\n\n    GroundGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        return height === 0 || (defined(extrudedHeight) && extrudedHeight !== height);\n    };\n\n    GroundGeometryUpdater.prototype._computeCenter = DeveloperError.throwInstantiationError;\n\n    GroundGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n        if (defined(geometry.zIndex) && (defined(geometry.height) || defined(geometry.extrudedHeight))) {\n            oneTimeWarning(oneTimeWarning.geometryZIndex);\n        }\n\n        this._zIndex = defaultValue(geometry.zIndex, defaultZIndex);\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n        var extrudedHeightReferenceProperty = geometry.extrudedHeightReference;\n\n        if (defined(heightReferenceProperty) || defined(extrudedHeightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty, extrudedHeightReferenceProperty);\n        }\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GroundGeometryUpdater.prototype.destroy = function() {\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        GeometryUpdater.prototype.destroy.call(this);\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryHeight = function(height, heightReference) {\n        \n        if (!defined(height)) {\n            if (heightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryHeightReference);\n            }\n            return;\n        }\n\n        if (heightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return height;\n        }\n        return 0.0;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryExtrudedHeight = function(extrudedHeight, extrudedHeightReference) {\n        \n        if (!defined(extrudedHeight)) {\n            if (extrudedHeightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryExtrudedHeightReference);\n            }\n            return;\n        }\n        if (extrudedHeightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return extrudedHeight;\n        }\n\n        return GroundGeometryUpdater.CLAMP_TO_GROUND;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.CLAMP_TO_GROUND = 'clamp';\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.computeGeometryOffsetAttribute = function(height, heightReference, extrudedHeight, extrudedHeightReference) {\n        if (!defined(height) || !defined(heightReference)) {\n            heightReference = HeightReference.NONE;\n        }\n        if (!defined(extrudedHeight) || !defined(extrudedHeightReference)) {\n            extrudedHeightReference = HeightReference.NONE;\n        }\n        var n = 0;\n        if (heightReference !== HeightReference.NONE) {\n            n++;\n        }\n        if (extrudedHeightReference === HeightReference.RELATIVE_TO_GROUND) {\n            n++;\n        }\n        if (n === 2) {\n            return GeometryOffsetAttribute.ALL;\n        }\n        if (n === 1) {\n            return GeometryOffsetAttribute.TOP;\n        }\n\n        return undefined;\n    };\nexport default GroundGeometryUpdater;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CorridorGeometry from '../Core/CorridorGeometry.js';\nimport CorridorOutlineGeometry from '../Core/CorridorOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function CorridorGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.cornerType = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for corridors.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CorridorGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CorridorGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new CorridorGeometryOptions(entity),\n            geometryPropertyName : 'corridor',\n            observedPropertyNames : ['availability', 'corridor']\n        });\n\n        this._onEntityPropertyChanged(entity, 'corridor', entity.corridor, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CorridorGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        CorridorGeometryUpdater.prototype.constructor = CorridorGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CorridorGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    CorridorGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var positions = Property.getValueOrUndefined(this._entity.corridor.positions, time);\n        if (!defined(positions) || positions.length === 0) {\n            return;\n        }\n        return Cartesian3.clone(positions[Math.floor(positions.length / 2.0)], result);\n    };\n\n    CorridorGeometryUpdater.prototype._isHidden = function(entity, corridor) {\n        return !defined(corridor.positions) || !defined(corridor.width) || GeometryUpdater.prototype._isHidden.call(this, entity, corridor);\n    };\n\n    CorridorGeometryUpdater.prototype._isDynamic = function(entity, corridor) {\n        return !corridor.positions.isConstant || //\n               !Property.isConstant(corridor.height) || //\n               !Property.isConstant(corridor.extrudedHeight) || //\n               !Property.isConstant(corridor.granularity) || //\n               !Property.isConstant(corridor.width) || //\n               !Property.isConstant(corridor.outlineWidth) || //\n               !Property.isConstant(corridor.cornerType) || //\n               !Property.isConstant(corridor.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    CorridorGeometryUpdater.prototype._setStaticOptions = function(entity, corridor) {\n        var heightValue = Property.getValueOrUndefined(corridor.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = corridor.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.width = corridor.width.getValue(Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, Iso8601.MINIMUM_VALUE);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    CorridorGeometryUpdater.DynamicGeometryUpdater = DynamicCorridorGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCorridorGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCorridorGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCorridorGeometryUpdater.prototype.constructor = DynamicCorridorGeometryUpdater;\n    }\n\n    DynamicCorridorGeometryUpdater.prototype._isHidden = function(entity, corridor, time) {\n        var options = this._options;\n        return !defined(options.positions) || !defined(options.width) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, corridor, time);\n    };\n\n    DynamicCorridorGeometryUpdater.prototype._setOptions = function(entity, corridor, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(corridor.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.positions = Property.getValueOrUndefined(corridor.positions, time);\n        options.width = Property.getValueOrUndefined(corridor.width, time);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default CorridorGeometryUpdater;\n","import CesiumMath from './Math.js';\n\n    /**\n     * @private\n     */\n    var CylinderGeometryLibrary = {};\n\n    /**\n     * @private\n     */\n    CylinderGeometryLibrary.computePositions = function(length, topRadius, bottomRadius, slices, fill){\n        var topZ = length * 0.5;\n        var bottomZ = -topZ;\n\n        var twoSlice = slices + slices;\n        var size = (fill) ? 2 * twoSlice : twoSlice;\n        var positions = new Float64Array(size*3);\n        var i;\n        var index = 0;\n        var tbIndex = 0;\n        var bottomOffset = (fill) ? twoSlice*3 : 0;\n        var topOffset = (fill) ? (twoSlice + slices)*3 : slices*3;\n\n        for (i = 0; i < slices; i++) {\n            var angle = i / slices * CesiumMath.TWO_PI;\n            var x = Math.cos(angle);\n            var y = Math.sin(angle);\n            var bottomX = x * bottomRadius;\n            var bottomY = y * bottomRadius;\n            var topX = x * topRadius;\n            var topY = y * topRadius;\n\n            positions[tbIndex + bottomOffset] = bottomX;\n            positions[tbIndex + bottomOffset + 1] = bottomY;\n            positions[tbIndex + bottomOffset + 2] = bottomZ;\n\n            positions[tbIndex + topOffset] = topX;\n            positions[tbIndex + topOffset + 1] = topY;\n            positions[tbIndex + topOffset + 2] = topZ;\n            tbIndex += 3;\n            if (fill) {\n                positions[index++] = bottomX;\n                positions[index++] = bottomY;\n                positions[index++] = bottomZ;\n                positions[index++] = topX;\n                positions[index++] = topY;\n                positions[index++] = topZ;\n            }\n        }\n\n        return positions;\n    };\nexport default CylinderGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CylinderGeometryLibrary from './CylinderGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var radiusScratch = new Cartesian2();\n    var normalScratch = new Cartesian3();\n    var bitangentScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n\n    /**\n     * A description of a cylinder.\n     *\n     * @alias CylinderGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n     */\n    function CylinderGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var slices = defaultValue(options.slices, 128);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._slices = slices;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat : scratchVertexFormat,\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderGeometry} [result] The object into which to store the result.\n     * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n     */\n    CylinderGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var vertexFormat = cylinderGeometry._vertexFormat;\n        var slices = cylinderGeometry._slices;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var twoSlices = slices + slices;\n        var threeSlices = slices + twoSlices;\n        var numVertices = twoSlices + twoSlices;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);\n\n        var st = (vertexFormat.st) ? new Float32Array(numVertices * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(numVertices * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(numVertices * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(numVertices * 3) : undefined;\n\n        var i;\n        var computeNormal = (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent);\n\n        if (computeNormal) {\n            var computeTangent = (vertexFormat.tangent || vertexFormat.bitangent);\n\n            var normalIndex = 0;\n            var tangentIndex = 0;\n            var bitangentIndex = 0;\n\n            var theta = Math.atan2(bottomRadius - topRadius, length);\n            var normal = normalScratch;\n            normal.z = Math.sin(theta);\n            var normalScale = Math.cos(theta);\n            var tangent = tangentScratch;\n            var bitangent = bitangentScratch;\n\n            for (i = 0; i < slices; i++) {\n                var angle = i / slices * CesiumMath.TWO_PI;\n                var x = normalScale * Math.cos(angle);\n                var y = normalScale * Math.sin(angle);\n                if (computeNormal) {\n                    normal.x = x;\n                    normal.y = y;\n\n                    if (computeTangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                    }\n\n                    if (vertexFormat.normal) {\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                    }\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = -1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = -1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = 1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n        }\n\n        var numIndices = 12 * slices - 12;\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n        var index = 0;\n        var j = 0;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = j;\n            indices[index++] = j + 2;\n            indices[index++] = j + 3;\n\n            indices[index++] = j;\n            indices[index++] = j + 3;\n            indices[index++] = j + 1;\n\n            j += 2;\n        }\n\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 0;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 1;\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = twoSlices + i + 1;\n            indices[index++] = twoSlices + i;\n            indices[index++] = twoSlices;\n        }\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = threeSlices;\n            indices[index++] = threeSlices + i;\n            indices[index++] = threeSlices + i + 1;\n        }\n\n        var textureCoordIndex = 0;\n        if (vertexFormat.st) {\n            var rad = Math.max(topRadius, bottomRadius);\n            for (i = 0; i < numVertices; i++) {\n                var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n                st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n                st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype: ComponentDatatype.DOUBLE,\n                componentsPerAttribute: 3,\n                values: positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\n\n    var unitCylinderGeometry;\n\n    /**\n     * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n     * @returns {Geometry} The computed vertices and indices.\n     *\n     * @private\n     */\n    CylinderGeometry.getUnitCylinder = function() {\n        if (!defined(unitCylinderGeometry)) {\n            unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({\n                topRadius : 1.0,\n                bottomRadius : 1.0,\n                length : 1.0,\n                vertexFormat : VertexFormat.POSITION_ONLY\n            }));\n        }\n        return unitCylinderGeometry;\n    };\nexport default CylinderGeometry;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CylinderGeometryLibrary from './CylinderGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var radiusScratch = new Cartesian2();\n\n    /**\n     * A description of the outline of a cylinder.\n     *\n     * @alias CylinderOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n     *\n     * @exception {DeveloperError} options.length must be greater than 0.\n     * @exception {DeveloperError} options.topRadius must be greater than 0.\n     * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n     * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderOutlineGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderOutlineGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n     */\n    function CylinderOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var slices = defaultValue(options.slices, 128);\n        var numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._slices = slices;\n        this._numberOfVerticalLines = numberOfVerticalLines;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderOutlineGeometry.packedLength = 6;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex++] = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchOptions = {\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n     */\n    CylinderOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderOutlineGeometry(scratchOptions);\n        }\n\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderOutlineGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var slices = cylinderGeometry._slices;\n        var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var numVertices = slices * 2;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, false);\n        var numIndices = slices * 2;\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, slices);\n            numSide = Math.round(slices / numSideLines);\n            numIndices += numSideLines;\n        }\n\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n        var index = 0;\n        var i;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n            indices[index++] = i + slices;\n            indices[index++] = i + 1 + slices;\n        }\n\n        indices[index++] = slices - 1;\n        indices[index++] = 0;\n        indices[index++] = slices + slices - 1;\n        indices[index++] = slices;\n\n        if (numberOfVerticalLines > 0) {\n            for (i = 0; i < slices; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + slices;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\nexport default CylinderOutlineGeometry;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CylinderGeometry from '../Core/CylinderGeometry.js';\nimport CylinderOutlineGeometry from '../Core/CylinderOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport Property from './Property.js';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function CylinderGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.length = undefined;\n        this.topRadius = undefined;\n        this.bottomRadius = undefined;\n        this.slices = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for cylinders.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CylinderGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CylinderGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity: entity,\n            scene: scene,\n            geometryOptions: new CylinderGeometryOptions(entity),\n            geometryPropertyName: 'cylinder',\n            observedPropertyNames: ['availability', 'position', 'orientation', 'cylinder']\n        });\n\n        this._onEntityPropertyChanged(entity, 'cylinder', entity.cylinder, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CylinderGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        CylinderGeometryUpdater.prototype.constructor = CylinderGeometryUpdater;\n    }\n\n    defineProperties(CylinderGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof CylinderGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CylinderGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderOutlineGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    CylinderGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    CylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder) {\n        return !defined(entity.position) || !defined(cylinder.length) || !defined(cylinder.topRadius) || !defined(cylinder.bottomRadius) || GeometryUpdater.prototype._isHidden.call(this, entity, cylinder);\n    };\n\n    CylinderGeometryUpdater.prototype._isDynamic = function(entity, cylinder) {\n        return !entity.position.isConstant || //\n                !Property.isConstant(entity.orientation) || //\n                !cylinder.length.isConstant || //\n                !cylinder.topRadius.isConstant || //\n                !cylinder.bottomRadius.isConstant || //\n                !Property.isConstant(cylinder.slices) || //\n                !Property.isConstant(cylinder.outlineWidth) || //\n                !Property.isConstant(cylinder.numberOfVerticalLines);\n    };\n\n    CylinderGeometryUpdater.prototype._setStaticOptions = function(entity, cylinder) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.length = cylinder.length.getValue(Iso8601.MINIMUM_VALUE);\n        options.topRadius = cylinder.topRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.bottomRadius = cylinder.bottomRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    CylinderGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    CylinderGeometryUpdater.DynamicGeometryUpdater = DynamicCylinderGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCylinderGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCylinderGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCylinderGeometryUpdater.prototype.constructor = DynamicCylinderGeometryUpdater;\n    }\n\n    DynamicCylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.length) || !defined(options.topRadius) || //\n               !defined(options.bottomRadius) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, cylinder, time);\n    };\n\n    DynamicCylinderGeometryUpdater.prototype._setOptions = function(entity, cylinder, time) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.length = Property.getValueOrUndefined(cylinder.length, time);\n        options.topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);\n        options.bottomRadius = Property.getValueOrUndefined(cylinder.bottomRadius, time);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, time);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\nexport default CylinderGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport defined from '../Core/defined.js';\nimport BoundingSphereState from './BoundingSphereState.js';\n\n    /**\n     * @private\n     */\n    function DynamicGeometryBatch(primitives, orderedGroundPrimitives) {\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._dynamicUpdaters = new AssociativeArray();\n    }\n\n    DynamicGeometryBatch.prototype.add = function(time, updater) {\n        this._dynamicUpdaters.set(updater.id, updater.createDynamicUpdater(this._primitives, this._orderedGroundPrimitives));\n    };\n\n    DynamicGeometryBatch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var dynamicUpdater = this._dynamicUpdaters.get(id);\n        if (defined(dynamicUpdater)) {\n            this._dynamicUpdaters.remove(id);\n            dynamicUpdater.destroy();\n        }\n    };\n\n    DynamicGeometryBatch.prototype.update = function(time) {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].update(time);\n        }\n        return true;\n    };\n\n    DynamicGeometryBatch.prototype.removeAllPrimitives = function() {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].destroy();\n        }\n        this._dynamicUpdaters.removeAll();\n    };\n\n    DynamicGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        updater = this._dynamicUpdaters.get(updater.id);\n        if (defined(updater) && defined(updater.getBoundingSphere)) {\n            return updater.getBoundingSphere(result);\n        }\n        return BoundingSphereState.FAILED;\n    };\nexport default DynamicGeometryBatch;\n","import Cartesian3 from './Cartesian3.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport Quaternion from './Quaternion.js';\n\n    var EllipseGeometryLibrary = {};\n\n    var rotAxis = new Cartesian3();\n    var tempVec = new Cartesian3();\n    var unitQuat = new Quaternion();\n    var rotMtx = new Matrix3();\n\n    function pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {\n        var azimuth = theta + rotation;\n\n        Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n        Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n        Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n        var cosThetaSquared = Math.cos(theta);\n        cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n        var sinThetaSquared = Math.sin(theta);\n        sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n        var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n        var angle = radius / mag;\n\n        // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n        Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n        Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n        Matrix3.multiplyByVector(rotMtx, unitPos, result);\n        Cartesian3.normalize(result, result);\n        Cartesian3.multiplyByScalar(result, mag, result);\n        return result;\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    /**\n     * Returns the positions raised to the given heights\n     * @private\n     */\n    EllipseGeometryLibrary.raisePositionsToHeight = function(positions, options, extrude) {\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n\n        var finalPositions = new Float64Array(size * 3);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            ellipsoid.scaleToGeodeticSurface(position, position);\n\n            var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);\n            Cartesian3.add(position, scaledNormal, position);\n\n            if (extrude) {\n                Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n                Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n                finalPositions[i + bottomOffset] = extrudedPosition.x;\n                finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n                finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n            }\n\n            finalPositions[i] = position.x;\n            finalPositions[i1] = position.y;\n            finalPositions[i2] = position.z;\n        }\n\n        return finalPositions;\n    };\n\n    var unitPosScratch = new Cartesian3();\n    var eastVecScratch = new Cartesian3();\n    var northVecScratch = new Cartesian3();\n    /**\n     * Returns an array of positions that make up the ellipse.\n     * @private\n     */\n    EllipseGeometryLibrary.computeEllipsePositions = function(options, addFillPositions, addEdgePositions) {\n        var semiMinorAxis = options.semiMinorAxis;\n        var semiMajorAxis = options.semiMajorAxis;\n        var rotation = options.rotation;\n        var center = options.center;\n\n        // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n        // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n        // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n        // the distance along the ellipse boundary more closely match the granularity.\n        var granularity = options.granularity * 8.0;\n\n        var aSqr = semiMinorAxis * semiMinorAxis;\n        var bSqr = semiMajorAxis * semiMajorAxis;\n        var ab = semiMajorAxis * semiMinorAxis;\n\n        var mag = Cartesian3.magnitude(center);\n\n        var unitPos = Cartesian3.normalize(center, unitPosScratch);\n        var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n        eastVec = Cartesian3.normalize(eastVec, eastVec);\n        var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n        // The number of points in the first quadrant\n        var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n        var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n        var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n        if (theta < 0.0) {\n            numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n        }\n\n        // If the number of points were three, the ellipse\n        // would be tessellated like below:\n        //\n        //         *---*\n        //       / | \\ | \\\n        //     *---*---*---*\n        //   / | \\ | \\ | \\ | \\\n        //  / .*---*---*---*. \\\n        // * ` | \\ | \\ | \\ | `*\n        //  \\`.*---*---*---*.`/\n        //   \\ | \\ | \\ | \\ | /\n        //     *---*---*---*\n        //       \\ | \\ | /\n        //         *---*\n        // The first and last column have one position and fan to connect to the adjacent column.\n        // Each other vertical column contains an even number of positions.\n        var size = 2 * (numPts * (numPts + 2));\n        var positions = (addFillPositions) ? new Array(size * 3) : undefined;\n        var positionIndex = 0;\n        var position = scratchCartesian1;\n        var reflectedPosition = scratchCartesian2;\n\n        var outerPositionsLength = (numPts * 4) * 3;\n        var outerRightIndex = outerPositionsLength - 1;\n        var outerLeftIndex = 0;\n        var outerPositions = (addEdgePositions) ? new Array(outerPositionsLength) : undefined;\n\n        var i;\n        var j;\n        var numInterior;\n        var t;\n        var interiorPosition;\n\n        // Compute points in the 'eastern' half of the ellipse\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n        }\n        theta = CesiumMath.PI_OVER_TWO -  deltaTheta;\n        for (i = 1; i < numPts + 1; ++i) {\n            position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * i + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n\n            theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n        }\n\n        // Compute points in the 'western' half of the ellipse\n        for (i = numPts; i > 1; --i) {\n            theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n            position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * (i - 1) + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n        }\n\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n\n        var r = {};\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n            r.positions = positions;\n            r.numPts = numPts;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n            r.outerPositions = outerPositions;\n        }\n\n        return r;\n    };\nexport default EllipseGeometryLibrary;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport EllipseGeometryLibrary from './EllipseGeometryLibrary.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport GeographicProjection from './GeographicProjection.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var texCoordScratch = new Cartesian2();\n    var textureMatrixScratch = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n\n    var scratchCartographic = new Cartographic();\n    var projectedCenterScratch = new Cartesian3();\n\n    var scratchMinTexCoord = new Cartesian2();\n    var scratchMaxTexCoord = new Cartesian2();\n\n    function computeTopBottomAttributes(positions, options, extrude) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var stRotation = options.stRotation;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n        var shadowVolume = options.shadowVolume;\n\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n        var textureMatrix = textureMatrixScratch;\n        var tangentMatrix = tangentMatrixScratch;\n        if (stRotation !== 0) {\n            var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            rotation = Quaternion.fromAxisAngle(geodeticNormal, -stRotation, quaternionScratch);\n            tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n            tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n        }\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        var stOffset = bottomOffset / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                if (extrude) {\n                    textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                    textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n                }\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n                if (shadowVolume) {\n                    extrudeNormals[i + bottomOffset] = -normal.x;\n                    extrudeNormals[i1 + bottomOffset] = -normal.y;\n                    extrudeNormals[i2 + bottomOffset] = -normal.z;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                    if (vertexFormat.tangent || vertexFormat.bitangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                        Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n                    }\n                    if (vertexFormat.normal) {\n                        normals[i] = normal.x;\n                        normals[i1] = normal.y;\n                        normals[i2] = normal.z;\n                        if (extrude) {\n                            normals[i + bottomOffset] = -normal.x;\n                            normals[i1 + bottomOffset] = -normal.y;\n                            normals[i2 + bottomOffset] = -normal.z;\n                        }\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[i] = tangent.x;\n                        tangents[i1] = tangent.y;\n                        tangents[i2] = tangent.z;\n                        if (extrude) {\n                            tangents[i + bottomOffset] = -tangent.x;\n                            tangents[i1 + bottomOffset] = -tangent.y;\n                            tangents[i2 + bottomOffset] = -tangent.z;\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[i ] = bitangent.x;\n                        bitangents[i1] = bitangent.y;\n                        bitangents[i2] = bitangent.z;\n                        if (extrude) {\n                            bitangents[i + bottomOffset] = bitangent.x;\n                            bitangents[i1 + bottomOffset] = bitangent.y;\n                            bitangents[i2 + bottomOffset] = bitangent.z;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (extrude && defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function topIndices(numPts) {\n        // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n        //              = -1 + 4 * ((n * ( n + 1)) / 2)\n        // total triangles = 2 * numTrangles in half\n        // indices = total triangles * 3;\n        // Substitute numPts for n above\n\n        var indices = new Array(12 * (numPts * ( numPts + 1)) - 6);\n        var indicesIndex = 0;\n        var prevIndex;\n        var numInterior;\n        var positionIndex;\n        var i;\n        var j;\n        // Indices triangles to the 'right' of the north vector\n\n        prevIndex = 0;\n        positionIndex = 1;\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        for (i = 2; i < numPts + 1; ++i) {\n            positionIndex = i * (i + 1) - 1;\n            prevIndex = (i - 1) * i - 1;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        // Indices for center column of triangles\n        numInterior = numPts * 2;\n        ++positionIndex;\n        ++prevIndex;\n        for (i = 0; i < numInterior - 1; ++i) {\n            indices[indicesIndex++] = positionIndex;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        indices[indicesIndex++] = positionIndex;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        indices[indicesIndex++] = positionIndex++;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        // Reverse the process creating indices to the 'left' of the north vector\n        ++prevIndex;\n        for (i = numPts - 1; i > 1; --i) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = positionIndex++;\n        }\n\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n        return indices;\n    }\n\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var attributes = computeTopBottomAttributes(positions, options, false);\n        var indices = topIndices(numPts);\n        indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function computeWallAttributes(positions, options) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var stRotation = options.stRotation;\n        var size = positions.length / 3 * 2;\n\n        var finalPositions = new Float64Array(size * 3);\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var shadowVolume = options.shadowVolume;\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n        var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n        var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var stOffset = length / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            var extrudedPosition;\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            position = ellipsoid.scaleToGeodeticSurface(position, position);\n            extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n            if (shadowVolume) {\n                extrudeNormals[i + length] = -normal.x;\n                extrudeNormals[i1 + length] = -normal.y;\n                extrudeNormals[i2 + length] = -normal.z;\n            }\n\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);\n            position = Cartesian3.add(position, scaledNormal, position);\n            scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n            extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n            if (vertexFormat.position) {\n                finalPositions[i + length] = extrudedPosition.x;\n                finalPositions[i1 + length] = extrudedPosition.y;\n                finalPositions[i2 + length] = extrudedPosition.z;\n\n                finalPositions[i] = position.x;\n                finalPositions[i1] = position.y;\n                finalPositions[i2] = position.z;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n\n                bitangent = Cartesian3.clone(normal, bitangent);\n                var next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);\n                Cartesian3.subtract(next, position, next);\n                var bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);\n\n                normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);\n\n                if (vertexFormat.normal) {\n                    normals[i] = normal.x;\n                    normals[i1] = normal.y;\n                    normals[i2] = normal.z;\n\n                    normals[i + length] = normal.x;\n                    normals[i1 + length] = normal.y;\n                    normals[i2 + length] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                    tangents[i] = tangent.x;\n                    tangents[i1] = tangent.y;\n                    tangents[i2] = tangent.z;\n\n                    tangents[i + length] = tangent.x;\n                    tangents[i + 1 + length] = tangent.y;\n                    tangents[i + 2 + length] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[i ] = bitangent.x;\n                    bitangents[i1] = bitangent.y;\n                    bitangents[i2] = bitangent.z;\n\n                    bitangents[i + length] = bitangent.x;\n                    bitangents[i1 + length] = bitangent.y;\n                    bitangents[i2 + length] = bitangent.z;\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function computeWallIndices(positions) {\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 6);\n        var index = 0;\n        for (var i = 0; i < length; i++) {\n            var UL = i;\n            var LL = i + length;\n            var UR = (UL + 1) % length;\n            var LR = UR + length;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n        }\n\n        return indices;\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var outerPositions = cep.outerPositions;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var topBottomAttributes = computeTopBottomAttributes(positions, options, true);\n        var indices = topIndices(numPts);\n        var length = indices.length;\n        indices.length = length * 2;\n        var posLength = positions.length / 3;\n        for (var i = 0; i < length; i += 3) {\n            indices[i + length] = indices[i + 2] + posLength;\n            indices[i + 1 + length] = indices[i + 1] + posLength;\n            indices[i + 2 + length] = indices[i] + posLength;\n        }\n\n        var topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);\n\n        var topBottomGeo = new Geometry({\n            attributes : topBottomAttributes,\n            indices : topBottomIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var wallAttributes = computeWallAttributes(outerPositions, options);\n        indices = computeWallIndices(outerPositions);\n        var wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);\n\n        var wallGeo = new Geometry({\n            attributes : wallAttributes,\n            indices : wallIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : wallGeo\n            })\n        ]);\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : geo[0].attributes,\n            indices : geo[0].indices\n        };\n    }\n\n    function computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result) {\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : center,\n            semiMajorAxis : semiMajorAxis,\n            semiMinorAxis : semiMinorAxis,\n            rotation : rotation,\n            granularity : granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n        var rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n        // When this happens, make the rectangle into a \"circle\" around the pole\n        if (rectangle.width > CesiumMath.PI) {\n            rectangle.north = rectangle.north > 0.0 ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7 : rectangle.north;\n            rectangle.south = rectangle.south < 0.0 ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO : rectangle.south;\n            rectangle.east = CesiumMath.PI;\n            rectangle.west = -CesiumMath.PI;\n        }\n        return rectangle;\n    }\n\n    /**\n     * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias EllipseGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     *\n     * @example\n     * // Create an ellipse.\n     * var ellipse = new Cesium.EllipseGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n     *\n     * @see EllipseGeometry.createGeometry\n     */\n    function EllipseGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createEllipseGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 9;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseGeometry} [result] The object into which to store the result.\n     * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n     */\n    EllipseGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle based on the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {Rectangle} [result] An object in which to store the result\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    EllipseGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var rotation = defaultValue(options.rotation, 0.0);\n\n        \n\n        return computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result);\n    };\n\n    /**\n     * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            vertexFormat : ellipseGeometry._vertexFormat,\n            stRotation : ellipseGeometry._stRotation\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.shadowVolume = ellipseGeometry._shadowVolume;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    EllipseGeometry.createShadowVolume = function(ellipseGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = ellipseGeometry._granularity;\n        var ellipsoid = ellipseGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new EllipseGeometry({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            stRotation : ellipseGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    function textureCoordinateRotationPoints(ellipseGeometry) {\n        var stRotation = -ellipseGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            rotation : ellipseGeometry._rotation,\n            granularity : ellipseGeometry._granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n\n        var ellipsoid = ellipseGeometry._ellipsoid;\n        var boundingRectangle = ellipseGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(EllipseGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default EllipseGeometry;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport EllipseGeometryLibrary from './EllipseGeometryLibrary.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    var scratchCartesian1 = new Cartesian3();\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)\n            })\n        });\n\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n        var index = 0;\n        for ( var i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)\n            })\n        });\n\n        positions = attributes.position.values;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var length = positions.length/3;\n\n        if (defined(options.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n        numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length/2);\n\n        var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);\n\n        length /= 2;\n        var index = 0;\n        var i;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, length);\n            numSide = Math.round(length / numSideLines);\n\n            var maxI = Math.min(numSide * numberOfVerticalLines, length);\n            for (i = 0; i < maxI; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + length;\n            }\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    /**\n     * A description of the outline of an ellipse on an ellipsoid.\n     *\n     * @alias EllipseOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n     * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     * @see EllipseOutlineGeometry.createGeometry\n     *\n     * @example\n     * var ellipse = new Cesium.EllipseOutlineGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n     */\n    function EllipseOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createEllipseOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++]   = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n     * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n     */\n    EllipseOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseOutlineGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseOutlineGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            numberOfVerticalLines : ellipseGeometry._numberOfVerticalLines\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\nexport default EllipseOutlineGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipseGeometry from '../Core/EllipseGeometry.js';\nimport EllipseOutlineGeometry from '../Core/EllipseOutlineGeometry.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function EllipseGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.center = undefined;\n        this.semiMajorAxis = undefined;\n        this.semiMinorAxis = undefined;\n        this.rotation = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipses.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipseGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipseGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipseGeometryOptions(entity),\n            geometryPropertyName : 'ellipse',\n            observedPropertyNames : ['availability', 'position', 'ellipse']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipse', entity.ellipse, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipseGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipseGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    EllipseGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse) {\n        var position = entity.position;\n\n        return !defined(position) || !defined(ellipse.semiMajorAxis) || !defined(ellipse.semiMinorAxis) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipse);\n    };\n\n    EllipseGeometryUpdater.prototype._isDynamic = function(entity, ellipse) {\n        return !entity.position.isConstant || //\n               !ellipse.semiMajorAxis.isConstant || //\n               !ellipse.semiMinorAxis.isConstant || //\n               !Property.isConstant(ellipse.rotation) || //\n               !Property.isConstant(ellipse.height) || //\n               !Property.isConstant(ellipse.extrudedHeight) || //\n               !Property.isConstant(ellipse.granularity) || //\n               !Property.isConstant(ellipse.stRotation) || //\n               !Property.isConstant(ellipse.outlineWidth) || //\n               !Property.isConstant(ellipse.numberOfVerticalLines) || //\n               !Property.isConstant(ellipse.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    EllipseGeometryUpdater.prototype._setStaticOptions = function(entity, ellipse) {\n        var heightValue = Property.getValueOrUndefined(ellipse.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.center = entity.position.getValue(Iso8601.MINIMUM_VALUE, options.center);\n        options.semiMajorAxis = ellipse.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);\n        options.semiMinorAxis = ellipse.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    EllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipseGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipseGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;\n    }\n\n    DynamicEllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse, time) {\n        var options = this._options;\n        return !defined(options.center) || !defined(options.semiMajorAxis) || !defined(options.semiMinorAxis) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time);\n    };\n\n    DynamicEllipseGeometryUpdater.prototype._setOptions = function(entity, ellipse, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(ellipse.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.center = Property.getValueOrUndefined(entity.position, time, options.center);\n        options.semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);\n        options.semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default EllipseGeometryUpdater;\n","import Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipsoidGeometry from '../Core/EllipsoidGeometry.js';\nimport EllipsoidOutlineGeometry from '../Core/EllipsoidOutlineGeometry.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GeometryOffsetAttribute from '../Core/GeometryOffsetAttribute.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport heightReferenceOnEntityPropertyChanged from './heightReferenceOnEntityPropertyChanged.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var radiiScratch = new Cartesian3();\n    var innerRadiiScratch = new Cartesian3();\n    var scratchColor = new Color();\n    var unitSphere = new Cartesian3(1, 1, 1);\n\n    function EllipsoidGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.radii = undefined;\n        this.innerRadii = undefined;\n        this.minimumClock = undefined;\n        this.maximumClock = undefined;\n        this.minimumCone = undefined;\n        this.maximumCone = undefined;\n        this.stackPartitions = undefined;\n        this.slicePartitions = undefined;\n        this.subdivisions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipsoids.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipsoidGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipsoidGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipsoidGeometryOptions(entity),\n            geometryPropertyName : 'ellipsoid',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'ellipsoid']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipsoid', entity.ellipsoid, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n    }\n\n    defineProperties(EllipsoidGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof EllipsoidGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty : {\n            get : function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes.color = color;\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidOutlineGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    EllipsoidGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isHidden = function(entity, ellipsoid) {\n        return !defined(entity.position) || !defined(ellipsoid.radii) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isDynamic = function(entity, ellipsoid) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !ellipsoid.radii.isConstant || //\n               !Property.isConstant(ellipsoid.innerRadii) || //\n               !Property.isConstant(ellipsoid.stackPartitions) || //\n               !Property.isConstant(ellipsoid.slicePartitions) || //\n               !Property.isConstant(ellipsoid.outlineWidth) || //\n               !Property.isConstant(ellipsoid.minimumClock) || //\n               !Property.isConstant(ellipsoid.maximumClock) || //\n               !Property.isConstant(ellipsoid.minimumCone) || //\n               !Property.isConstant(ellipsoid.maximumCone) || //\n               !Property.isConstant(ellipsoid.subdivisions);\n    };\n\n    EllipsoidGeometryUpdater.prototype._setStaticOptions = function(entity, ellipsoid) {\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.radii = ellipsoid.radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);\n        options.innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, options.radii);\n        options.minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, Iso8601.MINIMUM_VALUE);\n        options.maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, Iso8601.MINIMUM_VALUE);\n        options.minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, Iso8601.MINIMUM_VALUE);\n        options.maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, Iso8601.MINIMUM_VALUE);\n        options.stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, Iso8601.MINIMUM_VALUE);\n        options.slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, Iso8601.MINIMUM_VALUE);\n        options.subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    EllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipsoidGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n\n        this._scene = geometryUpdater._scene;\n        this._modelMatrix = new Matrix4();\n        this._attributes = undefined;\n        this._outlineAttributes = undefined;\n        this._lastSceneMode = undefined;\n        this._lastShow = undefined;\n        this._lastOutlineShow = undefined;\n        this._lastOutlineWidth = undefined;\n        this._lastOutlineColor = undefined;\n        this._lastOffset = new Cartesian3();\n        this._material = {};\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipsoidGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;\n    }\n\n    DynamicEllipsoidGeometryUpdater.prototype.update = function(time) {\n        \n\n        var entity = this._entity;\n        var ellipsoid = entity.ellipsoid;\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);\n        var modelMatrix = defined(radii) ? entity.computeModelMatrixForHeightReference(time, ellipsoid.heightReference, radii.z * 0.5, this._scene.mapProjection.ellipsoid, this._modelMatrix) : undefined;\n        if (!defined(modelMatrix) || !defined(radii)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        //Compute attributes and material.\n        var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n        var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);\n        var outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);\n        var material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material);\n\n        // Check properties that could trigger a primitive rebuild.\n        var innerRadii = Property.getValueOrUndefined(ellipsoid.innerRadii, time, innerRadiiScratch);\n        var minimumClock = Property.getValueOrUndefined(ellipsoid.minimumClock, time);\n        var maximumClock = Property.getValueOrUndefined(ellipsoid.maximumClock, time);\n        var minimumCone = Property.getValueOrUndefined(ellipsoid.minimumCone, time);\n        var maximumCone = Property.getValueOrUndefined(ellipsoid.maximumCone, time);\n        var stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);\n        var slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);\n        var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);\n        var outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1.0);\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, time, HeightReference.NONE);\n        var offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n\n        //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n        //Also check for height reference because this method doesn't work when the height is relative to terrain.\n        var sceneMode = this._scene.mode;\n        var in3D = sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n\n        var options = this._options;\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n        var distanceDisplayConditionProperty = this._geometryUpdater.distanceDisplayConditionProperty;\n        var distanceDisplayCondition = distanceDisplayConditionProperty.getValue(time);\n\n        var offset = Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, time, defaultOffset, offsetScratch);\n\n        //We only rebuild the primitive if something other than the radii has changed\n        //For the radii, we use unit sphere and then deform it with a scale matrix.\n        var rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) || //\n                                options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions || //\n                                defined(innerRadii) && !Cartesian3.equals(options.innerRadii !== innerRadii) || options.minimumClock !== minimumClock || //\n                                options.maximumClock !== maximumClock || options.minimumCone !== minimumCone || //\n                                options.maximumCone !== maximumCone || options.subdivisions !== subdivisions || //\n                                this._lastOutlineWidth !== outlineWidth || options.offsetAttribute !== offsetAttribute;\n\n        if (rebuildPrimitives) {\n            var primitives = this._primitives;\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._primitive = undefined;\n            this._outlinePrimitive = undefined;\n            this._lastSceneMode = sceneMode;\n            this._lastOutlineWidth = outlineWidth;\n\n            options.stackPartitions = stackPartitions;\n            options.slicePartitions = slicePartitions;\n            options.subdivisions = subdivisions;\n            options.offsetAttribute = offsetAttribute;\n            options.radii = Cartesian3.clone(in3D ? unitSphere : radii, options.radii);\n            if (defined(innerRadii)) {\n                if (in3D) {\n                    var mag = Cartesian3.magnitude(radii);\n                    options.innerRadii = Cartesian3.fromElements(innerRadii.x / mag, innerRadii.y / mag, innerRadii.z / mag, options.innerRadii);\n                } else {\n                    options.innerRadii = Cartesian3.clone(innerRadii, options.innerRadii);\n                }\n            } else {\n                options.innerRadii = undefined;\n            }\n            options.minimumClock = minimumClock;\n            options.maximumClock = maximumClock;\n            options.minimumCone = minimumCone;\n            options.maximumCone = maximumCone;\n\n            var appearance = new MaterialAppearance({\n                material : material,\n                translucent : material.isTranslucent(),\n                closed : true\n            });\n            options.vertexFormat = appearance.vertexFormat;\n\n            var fillInstance = this._geometryUpdater.createFillGeometryInstance(time, in3D, this._modelMatrix);\n\n            this._primitive = primitives.add(new Primitive({\n                geometryInstances : fillInstance,\n                appearance : appearance,\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time, in3D, this._modelMatrix);\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : this._geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            this._lastShow = showFill;\n            this._lastOutlineShow = showOutline;\n            this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n            this._lastDistanceDisplayCondition = distanceDisplayCondition;\n            this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n        } else if (this._primitive.ready) {\n            //Update attributes only.\n            var primitive = this._primitive;\n            var outlinePrimitive = this._outlinePrimitive;\n\n            primitive.show = true;\n            outlinePrimitive.show = true;\n            primitive.appearance.material = material;\n\n            var attributes = this._attributes;\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(entity);\n                this._attributes = attributes;\n            }\n            if (showFill !== this._lastShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);\n                this._lastShow = showFill;\n            }\n\n            var outlineAttributes = this._outlineAttributes;\n\n            if (!defined(outlineAttributes)) {\n                outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n                this._outlineAttributes = outlineAttributes;\n            }\n\n            if (showOutline !== this._lastOutlineShow) {\n                outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);\n                this._lastOutlineShow = showOutline;\n            }\n\n            if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n                outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);\n                Color.clone(outlineColor, this._lastOutlineColor);\n            }\n\n            if (!DistanceDisplayCondition.equals(distanceDisplayCondition, this._lastDistanceDisplayCondition)) {\n                attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, outlineAttributes.distanceDisplayCondition);\n                DistanceDisplayCondition.clone(distanceDisplayCondition, this._lastDistanceDisplayCondition);\n            }\n\n            if (!Cartesian3.equals(offset, this._lastOffset)) {\n                attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                outlineAttributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                Cartesian3.clone(offset, this._lastOffset);\n            }\n        }\n\n        if (in3D) {\n            //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n            //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n            //that you get passing EllipsoidGeometry a radii with a zero component.\n            radii.x = Math.max(radii.x, 0.001);\n            radii.y = Math.max(radii.y, 0.001);\n            radii.z = Math.max(radii.z, 0.001);\n\n            modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n            this._primitive.modelMatrix = modelMatrix;\n            this._outlinePrimitive.modelMatrix = modelMatrix;\n        }\n    };\nexport default EllipsoidGeometryUpdater;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    /**\n     * Describes geometry representing a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @example\n     * var planeGeometry = new Cesium.PlaneGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n     * });\n     */\n    function PlaneGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        this._vertexFormat = vertexFormat;\n        this._workerName = 'createPlaneGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneGeometry.packedLength = VertexFormat.packedLength;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat: scratchVertexFormat\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneGeometry} [result] The object into which to store the result.\n     * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.\n     */\n    PlaneGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n\n        if (!defined(result)) {\n            return new PlaneGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PlaneGeometry} planeGeometry A description of the plane.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneGeometry.createGeometry = function(planeGeometry) {\n        var vertexFormat = planeGeometry._vertexFormat;\n\n        var attributes = new GeometryAttributes();\n        var indices;\n        var positions;\n\n        if (vertexFormat.position) {\n            // 4 corner points.  Duplicated 3 times each for each incident edge/face.\n            positions = new Float64Array(4 * 3);\n\n            // +z face\n            positions[0]  = min.x;\n            positions[1]  = min.y;\n            positions[2]  = 0.0;\n            positions[3]  = max.x;\n            positions[4]  = min.y;\n            positions[5]  = 0.0;\n            positions[6]  = max.x;\n            positions[7]  = max.y;\n            positions[8]  = 0.0;\n            positions[9]  = min.x;\n            positions[10] = max.y;\n            positions[11] = 0.0;\n\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n\n            if (vertexFormat.normal) {\n                var normals = new Float32Array(4 * 3);\n\n                // +z face\n                normals[0]  = 0.0;\n                normals[1]  = 0.0;\n                normals[2]  = 1.0;\n                normals[3]  = 0.0;\n                normals[4]  = 0.0;\n                normals[5]  = 1.0;\n                normals[6]  = 0.0;\n                normals[7]  = 0.0;\n                normals[8]  = 1.0;\n                normals[9]  = 0.0;\n                normals[10] = 0.0;\n                normals[11] = 1.0;\n\n                attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.st) {\n                var texCoords = new Float32Array(4 * 2);\n\n                // +z face\n                texCoords[0]  = 0.0;\n                texCoords[1]  = 0.0;\n                texCoords[2]  = 1.0;\n                texCoords[3]  = 0.0;\n                texCoords[4]  = 1.0;\n                texCoords[5]  = 1.0;\n                texCoords[6]  = 0.0;\n                texCoords[7]  = 1.0;\n\n                attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : texCoords\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                var tangents = new Float32Array(4 * 3);\n\n                // +z face\n                tangents[0]  = 1.0;\n                tangents[1]  = 0.0;\n                tangents[2]  = 0.0;\n                tangents[3]  = 1.0;\n                tangents[4]  = 0.0;\n                tangents[5]  = 0.0;\n                tangents[6]  = 1.0;\n                tangents[7]  = 0.0;\n                tangents[8]  = 0.0;\n                tangents[9]  = 1.0;\n                tangents[10] = 0.0;\n                tangents[11] = 0.0;\n\n                attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                var bitangents = new Float32Array(4 * 3);\n\n                // +z face\n                bitangents[0] = 0.0;\n                bitangents[1] = 1.0;\n                bitangents[2] = 0.0;\n                bitangents[3] = 0.0;\n                bitangents[4] = 1.0;\n                bitangents[5] = 0.0;\n                bitangents[6] = 0.0;\n                bitangents[7] = 1.0;\n                bitangents[8] = 0.0;\n                bitangents[9] = 0.0;\n                bitangents[10] = 1.0;\n                bitangents[11] = 0.0;\n\n                attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            // 2 triangles\n            indices = new Uint16Array(2 * 3);\n\n            // +z face\n            indices[0] = 0;\n            indices[1] = 1;\n            indices[2] = 2;\n            indices[3] = 0;\n            indices[4] = 2;\n            indices[5] = 3;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\nexport default PlaneGeometry;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    /**\n     * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneOutlineGeometry\n     * @constructor\n     *\n     */\n    function PlaneOutlineGeometry() {\n        this._workerName = 'createPlaneOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneOutlineGeometry.packedLength = 0;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneOutlineGeometry.pack = function(value, array) {\n        \n\n        return array;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.\n     */\n    PlaneOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        if (!defined(result)) {\n            return new PlaneOutlineGeometry();\n        }\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneOutlineGeometry.createGeometry = function() {\n        var attributes = new GeometryAttributes();\n        var indices = new Uint16Array(4 * 2);\n        var positions = new Float64Array(4 * 3);\n\n        positions[0] = min.x;\n        positions[1] = min.y;\n        positions[2] = min.z;\n        positions[3] = max.x;\n        positions[4] = min.y;\n        positions[5] = min.z;\n        positions[6] = max.x;\n        positions[7] = max.y;\n        positions[8] = min.z;\n        positions[9] = min.x;\n        positions[10] = max.y;\n        positions[11] = min.z;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        indices[0] = 0;\n        indices[1] = 1;\n        indices[2] = 1;\n        indices[3] = 2;\n        indices[4] = 2;\n        indices[5] = 3;\n        indices[6] = 3;\n        indices[7] = 0;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\nexport default PlaneOutlineGeometry;\n","import Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport CesiumMath from '../Core/Math.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport PlaneGeometry from '../Core/PlaneGeometry.js';\nimport PlaneOutlineGeometry from '../Core/PlaneOutlineGeometry.js';\nimport Quaternion from '../Core/Quaternion.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function PlaneGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.plane = undefined;\n        this.dimensions = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for planes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PlaneGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PlaneGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PlaneGeometryOptions(entity),\n            geometryPropertyName : 'plane',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'plane']\n        });\n\n        this._onEntityPropertyChanged(entity, 'plane', entity.plane, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PlaneGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PlaneGeometryUpdater.prototype.constructor = PlaneGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PlaneGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneGeometry(this._options),\n            modelMatrix : modelMatrix,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PlaneGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneOutlineGeometry(),\n            modelMatrix : modelMatrix,\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PlaneGeometryUpdater.prototype._isHidden = function(entity, plane) {\n        return !defined(plane.plane) || !defined(plane.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, plane);\n    };\n\n    PlaneGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    PlaneGeometryUpdater.prototype._isDynamic = function(entity, plane) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !plane.plane.isConstant || //\n               !plane.dimensions.isConstant || //\n               !Property.isConstant(plane.outlineWidth);\n    };\n\n    PlaneGeometryUpdater.prototype._setStaticOptions = function(entity, plane) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.plane = plane.plane.getValue(Iso8601.MINIMUM_VALUE, options.plane);\n        options.dimensions = plane.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n    };\n\n    PlaneGeometryUpdater.DynamicGeometryUpdater = DynamicPlaneGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPlaneGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPlaneGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPlaneGeometryUpdater.prototype.constructor = DynamicPlaneGeometryUpdater;\n    }\n\n    DynamicPlaneGeometryUpdater.prototype._isHidden = function(entity, plane, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.plane) || !defined(options.dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, plane, time);\n    };\n\n    DynamicPlaneGeometryUpdater.prototype._setOptions = function(entity, plane, time) {\n        var options = this._options;\n        options.plane = Property.getValueOrDefault(plane.plane, time, options.plane);\n        options.dimensions = Property.getValueOrUndefined(plane.dimensions, time, options.dimensions);\n    };\n\n    var scratchAxis = new Cartesian3();\n    var scratchAxis2 = new Cartesian3();\n    var scratchTranslation = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchScale = new Cartesian3();\n    var scratchQuaternion = new Quaternion();\n    var scratchMatrix3 = new Matrix3();\n    function createPrimitiveMatrix(plane, dimensions, transform, ellipsoid, result) {\n        var normal = plane.normal;\n        var distance = plane.distance;\n\n        var translation = Cartesian3.multiplyByScalar(normal, -distance, scratchTranslation);\n        translation = Matrix4.multiplyByPoint(transform, translation, translation);\n\n        var transformedNormal = Matrix4.multiplyByPointAsVector(transform, normal, scratchNormal);\n        Cartesian3.normalize(transformedNormal, transformedNormal);\n\n        var up = ellipsoid.geodeticSurfaceNormal(translation, scratchAxis2);\n        if (CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(up, transformedNormal)), 1.0, CesiumMath.EPSILON8)) {\n            up = Cartesian3.clone(Cartesian3.UNIT_Z, up);\n        }\n\n        var left = Cartesian3.cross(up, transformedNormal, scratchAxis);\n        up = Cartesian3.cross(transformedNormal, left, up);\n        Cartesian3.normalize(left, left);\n        Cartesian3.normalize(up, up);\n\n        var rotationMatrix = scratchMatrix3;\n        Matrix3.setColumn(rotationMatrix, 0, left, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 1, up, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 2, transformedNormal, rotationMatrix);\n        var rotation = Quaternion.fromRotationMatrix(rotationMatrix, scratchQuaternion);\n\n        var scale = Cartesian2.clone(dimensions, scratchScale);\n        scale.z = 1.0;\n\n        return Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, result);\n    }\n\n    /**\n     * @private\n     */\n    PlaneGeometryUpdater.createPrimitiveMatrix = createPrimitiveMatrix;\nexport default PlaneGeometryUpdater;\n","import Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport Matrix3 from './Matrix3.js';\nimport OrientedBoundingBox from './OrientedBoundingBox.js';\n\n    /**\n     * @private\n     */\n    var CoplanarPolygonGeometryLibrary = {};\n\n    var scratchIntersectionPoint = new Cartesian3();\n    var scratchXAxis = new Cartesian3();\n    var scratchYAxis = new Cartesian3();\n    var scratchZAxis = new Cartesian3();\n    var obbScratch = new OrientedBoundingBox();\n\n    CoplanarPolygonGeometryLibrary.validOutline = function(positions) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        return !((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0));\n    };\n\n    // call after removeDuplicates\n    CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function(positions, centerResult, planeAxis1Result, planeAxis2Result) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n        var min = Math.min(xMag, yMag, zMag);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        if ((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0)) {\n            return false;\n        }\n\n        var planeAxis1;\n        var planeAxis2;\n\n        if (min === yMag || min === zMag) {\n            planeAxis1 = xAxis;\n        }\n        if (min === xMag) {\n            planeAxis1 = yAxis;\n        } else if (min === zMag) {\n            planeAxis2 = yAxis;\n        }\n        if (min === xMag || min === yMag) {\n            planeAxis2 = zAxis;\n        }\n\n        Cartesian3.normalize(planeAxis1, planeAxis1Result);\n        Cartesian3.normalize(planeAxis2, planeAxis2Result);\n        Cartesian3.clone(orientedBoundingBox.center, centerResult);\n        return true;\n    };\n\n    function projectTo2D(position, center, axis1, axis2, result) {\n        var v = Cartesian3.subtract(position, center, scratchIntersectionPoint);\n        var x = Cartesian3.dot(axis1, v);\n        var y = Cartesian3.dot(axis2, v);\n\n        return Cartesian2.fromElements(x, y, result);\n    }\n\n    CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function(center, axis1, axis2) {\n        return function(positions) {\n            var positionResults = new Array(positions.length);\n            for (var i = 0; i < positions.length; i++) {\n                positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);\n            }\n\n            return positionResults;\n        };\n    };\n\n    CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function(center, axis1, axis2) {\n        return function(position, result) {\n            return projectTo2D(position, center, axis1, axis2, result);\n        };\n    };\nexport default CoplanarPolygonGeometryLibrary;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CoplanarPolygonGeometryLibrary from './CoplanarPolygonGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchPosition = new Cartesian3();\n    var scratchBR = new BoundingRectangle();\n    var stScratch = new Cartesian2();\n    var textureCoordinatesOrigin = new Cartesian2();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var centerScratch = new Cartesian3();\n    var axis1Scratch = new Cartesian3();\n    var axis2Scratch = new Cartesian3();\n    var quaternionScratch = new Quaternion();\n    var textureMatrixScratch = new Matrix3();\n    var tangentRotationScratch = new Matrix3();\n    var surfaceNormalScratch = new Cartesian3();\n\n    function createGeometryFromPolygon(polygon, vertexFormat, boundingRectangle, stRotation, projectPointTo2D, normal, tangent, bitangent) {\n        var positions = polygon.positions;\n        var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n        /* If polygon is completely unrenderable, just use the first three vertices */\n        if (indices.length < 3) {\n            indices = [0, 1, 2];\n        }\n\n        var newIndices = IndexDatatype.createTypedArray(positions.length, indices.length);\n        newIndices.set(indices);\n\n        var textureMatrix = textureMatrixScratch;\n        if (stRotation !== 0.0) {\n            var rotation = Quaternion.fromAxisAngle(normal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            if (vertexFormat.tangent || vertexFormat.bitangent) {\n                rotation = Quaternion.fromAxisAngle(normal, -stRotation, quaternionScratch);\n                var tangentRotation = Matrix3.fromQuaternion(rotation, tangentRotationScratch);\n\n                tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotation, tangent, tangent), tangent);\n                if (vertexFormat.bitangent) {\n                    bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                }\n            }\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n        }\n\n        var stOrigin = textureCoordinatesOrigin;\n        if (vertexFormat.st) {\n            stOrigin.x = boundingRectangle.x;\n            stOrigin.y = boundingRectangle.y;\n        }\n\n        var length = positions.length;\n        var size = length * 3;\n        var flatPositions = new Float64Array(size);\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(length * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            if (vertexFormat.st) {\n                var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                var st = projectPointTo2D(p, stScratch);\n                Cartesian2.subtract(st, stOrigin, st);\n\n                var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                textureCoordinates[stIndex++] = stx;\n                textureCoordinates[stIndex++] = sty;\n            }\n\n            if (vertexFormat.normal) {\n                normals[normalIndex++] = normal.x;\n                normals[normalIndex++] = normal.y;\n                normals[normalIndex++] = normal.z;\n            }\n\n            if (vertexFormat.tangent) {\n                tangents[tangentIndex++] = tangent.x;\n                tangents[tangentIndex++] = tangent.y;\n                tangents[tangentIndex++] = tangent.z;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents[bitangentIndex++] = bitangent.x;\n                bitangents[bitangentIndex++] = bitangent.y;\n                bitangents[bitangentIndex++] = bitangent.z;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : newIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n    }\n\n    /**\n     * A description of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @example\n     * var polygon = new Cesium.CoplanarPolygonGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);\n     *\n     * @see CoplanarPolygonGeometry.createGeometry\n     */\n    function CoplanarPolygonGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._polygonHierarchy = polygonHierarchy;\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createCoplanarPolygonGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + VertexFormat.packedLength + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * A description of a coplanar polygon from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @returns {CoplanarPolygonGeometry}\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    CoplanarPolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid\n        };\n        return new CoplanarPolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\n     */\n    CoplanarPolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var stRotation = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._stRotation = stRotation;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var stRotation = polygonGeometry._stRotation;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var axis1 = axis1Scratch;\n        var axis2 = axis2Scratch;\n\n        var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(outerPositions, centerScratch, axis1, axis2);\n        if (!validGeometry) {\n            return undefined;\n        }\n\n        normal = Cartesian3.cross(axis1, axis2, normal);\n        normal = Cartesian3.normalize(normal, normal);\n\n        if (!Cartesian3.equalsEpsilon(centerScratch, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n            var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(centerScratch, surfaceNormalScratch);\n            if (Cartesian3.dot(normal, surfaceNormal) < 0) {\n                normal = Cartesian3.negate(normal, normal);\n                axis1 = Cartesian3.negate(axis1, axis1);\n            }\n        }\n\n        var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch, axis1, axis2);\n        var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch, axis1, axis2);\n\n        if (vertexFormat.tangent) {\n            tangent = Cartesian3.clone(axis1, tangent);\n        }\n        if (vertexFormat.bitangent) {\n            bitangent = Cartesian3.clone(axis2, bitangent);\n        }\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, projectPoints, false);\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n        outerPositions = hierarchy[0].outerRing;\n\n        var boundingSphere = BoundingSphere.fromPoints(outerPositions);\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(normal, projectPoint, outerPositions, stRotation, scratchBR);\n\n        var geometries = [];\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPolygon(polygons[i], vertexFormat, boundingRectangle, stRotation, projectPoint, normal, tangent, bitangent)\n            });\n\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\nexport default CoplanarPolygonGeometry;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CoplanarPolygonGeometryLibrary from './CoplanarPolygonGeometryLibrary.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\n\n    function createGeometryFromPositions(positions){\n        var length = positions.length;\n        var flatPositions = new Float64Array(length * 3);\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n\n        var positionIndex = 0;\n        var index = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            })\n        });\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     *\n     * @see CoplanarPolygonOutlineGeometry.createGeometry\n     *\n     * @example\n     * var polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);\n     */\n    function CoplanarPolygonOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        this._polygonHierarchy = polygonHierarchy;\n        this._workerName = 'createCoplanarPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + 1;\n    }\n\n    /**\n     * A description of a coplanar polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @returns {CoplanarPolygonOutlineGeometry}\n     */\n    CoplanarPolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            }\n        };\n        return new CoplanarPolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.\n     */\n    CoplanarPolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonOutlineGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n        var isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);\n        if (!isValid) {\n            return undefined;\n        }\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, false);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometries = [];\n\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPositions(polygons[i])\n            });\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\nexport default CoplanarPolygonOutlineGeometry;\n","import ArcType from './ArcType.js';\nimport arrayFill from './arrayFill.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport VertexFormat from './VertexFormat.js';\nimport WindingOrder from './WindingOrder.js';\n\n    var scratchCarto1 = new Cartographic();\n    var scratchCarto2 = new Cartographic();\n    function adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n        var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n        var height = carto1.height;\n        var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n        p1Carto.height = height;\n        ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n        var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n        p2Carto.height = height - 100;\n        ellipsoid.cartographicToCartesian(p2Carto, p2);\n    }\n\n    var scratchBoundingRectangle = new BoundingRectangle();\n    var scratchPosition = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var p1Scratch = new Cartesian3();\n    var p2Scratch = new Cartesian3();\n    var scratchPerPosNormal = new Cartesian3();\n    var scratchPerPosTangent = new Cartesian3();\n    var scratchPerPosBitangent = new Cartesian3();\n\n    var appendTextureCoordinatesOrigin = new Cartesian2();\n    var appendTextureCoordinatesCartesian2 = new Cartesian2();\n    var appendTextureCoordinatesCartesian3 = new Cartesian3();\n    var appendTextureCoordinatesQuaternion = new Quaternion();\n    var appendTextureCoordinatesMatrix3 = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n\n    function computeAttributes(options) {\n        var vertexFormat = options.vertexFormat;\n        var geometry = options.geometry;\n        var shadowVolume = options.shadowVolume;\n        var flatPositions = geometry.attributes.position.values;\n        var length = flatPositions.length;\n        var wall = options.wall;\n        var top = options.top || wall;\n        var bottom = options.bottom || wall;\n        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n            // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n            // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n            var boundingRectangle = options.boundingRectangle;\n            var tangentPlane = options.tangentPlane;\n            var ellipsoid = options.ellipsoid;\n            var stRotation = options.stRotation;\n            var perPositionHeight = options.perPositionHeight;\n\n            var origin = appendTextureCoordinatesOrigin;\n            origin.x = boundingRectangle.x;\n            origin.y = boundingRectangle.y;\n\n            var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;\n            var normals;\n            if (vertexFormat.normal) {\n                if (perPositionHeight && top && !wall) {\n                    normals = geometry.attributes.normal.values;\n                } else {\n                    normals = new Float32Array(length);\n                }\n            }\n            var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n            var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n            var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n            var textureCoordIndex = 0;\n            var attrIndex = 0;\n\n            var normal = scratchNormal;\n            var tangent = scratchTangent;\n            var bitangent = scratchBitangent;\n            var recomputeNormal = true;\n\n            var textureMatrix = appendTextureCoordinatesMatrix3;\n            var tangentRotationMatrix = tangentMatrixScratch;\n            if (stRotation !== 0.0) {\n                var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);\n                textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n                rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, -stRotation, appendTextureCoordinatesQuaternion);\n                tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);\n            } else {\n                textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n                tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n            }\n\n            var bottomOffset = 0;\n            var bottomOffset2 = 0;\n\n            if (top && bottom) {\n                bottomOffset = length / 2;\n                bottomOffset2 = length / 3;\n\n                length /= 2;\n            }\n\n            for ( var i = 0; i < length; i += 3) {\n                var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);\n\n                if (vertexFormat.st) {\n                    var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                    p = ellipsoid.scaleToGeodeticSurface(p,p);\n                    var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);\n                    Cartesian2.subtract(st, origin, st);\n\n                    var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                    var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                    if (bottom) {\n                        textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n                        textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n                    }\n                    if (top) {\n                        textureCoordinates[textureCoordIndex] = stx;\n                        textureCoordinates[textureCoordIndex + 1] = sty;\n                    }\n\n                    textureCoordIndex += 2;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                    var attrIndex1 = attrIndex + 1;\n                    var attrIndex2 = attrIndex + 2;\n\n                    if (wall) {\n                        if (i + 3 < length) {\n                            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n                            if (recomputeNormal) {\n                                var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);\n                                if (perPositionHeight) {\n                                    adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n                                }\n                                Cartesian3.subtract(p1, position, p1);\n                                Cartesian3.subtract(p2, position, p2);\n                                normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                                recomputeNormal = false;\n                            }\n\n                            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) { // if we've reached a corner\n                                recomputeNormal = true;\n                            }\n                        }\n\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n                            if (vertexFormat.tangent) {\n                                tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                            }\n                        }\n                    } else {\n                        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            if (perPositionHeight) {\n                                scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);\n                                scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);\n                                scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);\n                                if (vertexFormat.bitangent) {\n                                    scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);\n                                }\n                            }\n\n                            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);\n                            if (vertexFormat.bitangent) {\n                                bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.normal) {\n                        if (options.wall) {\n                            normals[attrIndex + bottomOffset] = normal.x;\n                            normals[attrIndex1 + bottomOffset] = normal.y;\n                            normals[attrIndex2 + bottomOffset] = normal.z;\n                        } else if (bottom){\n                            normals[attrIndex + bottomOffset] = -normal.x;\n                            normals[attrIndex1 + bottomOffset] = -normal.y;\n                            normals[attrIndex2 + bottomOffset] = -normal.z;\n                        }\n\n                        if ((top && !perPositionHeight) || wall) {\n                            normals[attrIndex] = normal.x;\n                            normals[attrIndex1] = normal.y;\n                            normals[attrIndex2] = normal.z;\n                        }\n                    }\n\n                    if (shadowVolume) {\n                        if (wall) {\n                            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        }\n                        extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n                        extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n                        extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        if (options.wall) {\n                            tangents[attrIndex + bottomOffset] = tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = tangent.z;\n                        } else if (bottom) {\n                            tangents[attrIndex + bottomOffset] = -tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n                        }\n\n                        if(top) {\n                            if (perPositionHeight) {\n                                tangents[attrIndex] = scratchPerPosTangent.x;\n                                tangents[attrIndex1] = scratchPerPosTangent.y;\n                                tangents[attrIndex2] = scratchPerPosTangent.z;\n                            } else {\n                                tangents[attrIndex] = tangent.x;\n                                tangents[attrIndex1] = tangent.y;\n                                tangents[attrIndex2] = tangent.z;\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        if (bottom) {\n                            bitangents[attrIndex + bottomOffset] = bitangent.x;\n                            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n                            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n                        }\n                        if (top) {\n                            if (perPositionHeight) {\n                                bitangents[attrIndex] = scratchPerPosBitangent.x;\n                                bitangents[attrIndex1] = scratchPerPosBitangent.y;\n                                bitangents[attrIndex2] = scratchPerPosBitangent.z;\n                            } else {\n                                bitangents[attrIndex] = bitangent.x;\n                                bitangents[attrIndex1] = bitangent.y;\n                                bitangents[attrIndex2] = bitangent.z;\n                            }\n                        }\n                    }\n                    attrIndex += 3;\n                }\n            }\n\n            if (vertexFormat.st) {\n                geometry.attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : textureCoordinates\n                });\n            }\n\n            if (vertexFormat.normal) {\n                geometry.attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                geometry.attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                geometry.attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            if (shadowVolume) {\n                geometry.attributes.extrudeDirection = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : extrudeNormals\n                });\n            }\n        }\n\n        if (options.extrude && defined(options.offsetAttribute)) {\n            var size = flatPositions.length / 3;\n            var offsetAttribute = new Uint8Array(size);\n\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                if ((top && bottom) || wall) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                } else if (top) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1);\n                }\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            geometry.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return geometry;\n    }\n\n    var startCartographicScratch = new Cartographic();\n    var endCartographicScratch = new Cartographic();\n    var idlCross = {\n        westOverIDL : 0.0,\n        eastOverIDL : 0.0\n    };\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\n    function computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n        result = defaultValue(result, new Rectangle());\n        if (!defined(positions) || positions.length < 3) {\n            result.west = 0.0;\n            result.north = 0.0;\n            result.south = 0.0;\n            result.east = 0.0;\n            return result;\n        }\n\n        if (arcType === ArcType.RHUMB) {\n            return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        }\n\n        if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n            ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n        }\n\n        result.west = Number.POSITIVE_INFINITY;\n        result.east = Number.NEGATIVE_INFINITY;\n        result.south = Number.POSITIVE_INFINITY;\n        result.north = Number.NEGATIVE_INFINITY;\n\n        idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n        idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n\n        var inverseChordLength = 1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n        var positionsLength = positions.length;\n        var endCartographic = ellipsoid.cartesianToCartographic(positions[0], endCartographicScratch);\n        var startCartographic = startCartographicScratch;\n        var swap;\n\n        for (var i = 1; i < positionsLength; i++) {\n            swap = startCartographic;\n            startCartographic = endCartographic;\n            endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n            ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n            interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n        }\n\n        swap = startCartographic;\n        startCartographic = endCartographic;\n        endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n        ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n        interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n\n        if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n            result.west = idlCross.westOverIDL;\n            result.east = idlCross.eastOverIDL;\n\n            if (result.east > CesiumMath.PI) {\n                result.east = result.east - CesiumMath.TWO_PI;\n            }\n            if (result.west > CesiumMath.PI) {\n                result.west = result.west - CesiumMath.TWO_PI;\n            }\n        }\n\n        return result;\n    }\n\n    var interpolatedCartographicScratch = new Cartographic();\n    function interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross) {\n        var segmentLength = ellipsoidGeodesic.surfaceDistance;\n\n        var numPoints = Math.ceil(segmentLength * inverseChordLength);\n        var subsegmentDistance = numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n        var interpolationDistance = 0.0;\n\n        for (var i = 0; i < numPoints; i++) {\n            var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(interpolationDistance, interpolatedCartographicScratch);\n            interpolationDistance += subsegmentDistance;\n            var longitude = interpolatedCartographic.longitude;\n            var latitude = interpolatedCartographic.latitude;\n\n            result.west = Math.min(result.west, longitude);\n            result.east = Math.max(result.east, longitude);\n            result.south = Math.min(result.south, latitude);\n            result.north = Math.max(result.north, latitude);\n\n            var lonAdjusted = longitude >= 0 ?  longitude : longitude +  CesiumMath.TWO_PI;\n            idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n            idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n        }\n    }\n\n    var createGeometryFromPositionsExtrudedPositions = [];\n\n    function createGeometryFromPositionsExtruded(ellipsoid, polygon, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {\n        var geos = {\n            walls : []\n        };\n        var i;\n\n        if (closeTop || closeBottom) {\n            var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType);\n\n            var edgePoints = topGeo.attributes.position.values;\n            var indices = topGeo.indices;\n            var numPositions;\n            var newIndices;\n\n            if (closeTop && closeBottom) {\n                var topBottomPositions = edgePoints.concat(edgePoints);\n\n                numPositions = topBottomPositions.length / 3;\n\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);\n                newIndices.set(indices);\n                var ilength = indices.length;\n\n                var length = numPositions / 2;\n\n                for (i = 0; i < ilength; i += 3) {\n                    var i0 = newIndices[i] + length;\n                    var i1 = newIndices[i + 1] + length;\n                    var i2 = newIndices[i + 2] + length;\n\n                    newIndices[i + ilength] = i2;\n                    newIndices[i + 1 + ilength] = i1;\n                    newIndices[i + 2 + ilength] = i0;\n                }\n\n                topGeo.attributes.position.values = topBottomPositions;\n                if (perPositionHeight && vertexFormat.normal) {\n                    var normals = topGeo.attributes.normal.values;\n                    topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);\n                    topGeo.attributes.normal.values.set(normals);\n                }\n                topGeo.indices = newIndices;\n            } else if (closeBottom) {\n                numPositions = edgePoints.length / 3;\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n                for (i = 0; i < indices.length; i += 3) {\n                    newIndices[i] = indices[i + 2];\n                    newIndices[i + 1] = indices[i + 1];\n                    newIndices[i + 2] = indices[i];\n                }\n\n                topGeo.indices = newIndices;\n            }\n\n            geos.topAndBottom = new GeometryInstance({\n                geometry : topGeo\n            });\n        }\n\n        var outerRing = hierarchy.outerRing;\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);\n\n        var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (windingOrder === WindingOrder.CLOCKWISE) {\n            outerRing = outerRing.slice().reverse();\n        }\n\n        var wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, ellipsoid, granularity, perPositionHeight, arcType);\n        geos.walls.push(new GeometryInstance({\n            geometry : wallGeo\n        }));\n\n        var holes = hierarchy.holes;\n        for (i = 0; i < holes.length; i++) {\n            var hole = holes[i];\n\n            tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n            positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);\n\n            windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n            if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n                hole = hole.slice().reverse();\n            }\n\n            wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, ellipsoid, granularity, perPositionHeight, arcType);\n            geos.walls.push(new GeometryInstance({\n                geometry : wallGeo\n            }));\n        }\n\n        return geos;\n    }\n\n    /**\n     * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias PolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonGeometry#createGeometry\n     * @see PolygonGeometry#fromPositions\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n     *\n     * @example\n     * // 1. create a polygon from points\n     * var polygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes\n     * var polygonWithHole = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon\n     * var extrudedPolygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var stRotation = defaultValue(options.stRotation, 0.0);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._stRotation = stRotation;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._closeTop = defaultValue(options.closeTop, true);\n        this._closeBottom = defaultValue(options.closeBottom, true);\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createPolygonGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 12;\n    }\n\n    /**\n     * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    PolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            closeTop : options.closeTop,\n            closeBottom : options.closeBottom,\n            offsetAttribute : options.offsetAttribute,\n            arcType : options.arcType\n        };\n        return new PolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex++] = value._arcType;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n\n    //Only used to avoid inability to default construct.\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonGeometry} [result] The object into which to store the result.\n     */\n    PolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var closeTop = array[startingIndex++] === 1.0;\n        var closeBottom = array[startingIndex++] === 1.0;\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex++];\n        var arcType = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._stRotation = stRotation;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._perPositionHeight = perPositionHeight;\n        result._closeTop = closeTop;\n        result._closeBottom = closeBottom;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result._arcType = arcType;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Returns the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    PolygonGeometry.computeRectangle = function(options, result) {\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        return computeRectangle(polygonHierarchy.positions, ellipsoid, arcType, granularity, result);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var stRotation = polygonGeometry._stRotation;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var closeTop = polygonGeometry._closeTop;\n        var closeBottom = polygonGeometry._closeBottom;\n        var arcType = polygonGeometry._arcType;\n\n        var outerPositions = polygonHierarchy.positions;\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, tangentPlane.projectPointsOntoPlane.bind(tangentPlane), !perPositionHeight, ellipsoid);\n\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n\n        outerPositions = hierarchy[0].outerRing;\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);\n\n        var geometries = [];\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var options = {\n            perPositionHeight: perPositionHeight,\n            vertexFormat: vertexFormat,\n            geometry: undefined,\n            tangentPlane: tangentPlane,\n            boundingRectangle: boundingRectangle,\n            ellipsoid: ellipsoid,\n            stRotation: stRotation,\n            bottom: false,\n            top: true,\n            wall: false,\n            extrude: false,\n            arcType: arcType\n        };\n\n        var i;\n\n        if (extrude) {\n            options.extrude = true;\n            options.top = closeTop;\n            options.bottom = closeBottom;\n            options.shadowVolume = polygonGeometry._shadowVolume;\n            options.offsetAttribute = polygonGeometry._offsetAttribute;\n            for (i = 0; i < polygons.length; i++) {\n                var splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);\n\n                var topAndBottom;\n                if (closeTop && closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                } else if (closeTop) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                    options.geometry = topAndBottom.geometry;\n                } else if (closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);\n                    options.geometry = topAndBottom.geometry;\n                }\n                if (closeTop || closeBottom) {\n                    options.wall = false;\n                    topAndBottom.geometry = computeAttributes(options);\n                    geometries.push(topAndBottom);\n                }\n\n                var walls = splitGeometry.walls;\n                options.wall = true;\n                for ( var k = 0; k < walls.length; k++) {\n                    var wall = walls[k];\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                    wall.geometry = computeAttributes(options);\n                    geometries.push(wall);\n                }\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                var geometryInstance = new GeometryInstance({\n                    geometry : PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight, vertexFormat, arcType)\n                });\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                options.geometry = geometryInstance.geometry;\n                geometryInstance.geometry = computeAttributes(options);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    var offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    PolygonGeometry.createShadowVolume = function(polygonGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = polygonGeometry._granularity;\n        var ellipsoid = polygonGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new PolygonGeometry({\n            polygonHierarchy : polygonGeometry._polygonHierarchy,\n            ellipsoid : ellipsoid,\n            stRotation : polygonGeometry._stRotation,\n            granularity : granularity,\n            perPositionHeight : false,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true,\n            arcType : polygonGeometry._arcType\n        });\n    };\n\n    function textureCoordinateRotationPoints(polygonGeometry) {\n        var stRotation = -polygonGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var positions = polygonGeometry._polygonHierarchy.positions;\n        var boundingRectangle = polygonGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(PolygonGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    var positions = this._polygonHierarchy.positions;\n                    this._rectangle = computeRectangle(positions, this._ellipsoid, this._arcType, this._granularity);\n                }\n\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default PolygonGeometry;\n","import ArcType from './ArcType.js';\nimport arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonGeometryLibrary from './PolygonGeometryLibrary.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WindingOrder from './WindingOrder.js';\n    var createGeometryFromPositionsPositions = [];\n    var createGeometryFromPositionsSubdivided = [];\n\n    function createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n            subdividedPositions = new Float64Array(numVertices * 3);\n            for (i = 0; i < length; i++) {\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3);\n            for (i = 0; i < length; i++) {\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / 3;\n        var indicesSize = length * 2;\n        var indices = IndexDatatype.createTypedArray(length, indicesSize);\n        index = 0;\n        for (i = 0; i < length - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n        }\n        indices[index++] = length - 1;\n        indices[index++] = 0;\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    function createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var corners = new Array(length);\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n\n            subdividedPositions = new Float64Array(numVertices * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / (3 * 2);\n        var cornersLength = corners.length;\n\n        var indicesSize = ((length * 2) + cornersLength) * 2;\n        var indices = IndexDatatype.createTypedArray(length + cornersLength, indicesSize);\n\n        index = 0;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        for (i = 0; i < cornersLength; i++) {\n            var corner = corners[i];\n            indices[index++] = corner;\n            indices[index++] = corner + length;\n        }\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n     *\n     * @alias PolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     * @see PolygonOutlineGeometry#fromPositions\n     *\n     * @example\n     * // 1. create a polygon outline from points\n     * var polygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes outline\n     * var polygonWithHole = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon outline\n     * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonOutlineGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._arcType = arcType;\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + 8;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n     */\n    PolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var offsetAttribute = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonOutlineGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._perPositionHeight = perPositionHeight;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._arcType = arcType;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * A description of a polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     */\n    PolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            arcType: options.arcType,\n            offsetAttribute : options.offsetAttribute\n        };\n        return new PolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var arcType = polygonGeometry._arcType;\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, !perPositionHeight, ellipsoid);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometryInstance;\n        var geometries = [];\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n        var offsetValue;\n        var i;\n        if (extrude) {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometryInstance.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var size = geometryInstance.geometry.attributes.position.values.length / 3;\n                    var offsetAttribute = new Uint8Array(size);\n                    if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n                        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                    } else {\n                        offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n                    }\n\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values : offsetAttribute\n                    });\n                }\n                geometries.push(geometryInstance);\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\nexport default PolygonOutlineGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport ArcType from '../Core/ArcType.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport CoplanarPolygonGeometry from '../Core/CoplanarPolygonGeometry.js';\nimport CoplanarPolygonOutlineGeometry from '../Core/CoplanarPolygonOutlineGeometry.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport EllipsoidTangentPlane from '../Core/EllipsoidTangentPlane.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport PolygonGeometry from '../Core/PolygonGeometry.js';\nimport PolygonOutlineGeometry from '../Core/PolygonOutlineGeometry.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var heightAndPerPositionHeightWarning = 'Entity polygons cannot have both height and perPositionHeight.  height will be ignored';\n    var heightReferenceAndPerPositionHeightWarning = 'heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratch2DPositions = [];\n    var cart2Scratch = new Cartesian2();\n\n    function PolygonGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polygonHierarchy = undefined;\n        this.perPositionHeight = undefined;\n        this.closeTop = undefined;\n        this.closeBottom = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.offsetAttribute = undefined;\n        this.arcType = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polygons.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolygonGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolygonGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolygonGeometryOptions(entity),\n            geometryPropertyName : 'polygon',\n            observedPropertyNames : ['availability', 'polygon']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polygon', entity.polygon, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolygonGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        PolygonGeometryUpdater.prototype.constructor = PolygonGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolygonGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonGeometry(options);\n        } else {\n            geometry = new PolygonGeometry(options);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonOutlineGeometry(options);\n        } else {\n            geometry = new PolygonOutlineGeometry(options);\n        }\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    PolygonGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var hierarchy = Property.getValueOrUndefined(this._entity.polygon.hierarchy, time);\n        if (!defined(hierarchy)) {\n            return;\n        }\n        var positions = hierarchy.positions;\n        if (positions.length === 0) {\n            return;\n        }\n        var ellipsoid = this._scene.mapProjection.ellipsoid;\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, scratch2DPositions);\n\n        var length = positions2D.length;\n        var area = 0;\n        var j = length - 1;\n        var centroid2D = new Cartesian2();\n        for (var i = 0; i < length; j = i++) {\n            var p1 = positions2D[i];\n            var p2 = positions2D[j];\n            var f = p1.x * p2.y - p2.x * p1.y;\n\n            var sum = Cartesian2.add(p1, p2, cart2Scratch);\n            sum = Cartesian2.multiplyByScalar(sum, f, sum);\n            centroid2D = Cartesian2.add(centroid2D, sum, centroid2D);\n\n            area += f;\n        }\n\n        var a = 1.0 / (area * 3.0);\n        centroid2D = Cartesian2.multiplyByScalar(centroid2D, a, centroid2D);\n        return tangentPlane.projectPointOntoEllipsoid(centroid2D, result);\n    };\n\n    PolygonGeometryUpdater.prototype._isHidden = function(entity, polygon) {\n        return !defined(polygon.hierarchy) || GeometryUpdater.prototype._isHidden.call(this, entity, polygon);\n    };\n\n    PolygonGeometryUpdater.prototype._isOnTerrain = function(entity, polygon) {\n        var onTerrain = GroundGeometryUpdater.prototype._isOnTerrain.call(this, entity, polygon);\n        var perPositionHeightProperty = polygon.perPositionHeight;\n        var perPositionHeightEnabled = defined(perPositionHeightProperty) && (perPositionHeightProperty.isConstant ? perPositionHeightProperty.getValue(Iso8601.MINIMUM_VALUE) : true);\n        return onTerrain && !perPositionHeightEnabled;\n    };\n\n    PolygonGeometryUpdater.prototype._isDynamic = function(entity, polygon) {\n        return !polygon.hierarchy.isConstant || //\n               !Property.isConstant(polygon.height) || //\n               !Property.isConstant(polygon.extrudedHeight) || //\n               !Property.isConstant(polygon.granularity) || //\n               !Property.isConstant(polygon.stRotation) || //\n               !Property.isConstant(polygon.outlineWidth) || //\n               !Property.isConstant(polygon.perPositionHeight) || //\n               !Property.isConstant(polygon.closeTop) || //\n               !Property.isConstant(polygon.closeBottom) || //\n               !Property.isConstant(polygon.zIndex) || //\n               !Property.isConstant(polygon.arcType) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    PolygonGeometryUpdater.prototype._setStaticOptions = function(entity, polygon) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n\n        var hierarchyValue = polygon.hierarchy.getValue(Iso8601.MINIMUM_VALUE);\n        var heightValue = Property.getValueOrUndefined(polygon.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var perPositionHeightValue = Property.getValueOrDefault(polygon.perPositionHeight, Iso8601.MINIMUM_VALUE, false);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.polygonHierarchy = hierarchyValue;\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, Iso8601.MINIMUM_VALUE);\n        options.perPositionHeight = perPositionHeightValue;\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, Iso8601.MINIMUM_VALUE, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, Iso8601.MINIMUM_VALUE, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, Iso8601.MINIMUM_VALUE, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    PolygonGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var isExtruded = defined(extrudedHeight) && extrudedHeight !== height;\n        return !options.perPositionHeight && (!isExtruded && height === 0 || (isExtruded && options.closeTop && options.closeBottom));\n    };\n\n    PolygonGeometryUpdater.DynamicGeometryUpdater = DyanmicPolygonGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DyanmicPolygonGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DyanmicPolygonGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DyanmicPolygonGeometryUpdater.prototype.constructor = DyanmicPolygonGeometryUpdater;\n    }\n\n    DyanmicPolygonGeometryUpdater.prototype._isHidden = function(entity, polygon, time) {\n        return !defined(this._options.polygonHierarchy) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polygon, time);\n    };\n\n    DyanmicPolygonGeometryUpdater.prototype._setOptions = function(entity, polygon, time) {\n        var options = this._options;\n\n        options.polygonHierarchy = Property.getValueOrUndefined(polygon.hierarchy, time);\n\n        var heightValue = Property.getValueOrUndefined(polygon.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, time, HeightReference.NONE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, time);\n        var perPositionHeightValue = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, extrudedHeightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);\n        options.perPositionHeight = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, time, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, time, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, time, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default PolygonGeometryUpdater;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport oneTimeWarning from './oneTimeWarning.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\nimport WindingOrder from './WindingOrder.js';\n\n    function computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : combinedPositions\n            });\n        }\n        var shapeLength = shape.length;\n        var vertexCount = combinedPositions.length / 3;\n        var length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n        var firstEndIndices = PolygonPipeline.triangulate(shape);\n\n        var indicesCount = (length - 1) * (shapeLength) * 6 + firstEndIndices.length * 2;\n        var indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n        var i, j;\n        var ll, ul, ur, lr;\n        var offset = shapeLength * 2;\n        var index = 0;\n        for (i = 0; i < length - 1; i++) {\n            for (j = 0; j < shapeLength - 1; j++) {\n                ll = j * 2 + i * shapeLength * 2;\n                lr = ll + offset;\n                ul = ll + 1;\n                ur = ul + offset;\n\n                indices[index++] = ul;\n                indices[index++] = ll;\n                indices[index++] = ur;\n                indices[index++] = ur;\n                indices[index++] = ll;\n                indices[index++] = lr;\n            }\n            ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n            ul = ll + 1;\n            ur = ul + offset;\n            lr = ll + offset;\n\n            indices[index++] = ul;\n            indices[index++] = ll;\n            indices[index++] = ur;\n            indices[index++] = ur;\n            indices[index++] = ll;\n            indices[index++] = lr;\n        }\n\n        if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) { // st required for tangent/bitangent calculation\n            var st = new Float32Array(vertexCount * 2);\n            var lengthSt = 1 / (length - 1);\n            var heightSt = 1 / (boundingRectangle.height);\n            var heightOffset = boundingRectangle.height / 2;\n            var s, t;\n            var stindex = 0;\n            for (i = 0; i < length; i++) {\n                s = i * lengthSt;\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n                for (j = 1; j < shapeLength; j++) {\n                    t = heightSt * (shape[j].y + heightOffset);\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                }\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = 0;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = (length - 1) * lengthSt;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : new Float32Array(st)\n            });\n        }\n\n        var endOffset = vertexCount - shapeLength * 2;\n        for (i = 0; i < firstEndIndices.length; i += 3) {\n            var v0 = firstEndIndices[i] + endOffset;\n            var v1 = firstEndIndices[i + 1] + endOffset;\n            var v2 = firstEndIndices[i + 2] + endOffset;\n\n            indices[index++] = v0;\n            indices[index++] = v1;\n            indices[index++] = v2;\n            indices[index++] = v2 + shapeLength;\n            indices[index++] = v1 + shapeLength;\n            indices[index++] = v0 + shapeLength;\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : indices,\n            boundingSphere : BoundingSphere.fromVertices(combinedPositions),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        if (vertexFormat.normal) {\n            geometry = GeometryPipeline.computeNormal(geometry);\n        }\n\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n            try {\n                geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n            } catch (e) {\n                oneTimeWarning('polyline-volume-tangent-bitangent', 'Unable to compute tangents and bitangents for polyline volume geometry');\n                //TODO https://github.com/AnalyticalGraphicsInc/cesium/issues/3609\n            }\n\n            if (!vertexFormat.tangent) {\n                geometry.attributes.tangent = undefined;\n            }\n            if (!vertexFormat.bitangent) {\n                geometry.attributes.bitangent = undefined;\n            }\n            if (!vertexFormat.st) {\n                geometry.attributes.st = undefined;\n            }\n        }\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesain3} positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volume = new Cesium.PolylineVolumeGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n     */\n    PolylineVolumeGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeGeometry.createGeometry = function(polylineVolumeGeometry) {\n        var positions = polylineVolumeGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);\n        return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);\n    };\nexport default PolylineVolumeGeometry;\n","import arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingRectangle from './BoundingRectangle.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport CornerType from './CornerType.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylineVolumeGeometryLibrary from './PolylineVolumeGeometryLibrary.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WindingOrder from './WindingOrder.js';\n\n    function computeAttributes(positions, shape) {\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        var shapeLength = shape.length;\n        var vertexCount = attributes.position.values.length / 3;\n        var positionLength = positions.length / 3;\n        var shapeCount = positionLength / shapeLength;\n        var indices = IndexDatatype.createTypedArray(vertexCount, 2 * shapeLength * (shapeCount + 1));\n        var i, j;\n        var index = 0;\n        i = 0;\n        var offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        i = shapeCount - 1;\n        offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        for (i = 0; i < shapeCount - 1; i++) {\n            var firstOffset = shapeLength * i;\n            var secondOffset = firstOffset + shapeLength;\n            for (j = 0; j < shapeLength; j++) {\n                indices[index++] = j + firstOffset;\n                indices[index++] = j + secondOffset;\n            }\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : IndexDatatype.createTypedArray(vertexCount, indices),\n            boundingSphere : BoundingSphere.fromVertices(positions),\n            primitiveType : PrimitiveType.LINES\n        });\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeOutlineGeometry#createGeometry\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeOutlineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        height : undefined,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.\n     */\n    PolylineVolumeOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeOutlineGeometry.createGeometry = function(polylineVolumeOutlineGeometry) {\n        var positions = polylineVolumeOutlineGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeOutlineGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeOutlineGeometry, false);\n        return computeAttributes(computedPositions, shape2D);\n    };\nexport default PolylineVolumeOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport PolylineVolumeGeometry from '../Core/PolylineVolumeGeometry.js';\nimport PolylineVolumeOutlineGeometry from '../Core/PolylineVolumeOutlineGeometry.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n\n    function PolylineVolumeGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polylinePositions = undefined;\n        this.shapePositions = undefined;\n        this.cornerType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polyline volumes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineVolumeGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineVolumeGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolylineVolumeGeometryOptions(entity),\n            geometryPropertyName : 'polylineVolume',\n            observedPropertyNames : ['availability', 'polylineVolume']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polylineVolume', entity.polylineVolume, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolylineVolumeGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PolylineVolumeGeometryUpdater.prototype.constructor = PolylineVolumeGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume) {\n        return !defined(polylineVolume.positions) || !defined(polylineVolume.shape) || GeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isDynamic = function(entity, polylineVolume) {\n        return !polylineVolume.positions.isConstant || //\n               !polylineVolume.shape.isConstant || //\n               !Property.isConstant(polylineVolume.granularity) || //\n               !Property.isConstant(polylineVolume.outlineWidth) || //\n               !Property.isConstant(polylineVolume.cornerType);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._setStaticOptions = function(entity, polylineVolume) {\n        var granularity = polylineVolume.granularity;\n        var cornerType = polylineVolume.cornerType;\n\n        var options = this._options;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.polylinePositions = polylineVolume.positions.getValue(Iso8601.MINIMUM_VALUE, options.polylinePositions);\n        options.shapePositions = polylineVolume.shape.getValue(Iso8601.MINIMUM_VALUE, options.shape);\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n        options.cornerType = defined(cornerType) ? cornerType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    PolylineVolumeGeometryUpdater.DynamicGeometryUpdater = DynamicPolylineVolumeGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPolylineVolumeGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPolylineVolumeGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPolylineVolumeGeometryUpdater.prototype.constructor = DynamicPolylineVolumeGeometryUpdater;\n    }\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume, time) {\n        var options = this._options;\n        return !defined(options.polylinePositions) || !defined(options.shapePositions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume, time);\n    };\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._setOptions = function(entity, polylineVolume, time) {\n        var options = this._options;\n        options.polylinePositions = Property.getValueOrUndefined(polylineVolume.positions, time, options.polylinePositions);\n        options.shapePositions = Property.getValueOrUndefined(polylineVolume.shape, time);\n        options.granularity = Property.getValueOrUndefined(polylineVolume.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(polylineVolume.cornerType, time);\n    };\nexport default PolylineVolumeGeometryUpdater;\n","import arrayFill from './arrayFill.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian2 from './Cartesian2.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Cartographic from './Cartographic.js';\nimport Check from './Check.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport defineProperties from './defineProperties.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryInstance from './GeometryInstance.js';\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\nimport GeometryPipeline from './GeometryPipeline.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport Matrix2 from './Matrix2.js';\nimport Matrix3 from './Matrix3.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport Quaternion from './Quaternion.js';\nimport Rectangle from './Rectangle.js';\nimport RectangleGeometryLibrary from './RectangleGeometryLibrary.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var positionScratch = new Cartesian3();\n    var normalScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var bitangentScratch = new Cartesian3();\n    var rectangleScratch = new Rectangle();\n    var stScratch = new Cartesian2();\n    var bottomBoundingSphere = new BoundingSphere();\n    var topBoundingSphere = new BoundingSphere();\n\n    function createAttributes(vertexFormat, attributes) {\n        var geo = new Geometry({\n            attributes : new GeometryAttributes(),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        geo.attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : attributes.positions\n        });\n        if (vertexFormat.normal) {\n            geo.attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.normals\n            });\n        }\n        if (vertexFormat.tangent) {\n            geo.attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.tangents\n            });\n        }\n        if (vertexFormat.bitangent) {\n            geo.attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.bitangents\n            });\n        }\n        return geo;\n    }\n\n    function calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\n\n        var attrIndex = 0;\n        var bitangent = bitangentScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n            for (var i = 0; i < length; i += 3) {\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\n                var attrIndex1 = attrIndex + 1;\n                var attrIndex2 = attrIndex + 2;\n\n                normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                    Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n                    Cartesian3.normalize(tangent, tangent);\n\n                    if (vertexFormat.bitangent) {\n                        Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[attrIndex] = normal.x;\n                    normals[attrIndex1] = normal.y;\n                    normals[attrIndex2] = normal.z;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[attrIndex] = tangent.x;\n                    tangents[attrIndex1] = tangent.y;\n                    tangents[attrIndex2] = tangent.z;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[attrIndex] = bitangent.x;\n                    bitangents[attrIndex1] = bitangent.y;\n                    bitangents[attrIndex2] = bitangent.z;\n                }\n                attrIndex += 3;\n            }\n        }\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        });\n    }\n\n    var v1Scratch = new Cartesian3();\n    var v2Scratch = new Cartesian3();\n\n    function calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(length) : undefined;\n\n        var normalIndex = 0;\n        var tangentIndex = 0;\n        var bitangentIndex = 0;\n        var recomputeNormal = true;\n\n        var bitangent = bitangentScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n            for (var i = 0; i < length; i += 6) {\n                var p = Cartesian3.fromArray(positions, i, positionScratch);\n                var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n                if (recomputeNormal) {\n                    var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n                    Cartesian3.subtract(p1, p, p1);\n                    Cartesian3.subtract(p2, p, p2);\n                    normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) { // if we've reached a corner\n                    recomputeNormal = true;\n                }\n\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    bitangent = ellipsoid.geodeticSurfaceNormal(p, bitangent);\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                }\n            }\n        }\n\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        });\n    }\n\n    function constructRectangle(rectangleGeometry, computedOptions) {\n        var vertexFormat = rectangleGeometry._vertexFormat;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n        var northCap = computedOptions.northCap;\n        var southCap = computedOptions.southCap;\n\n        var rowStart = 0;\n        var rowEnd = height;\n        var rowHeight = height;\n        var size = 0;\n        if (northCap) {\n            rowStart = 1;\n            rowHeight -= 1;\n            size += 1;\n        }\n        if (southCap) {\n            rowEnd -= 1;\n            rowHeight -= 1;\n            size += 1;\n        }\n        size += (width * rowHeight);\n\n        var positions = (vertexFormat.position) ? new Float64Array(size * 3) : undefined;\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n\n        var posIndex = 0;\n        var stIndex = 0;\n\n        var position = positionScratch;\n        var st = stScratch;\n\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = -Number.MAX_VALUE;\n        var maxY = -Number.MAX_VALUE;\n\n        for (var row = rowStart; row < rowEnd; ++row) {\n            for (var col = 0; col < width; ++col) {\n                RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, row, col, position, st);\n\n                positions[posIndex++] = position.x;\n                positions[posIndex++] = position.y;\n                positions[posIndex++] = position.z;\n\n                if (vertexFormat.st) {\n                    textureCoordinates[stIndex++] = st.x;\n                    textureCoordinates[stIndex++] = st.y;\n\n                    minX = Math.min(minX, st.x);\n                    minY = Math.min(minY, st.y);\n                    maxX = Math.max(maxX, st.x);\n                    maxY = Math.max(maxY, st.y);\n                }\n            }\n        }\n        if (northCap) {\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, 0, 0, position, st);\n\n            positions[posIndex++] = position.x;\n            positions[posIndex++] = position.y;\n            positions[posIndex++] = position.z;\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = st.x;\n                textureCoordinates[stIndex++] = st.y;\n\n                minX = st.x;\n                minY = st.y;\n                maxX = st.x;\n                maxY = st.y;\n            }\n        }\n        if (southCap) {\n            RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, vertexFormat.st, height - 1, 0, position, st);\n\n            positions[posIndex++] = position.x;\n            positions[posIndex++] = position.y;\n            positions[posIndex] = position.z;\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = st.x;\n                textureCoordinates[stIndex] = st.y;\n\n                minX = Math.min(minX, st.x);\n                minY = Math.min(minY, st.y);\n                maxX = Math.max(maxX, st.x);\n                maxY = Math.max(maxY, st.y);\n            }\n        }\n\n        if (vertexFormat.st && (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)) {\n            for (var k = 0; k < textureCoordinates.length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);\n            }\n        }\n\n        var geo = calculateAttributes(positions, vertexFormat, ellipsoid, computedOptions.tangentRotationMatrix);\n\n        var indicesSize = 6 * (width - 1) * (rowHeight - 1);\n        if (northCap) {\n            indicesSize += 3 * (width - 1);\n        }\n        if (southCap) {\n            indicesSize += 3 * (width - 1);\n        }\n        var indices = IndexDatatype.createTypedArray(size, indicesSize);\n        var index = 0;\n        var indicesIndex = 0;\n        var i;\n        for (i = 0; i < rowHeight - 1; ++i) {\n            for (var j = 0; j < width - 1; ++j) {\n                var upperLeft = index;\n                var lowerLeft = upperLeft + width;\n                var lowerRight = lowerLeft + 1;\n                var upperRight = upperLeft + 1;\n                indices[indicesIndex++] = upperLeft;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = lowerRight;\n                ++index;\n            }\n            ++index;\n        }\n        if (northCap || southCap) {\n            var northIndex = size - 1;\n            var southIndex = size - 1;\n            if (northCap && southCap) {\n                northIndex = size - 2;\n            }\n\n            var p1;\n            var p2;\n            index = 0;\n\n            if (northCap) {\n                for (i = 0; i < width - 1; i++) {\n                    p1 = index;\n                    p2 = p1 + 1;\n                    indices[indicesIndex++] = northIndex;\n                    indices[indicesIndex++] = p1;\n                    indices[indicesIndex++] = p2;\n                    ++index;\n                }\n            }\n            if (southCap) {\n                index = (rowHeight - 1) * (width);\n                for (i = 0; i < width - 1; i++) {\n                    p1 = index;\n                    p2 = p1 + 1;\n                    indices[indicesIndex++] = p1;\n                    indices[indicesIndex++] = southIndex;\n                    indices[indicesIndex++] = p2;\n                    ++index;\n                }\n            }\n        }\n\n        geo.indices = indices;\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return geo;\n    }\n\n    function addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {\n        wallPositions[posIndex++] = topPositions[i];\n        wallPositions[posIndex++] = topPositions[i + 1];\n        wallPositions[posIndex++] = topPositions[i + 2];\n        wallPositions[posIndex++] = bottomPositions[i];\n        wallPositions[posIndex++] = bottomPositions[i + 1];\n        wallPositions[posIndex] = bottomPositions[i + 2];\n        return wallPositions;\n    }\n\n    function addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex++] = st[i + 1];\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex] = st[i + 1];\n        return wallTextures;\n    }\n\n    var scratchVertexFormat = new VertexFormat();\n\n    function constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n        var shadowVolume = rectangleGeometry._shadowVolume;\n        var offsetAttributeValue = rectangleGeometry._offsetAttribute;\n        var vertexFormat = rectangleGeometry._vertexFormat;\n        var minHeight = rectangleGeometry._extrudedHeight;\n        var maxHeight = rectangleGeometry._surfaceHeight;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n\n        var i;\n\n        if (shadowVolume) {\n            var newVertexFormat = VertexFormat.clone(vertexFormat, scratchVertexFormat);\n            newVertexFormat.normal = true;\n            rectangleGeometry._vertexFormat = newVertexFormat;\n        }\n\n        var topBottomGeo = constructRectangle(rectangleGeometry, computedOptions);\n\n        if (shadowVolume) {\n            rectangleGeometry._vertexFormat = vertexFormat;\n        }\n\n        var topPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, maxHeight, ellipsoid, false);\n        topPositions = new Float64Array(topPositions);\n        var length = topPositions.length;\n        var newLength = length * 2;\n        var positions = new Float64Array(newLength);\n        positions.set(topPositions);\n        var bottomPositions = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo.attributes.position.values, minHeight, ellipsoid);\n        positions.set(bottomPositions, length);\n        topBottomGeo.attributes.position.values = positions;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(newLength) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(newLength) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(newLength) : undefined;\n        var textures = (vertexFormat.st) ? new Float32Array(newLength / 3 * 2) : undefined;\n        var topSt;\n        var topNormals;\n        if (vertexFormat.normal) {\n            topNormals = topBottomGeo.attributes.normal.values;\n            normals.set(topNormals);\n            for (i = 0; i < length; i++) {\n                topNormals[i] = -topNormals[i];\n            }\n            normals.set(topNormals, length);\n            topBottomGeo.attributes.normal.values = normals;\n        }\n        if (shadowVolume) {\n            topNormals = topBottomGeo.attributes.normal.values;\n            if (!vertexFormat.normal) {\n                topBottomGeo.attributes.normal = undefined;\n            }\n            var extrudeNormals = new Float32Array(newLength);\n            for (i = 0; i < length; i++) {\n                topNormals[i] = -topNormals[i];\n            }\n            extrudeNormals.set(topNormals, length); //only get normals for bottom layer that's going to be pushed down\n            topBottomGeo.attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        var offsetValue;\n        var hasOffsets = defined(offsetAttributeValue);\n        if (hasOffsets) {\n            var size = length / 3 * 2;\n            var offsetAttribute = new Uint8Array(size);\n            if (offsetAttributeValue === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                offsetValue = offsetAttributeValue === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            topBottomGeo.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            var topTangents = topBottomGeo.attributes.tangent.values;\n            tangents.set(topTangents);\n            for (i = 0; i < length; i++) {\n                topTangents[i] = -topTangents[i];\n            }\n            tangents.set(topTangents, length);\n            topBottomGeo.attributes.tangent.values = tangents;\n        }\n        if (vertexFormat.bitangent) {\n            var topBitangents = topBottomGeo.attributes.bitangent.values;\n            bitangents.set(topBitangents);\n            bitangents.set(topBitangents, length);\n            topBottomGeo.attributes.bitangent.values = bitangents;\n        }\n        if (vertexFormat.st) {\n            topSt = topBottomGeo.attributes.st.values;\n            textures.set(topSt);\n            textures.set(topSt, length / 3 * 2);\n            topBottomGeo.attributes.st.values = textures;\n        }\n\n        var indices = topBottomGeo.indices;\n        var indicesLength = indices.length;\n        var posLength = length / 3;\n        var newIndices = IndexDatatype.createTypedArray(newLength / 3, indicesLength * 2);\n        newIndices.set(indices);\n        for (i = 0; i < indicesLength; i += 3) {\n            newIndices[i + indicesLength] = indices[i + 2] + posLength;\n            newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n            newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n        }\n        topBottomGeo.indices = newIndices;\n\n        var northCap = computedOptions.northCap;\n        var southCap = computedOptions.southCap;\n\n        var rowHeight = height;\n        var widthMultiplier = 2;\n        var perimeterPositions = 0;\n        var corners = 4;\n        var dupliateCorners = 4;\n        if (northCap) {\n            widthMultiplier -= 1;\n            rowHeight -= 1;\n            perimeterPositions += 1;\n            corners -= 2;\n            dupliateCorners -= 1;\n        }\n        if (southCap) {\n            widthMultiplier -= 1;\n            rowHeight -= 1;\n            perimeterPositions += 1;\n            corners -= 2;\n            dupliateCorners -= 1;\n        }\n        perimeterPositions += (widthMultiplier * width + 2 * rowHeight - corners);\n\n        var wallCount = (perimeterPositions + dupliateCorners) * 2;\n\n        var wallPositions = new Float64Array(wallCount * 3);\n        var wallExtrudeNormals = shadowVolume ? new Float32Array(wallCount * 3) : undefined;\n        var wallOffsetAttribute = hasOffsets ? new Uint8Array(wallCount) : undefined;\n        var wallTextures = (vertexFormat.st) ? new Float32Array(wallCount * 2) : undefined;\n\n        var computeTopOffsets = offsetAttributeValue === GeometryOffsetAttribute.TOP;\n        if (hasOffsets && !computeTopOffsets) {\n            offsetValue = offsetAttributeValue === GeometryOffsetAttribute.ALL ? 1 : 0;\n            wallOffsetAttribute = arrayFill(wallOffsetAttribute, offsetValue);\n        }\n\n        var posIndex = 0;\n        var stIndex = 0;\n        var extrudeNormalIndex = 0;\n        var wallOffsetIndex = 0;\n        var area = width * rowHeight;\n        var threeI;\n        for (i = 0; i < area; i += width) {\n            threeI = i * 3;\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                stIndex += 4;\n            }\n            if (shadowVolume) {\n                extrudeNormalIndex += 3;\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n            }\n            if (computeTopOffsets) {\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\n                wallOffsetIndex += 1;\n            }\n        }\n\n        if (!southCap) {\n            for (i = area - width; i < area; i++) {\n                threeI = i * 3;\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        } else {\n            var southIndex = northCap ? area + 1 : area;\n            threeI = southIndex * 3;\n\n            for (i = 0; i < 2; i++) { // duplicate corner points\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, southIndex * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        }\n\n        for (i = area - 1; i > 0; i -= width) {\n            threeI = i * 3;\n            wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                stIndex += 4;\n            }\n            if (shadowVolume) {\n                extrudeNormalIndex += 3;\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n            }\n            if (computeTopOffsets) {\n                wallOffsetAttribute[wallOffsetIndex++] = 1;\n                wallOffsetIndex += 1;\n            }\n\n        }\n\n        if (!northCap) {\n            for (i = width - 1; i >= 0; i--) {\n                threeI = i * 3;\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        } else {\n            var northIndex = area;\n            threeI = northIndex * 3;\n\n            for (i = 0; i < 2; i++) { // duplicate corner points\n                wallPositions = addWallPositions(wallPositions, posIndex, threeI, topPositions, bottomPositions);\n                posIndex += 6;\n                if (vertexFormat.st) {\n                    wallTextures = addWallTextureCoordinates(wallTextures, stIndex, northIndex * 2, topSt);\n                    stIndex += 4;\n                }\n                if (shadowVolume) {\n                    extrudeNormalIndex += 3;\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 1];\n                    wallExtrudeNormals[extrudeNormalIndex++] = topNormals[threeI + 2];\n                }\n                if (computeTopOffsets) {\n                    wallOffsetAttribute[wallOffsetIndex++] = 1;\n                    wallOffsetIndex += 1;\n                }\n            }\n        }\n\n        var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : wallTextures\n            });\n        }\n        if (shadowVolume) {\n            geo.attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : wallExtrudeNormals\n            });\n        }\n        if (hasOffsets) {\n            geo.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : wallOffsetAttribute\n            });\n        }\n\n        var wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);\n\n        var upperLeft;\n        var lowerLeft;\n        var lowerRight;\n        var upperRight;\n        length = wallPositions.length / 3;\n        var index = 0;\n        for (i = 0; i < length - 1; i += 2) {\n            upperLeft = i;\n            upperRight = (upperLeft + 2) % length;\n            var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n            var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n            if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            lowerLeft = (upperLeft + 1) % length;\n            lowerRight = (lowerLeft + 2) % length;\n            wallIndices[index++] = upperLeft;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = lowerRight;\n        }\n\n        geo.indices = wallIndices;\n\n        geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : geo\n            })\n        ]);\n\n        return geo[0];\n    }\n\n    var scratchRectanglePoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n    var nwScratch = new Cartographic();\n    var stNwScratch = new Cartographic();\n    function computeRectangle(rectangle, granularity, rotation, ellipsoid, result) {\n        if (rotation === 0.0) {\n            return Rectangle.clone(rectangle, result);\n        }\n\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);\n\n        var height = computedOptions.height;\n        var width = computedOptions.width;\n\n        var positions = scratchRectanglePoints;\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, positions[0]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, width - 1, positions[1]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, 0, positions[2]);\n        RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, height - 1, width - 1, positions[3]);\n\n        return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n    }\n\n    /**\n     * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias RectangleGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n     *\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n     *\n     * @see RectangleGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n     *\n     * @example\n     * // 1. create a rectangle\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     *\n     * // 2. create an extruded rectangle without a top\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0,\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     */\n    function RectangleGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var rectangle = options.rectangle;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._rectangle = Rectangle.clone(rectangle);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._surfaceHeight = Math.max(height, extrudedHeight);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createRectangleGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._rotatedRectangle = undefined;\n\n        this._textureCoordinateRotationPoints = undefined;\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    RectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {RectangleGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    RectangleGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Rectangle.pack(value._rectangle, array, startingIndex);\n        startingIndex += Rectangle.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._surfaceHeight;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchRectangle = new Rectangle();\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        rectangle : scratchRectangle,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined,\n        height : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        extrudedHeight : undefined,\n        shadowVolume : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {RectangleGeometry} [result] The object into which to store the result.\n     * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n     */\n    RectangleGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n        startingIndex += Rectangle.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex++];\n        var surfaceHeight = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.granularity = granularity;\n            scratchOptions.height = surfaceHeight;\n            scratchOptions.rotation = rotation;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new RectangleGeometry(scratchOptions);\n        }\n\n        result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n        result._surfaceHeight = surfaceHeight;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._extrudedHeight = extrudedHeight;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle based on the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    RectangleGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var rectangle = options.rectangle;\n\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var rotation = defaultValue(options.rotation, 0.0);\n\n        return computeRectangle(rectangle, granularity, rotation, ellipsoid, result);\n    };\n\n    var tangentRotationMatrixScratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n    var centerScratch = new Cartographic();\n    /**\n     * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     *\n     * @exception {DeveloperError} Rotated rectangle is invalid.\n     */\n    RectangleGeometry.createGeometry = function(rectangleGeometry) {\n        if ((CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.north, rectangleGeometry._rectangle.south, CesiumMath.EPSILON10) ||\n             (CesiumMath.equalsEpsilon(rectangleGeometry._rectangle.east, rectangleGeometry._rectangle.west, CesiumMath.EPSILON10)))) {\n            return undefined;\n        }\n\n        var rectangle = rectangleGeometry._rectangle;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n        var rotation = rectangleGeometry._rotation;\n        var stRotation = rectangleGeometry._stRotation;\n        var vertexFormat = rectangleGeometry._vertexFormat;\n\n        var computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rotation, stRotation, rectangleScratch, nwScratch, stNwScratch);\n\n        var tangentRotationMatrix = tangentRotationMatrixScratch;\n        if (stRotation !== 0 || rotation !== 0) {\n            var center = Rectangle.center(rectangle, centerScratch);\n            var axis = ellipsoid.geodeticSurfaceNormalCartographic(center, v1Scratch);\n            Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n            Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n        } else {\n            Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n        }\n\n        var surfaceHeight = rectangleGeometry._surfaceHeight;\n        var extrudedHeight = rectangleGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        computedOptions.lonScalar = 1.0 / rectangleGeometry._rectangle.width;\n        computedOptions.latScalar = 1.0 / rectangleGeometry._rectangle.height;\n        computedOptions.tangentRotationMatrix = tangentRotationMatrix;\n\n        var geometry;\n        var boundingSphere;\n        rectangle = rectangleGeometry._rectangle;\n        if (extrude) {\n            geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n            var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n            var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n            boundingSphere = BoundingSphere.union(topBS, bottomBS);\n        } else {\n            geometry = constructRectangle(rectangleGeometry, computedOptions);\n            geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\n\n            if (defined(rectangleGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n\n            boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n        }\n\n        if (!vertexFormat.position) {\n            delete geometry.attributes.position;\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : rectangleGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    RectangleGeometry.createShadowVolume = function(rectangleGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = rectangleGeometry._granularity;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new RectangleGeometry({\n            rectangle : rectangleGeometry._rectangle,\n            rotation : rectangleGeometry._rotation,\n            ellipsoid : ellipsoid,\n            stRotation : rectangleGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : maxHeight,\n            height : minHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume : true\n        });\n    };\n\n    var unrotatedTextureRectangleScratch = new Rectangle();\n    var points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\n    var rotation2DScratch = new Matrix2();\n    var rectangleCenterScratch = new Cartographic();\n\n    function textureCoordinateRotationPoints(rectangleGeometry) {\n        if (rectangleGeometry._stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n\n        var rectangle = Rectangle.clone(rectangleGeometry._rectangle, unrotatedTextureRectangleScratch);\n        var granularity = rectangleGeometry._granularity;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        // Rotate to align the texture coordinates with ENU\n        var rotation = rectangleGeometry._rotation - rectangleGeometry._stRotation;\n\n        var unrotatedTextureRectangle = computeRectangle(rectangle, granularity, rotation, ellipsoid, unrotatedTextureRectangleScratch);\n\n        // Assume a computed \"east-north\" texture coordinate system based on spherical or planar tricks, bounded by `boundingRectangle`.\n        // The \"desired\" texture coordinate system forms an oriented rectangle (un-oriented computed) around the geometry that completely and tightly bounds it.\n        // We want to map from the \"east-north\" texture coordinate system into the \"desired\" system using a pair of lines (analagous planes in 2D)\n        // Compute 3 corners of the \"desired\" texture coordinate system in \"east-north\" texture space by the following in cartographic space:\n        // - rotate 3 of the corners in unrotatedTextureRectangle by stRotation around the center of the bounding rectangle\n        // - apply the \"east-north\" system's normalization formula to the rotated cartographics, even though this is likely to produce values outside [0-1].\n        // This gives us a set of points in the \"east-north\" texture coordinate system that can be used to map \"east-north\" texture coordinates to \"desired.\"\n\n        var points2D = points2DScratch;\n        points2D[0].x = unrotatedTextureRectangle.west;\n        points2D[0].y = unrotatedTextureRectangle.south;\n\n        points2D[1].x = unrotatedTextureRectangle.west;\n        points2D[1].y = unrotatedTextureRectangle.north;\n\n        points2D[2].x = unrotatedTextureRectangle.east;\n        points2D[2].y = unrotatedTextureRectangle.south;\n\n        var boundingRectangle = rectangleGeometry.rectangle;\n        var toDesiredInComputed = Matrix2.fromRotation(rectangleGeometry._stRotation, rotation2DScratch);\n        var boundingRectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\n\n        for (var i = 0; i < 3; ++i) {\n            var point2D = points2D[i];\n            point2D.x -= boundingRectangleCenter.longitude;\n            point2D.y -= boundingRectangleCenter.latitude;\n            Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n            point2D.x += boundingRectangleCenter.longitude;\n            point2D.y += boundingRectangleCenter.latitude;\n\n            // Convert point into east-north texture coordinate space\n            point2D.x = (point2D.x - boundingRectangle.west) / boundingRectangle.width;\n            point2D.y = (point2D.y - boundingRectangle.south) / boundingRectangle.height;\n        }\n\n        var minXYCorner = points2D[0];\n        var maxYCorner = points2D[1];\n        var maxXCorner = points2D[2];\n        var result = new Array(6);\n        Cartesian2.pack(minXYCorner, result);\n        Cartesian2.pack(maxYCorner, result, 2);\n        Cartesian2.pack(maxXCorner, result, 4);\n        return result;\n    }\n\n    defineProperties(RectangleGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rotatedRectangle)) {\n                    this._rotatedRectangle = computeRectangle(this._rectangle, this._granularity, this._rotation, this._ellipsoid);\n                }\n                return this._rotatedRectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering RectangleGeometries as GroundPrimitives.\n         * This version permits skew in textures by computing offsets directly in cartographic space and\n         * more accurately approximates rendering RectangleGeometries with height as standard Primitives.\n         * @see Geometry#_textureCoordinateRotationPoints\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\nexport default RectangleGeometry;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Cartographic from '../Core/Cartographic.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport Ellipsoid from '../Core/Ellipsoid.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport Rectangle from '../Core/Rectangle.js';\nimport RectangleGeometry from '../Core/RectangleGeometry.js';\nimport RectangleOutlineGeometry from '../Core/RectangleOutlineGeometry.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport GroundGeometryUpdater from './GroundGeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratchCenterRect = new Rectangle();\n    var scratchCarto = new Cartographic();\n\n    function RectangleGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.rectangle = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.rotation = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for rectangles.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias RectangleGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function RectangleGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new RectangleGeometryOptions(entity),\n            geometryPropertyName : 'rectangle',\n            observedPropertyNames : ['availability', 'rectangle']\n        });\n\n        this._onEntityPropertyChanged(entity, 'rectangle', entity.rectangle, undefined);\n    }\n\n    if (defined(Object.create)) {\n        RectangleGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        RectangleGeometryUpdater.prototype.constructor = RectangleGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    RectangleGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    RectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    RectangleGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var rect = Property.getValueOrUndefined(this._entity.rectangle.coordinates, time, scratchCenterRect);\n        if (!defined(rect)) {\n            return;\n        }\n        var center = Rectangle.center(rect, scratchCarto);\n        return Cartographic.toCartesian(center, Ellipsoid.WGS84, result);\n    };\n\n    RectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle) {\n        return !defined(rectangle.coordinates) || GeometryUpdater.prototype._isHidden.call(this, entity, rectangle);\n    };\n\n    RectangleGeometryUpdater.prototype._isDynamic = function(entity, rectangle) {\n        return !rectangle.coordinates.isConstant || //\n               !Property.isConstant(rectangle.height) || //\n               !Property.isConstant(rectangle.extrudedHeight) || //\n               !Property.isConstant(rectangle.granularity) || //\n               !Property.isConstant(rectangle.stRotation) || //\n               !Property.isConstant(rectangle.rotation) || //\n               !Property.isConstant(rectangle.outlineWidth) || //\n               !Property.isConstant(rectangle.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    RectangleGeometryUpdater.prototype._setStaticOptions = function(entity, rectangle) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var heightValue = Property.getValueOrUndefined(rectangle.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.rectangle = rectangle.coordinates.getValue(Iso8601.MINIMUM_VALUE, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, Iso8601.MINIMUM_VALUE);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    RectangleGeometryUpdater.DynamicGeometryUpdater = DynamicRectangleGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicRectangleGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicRectangleGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicRectangleGeometryUpdater.prototype.constructor = DynamicRectangleGeometryUpdater;\n    }\n\n    DynamicRectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle, time) {\n        return  !defined(this._options.rectangle) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, rectangle, time);\n    };\n\n    DynamicRectangleGeometryUpdater.prototype._setOptions = function(entity, rectangle, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(rectangle.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.rectangle = Property.getValueOrUndefined(rectangle.coordinates, time, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\nexport default RectangleGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, appearanceType, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.translucent = translucent;\n        this.appearanceType = appearanceType;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.depthFailMaterial = undefined;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.invalidated = false;\n\n        var removeMaterialSubscription;\n        if (defined(depthFailMaterialProperty)) {\n            removeMaterialSubscription = depthFailMaterialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        }\n        this.removeMaterialSubscription = removeMaterialSubscription;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.depthFailMaterialProperty;\n        var updaterMaterial = updater.depthFailMaterialProperty;\n        if (updaterMaterial === material) {\n            return true;\n        }\n        if (defined(material)) {\n            return material.equals(updaterMaterial);\n        }\n        return false;\n    };\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                var depthFailAppearance;\n                if (defined(this.depthFailAppearanceType)) {\n                    if (defined(this.depthFailMaterialProperty)) {\n                        this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    }\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.translucent,\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        translucent : this.translucent,\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                if (defined(this.depthFailAppearanceType) && updater.depthFailMaterialProperty instanceof ColorMaterialProperty && (!updater.depthFailMaterialProperty.isConstant || waitingOnCreate)) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        if (defined(this.removeMaterialSubscription)) {\n            this.removeMaterialSubscription();\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryColorBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._solidItems = [];\n        this._translucentItems = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryColorBatch.prototype.add = function(time, updater) {\n        var items;\n        var translucent;\n        var instance = updater.createFillGeometryInstance(time);\n        if (instance.attributes.color.value[3] === 255) {\n            items = this._solidItems;\n            translucent = false;\n        } else {\n            items = this._translucentItems;\n            translucent = true;\n        }\n\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(updater, instance);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, translucent, this._appearanceType, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(updater, instance);\n        items.push(batch);\n    };\n\n    function removeItem(items, updater) {\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    StaticGeometryColorBatch.prototype.remove = function(updater) {\n        if (!removeItem(this._solidItems, updater)) {\n            removeItem(this._translucentItems, updater);\n        }\n    };\n\n    function moveItems(batch, items, time) {\n        var itemsMoved = false;\n        var length = items.length;\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            var itemsToRemove = item.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            if (itemsToMoveLength > 0) {\n                for (i = 0; i < itemsToMoveLength; i++) {\n                    var updater = itemsToRemove[i];\n                    item.remove(updater);\n                    batch.add(time, updater);\n                    itemsMoved = true;\n                }\n            }\n        }\n        return itemsMoved;\n    }\n\n    function updateItems(batch, items, time, isUpdated) {\n        var length = items.length;\n        var i;\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    batch.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        length = items.length;\n        for (i = 0; i < length; ++i) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    }\n\n    StaticGeometryColorBatch.prototype.update = function(time) {\n        //Perform initial update\n        var isUpdated = updateItems(this, this._solidItems, time, true);\n        isUpdated = updateItems(this, this._translucentItems, time, isUpdated) && isUpdated;\n\n        //If any items swapped between solid/translucent, we need to\n        //move them between batches\n        var solidsMoved = moveItems(this, this._solidItems, time);\n        var translucentsMoved = moveItems(this, this._translucentItems, time);\n\n        //If we moved anything around, we need to re-build the primitive\n        if (solidsMoved || translucentsMoved) {\n            isUpdated = updateItems(this, this._solidItems, time, isUpdated) && isUpdated;\n            isUpdated = updateItems(this, this._translucentItems, time, isUpdated)&& isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    function getBoundingSphere(items, updater, result) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    }\n\n    StaticGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var boundingSphere = getBoundingSphere(this._solidItems, updater, result);\n        if (boundingSphere === BoundingSphereState.FAILED) {\n            return getBoundingSphere(this._translucentItems, updater, result);\n        }\n        return boundingSphere;\n    };\n\n    function removeAllPrimitives(items) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        items.length = 0;\n    }\n\n    StaticGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        removeAllPrimitives(this._solidItems);\n        removeAllPrimitives(this._translucentItems);\n    };\nexport default StaticGeometryColorBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, appearanceType, materialProperty, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.primitives = primitives;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.depthFailMaterial = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n        var depthFailMaterial = this.depthFailMaterialProperty;\n        var updaterDepthFailMaterial = updater.depthFailMaterialProperty;\n\n        if (updaterMaterial === material && updaterDepthFailMaterial === depthFailMaterial) {\n            return true;\n        }\n        var equals = defined(material) && material.equals(updaterMaterial);\n        equals = ((!defined(depthFailMaterial) && !defined(updaterDepthFailMaterial)) || (defined(depthFailMaterial) && depthFailMaterial.equals(updaterDepthFailMaterial))) && equals;\n        return equals;\n    };\n\n    Batch.prototype.add = function(time, updater) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, updater.createFillGeometryInstance(time));\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)  || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var colorScratch = new Color();\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                var depthFailAppearance;\n                if (defined(this.depthFailMaterialProperty)) {\n                    this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.depthFailMaterial.isTranslucent(),\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        material : this.material,\n                        translucent : this.material.isTranslucent(),\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (defined(this.depthFailAppearanceType) && this.depthFailMaterialProperty instanceof ColorMaterialProperty && !updater.depthFailMaterialProperty.isConstant) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthFailColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthFailColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthFailColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthFailColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryPerMaterialBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._items = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(time, updater);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, this._appearanceType, updater.fillMaterialProperty, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(time, updater);\n        items.push(batch);\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGeometryPerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    function Batch(primitives, classificationType, color, key, zIndex) {\n        this.primitives = primitives;\n        this.zIndex = zIndex;\n        this.classificationType = classificationType;\n        this.color = color;\n        this.key = key;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.isDirty = false;\n    }\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var scratchArray = new Array(4);\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    classificationType : this.classificationType\n                });\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var fillColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n\n                    if (!Color.equals(attributes._lastColor, fillColor)) {\n                        attributes._lastColor = Color.clone(fillColor, attributes._lastColor);\n                        var color = this.color;\n                        var newColor = fillColor.toBytes(scratchArray);\n                        if (color[0] !== newColor[0] || color[1] !== newColor[1] ||\n                            color[2] !== newColor[2] || color[3] !== newColor[3]) {\n                           this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var bs = primitive.getBoundingSphere(updater.entity);\n        if (!defined(bs)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        bs.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryColorBatch(primitives, classificationType) {\n        this._batches = new AssociativeArray();\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n    }\n\n    StaticGroundGeometryColorBatch.prototype.add = function(time, updater) {\n        var instance = updater.createFillGeometryInstance(time);\n        var batches = this._batches;\n        // color and zIndex are batch breakers, so we'll use that for the key\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        var batchKey = new Uint32Array(instance.attributes.color.value.buffer)[0] + ':' + zIndex;\n        var batch;\n        if (batches.contains(batchKey)) {\n            batch = batches.get(batchKey);\n        } else {\n            batch = new Batch(this._primitives, this._classificationType, instance.attributes.color.value, batchKey, zIndex);\n            batches.set(batchKey, batch);\n        }\n        batch.add(updater, instance);\n        return batch;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.remove = function(updater) {\n        var batchesArray = this._batches.values;\n        var count = batchesArray.length;\n        for (var i = 0; i < count; ++i) {\n            if (batchesArray[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticGroundGeometryColorBatch.prototype.update = function(time) {\n        var i;\n        var updater;\n\n        //Perform initial update\n        var isUpdated = true;\n        var batches = this._batches;\n        var batchesArray = batches.values;\n        var batchCount = batchesArray.length;\n        for (i = 0; i < batchCount; ++i) {\n            isUpdated = batchesArray[i].update(time) && isUpdated;\n        }\n\n        //If any items swapped between batches we need to move them\n        for (i = 0; i < batchCount; ++i) {\n            var oldBatch = batchesArray[i];\n            var itemsToRemove = oldBatch.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            for (var j = 0; j < itemsToMoveLength; j++) {\n                updater = itemsToRemove[j];\n                oldBatch.remove(updater);\n                var newBatch = this.add(time, updater);\n                oldBatch.isDirty = true;\n                newBatch.isDirty = true;\n            }\n        }\n\n        //If we moved anything around, we need to re-build the primitive and remove empty batches\n        var batchesArrayCopy = batchesArray.slice();\n        var batchesCopyCount = batchesArrayCopy.length;\n        for (i = 0; i < batchesCopyCount; ++i) {\n            var batch = batchesArrayCopy[i];\n            if (batch.isDirty) {\n                isUpdated = batchesArrayCopy[i].update(time) && isUpdated;\n                batch.isDirty = false;\n            }\n            if (batch.geometry.length === 0) {\n                batches.remove(batch.key);\n            }\n        }\n\n        return isUpdated;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            var batch = batchesArray[i];\n            if (batch.contains(updater)) {\n                return batch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            batchesArray[i].removeAllPrimitives();\n        }\n    };\nexport default StaticGroundGeometryColorBatch;\n","\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n};\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect.js';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","import rbush from '../ThirdParty/rbush.js';\nimport Check from './Check.js';\n\n    /**\n     * Wrapper around rbush for use with Rectangle types.\n     * @private\n     */\n    function RectangleCollisionChecker() {\n        this._tree = rbush();\n    }\n\n    function RectangleWithId() {\n        this.minX = 0.0;\n        this.minY = 0.0;\n        this.maxX = 0.0;\n        this.maxY = 0.0;\n        this.id = '';\n    }\n\n    RectangleWithId.fromRectangleAndId = function(id, rectangle, result) {\n        result.minX = rectangle.west;\n        result.minY = rectangle.south;\n        result.maxX = rectangle.east;\n        result.maxY = rectangle.north;\n        result.id = id;\n        return result;\n    };\n\n    /**\n     * Insert a rectangle into the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being inserted.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.insert = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, new RectangleWithId());\n        this._tree.insert(withId);\n    };\n\n    function idCompare(a, b) {\n        return a.id === b.id;\n    }\n\n    var removalScratch = new RectangleWithId();\n    /**\n     * Remove a rectangle from the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being removed.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.remove = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, removalScratch);\n        this._tree.remove(withId, idCompare);\n    };\n\n    var collisionScratch = new RectangleWithId();\n    /**\n     * Checks if a given rectangle collides with any of the rectangles in the collection.\n     *\n     * @param {Rectangle} rectangle A Rectangle that should be checked against the rectangles in the collision checker.\n     * @returns {Boolean} Whether the rectangle collides with any of the rectangles in the collision checker.\n     */\n    RectangleCollisionChecker.prototype.collides = function(rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId('', rectangle, collisionScratch);\n        return this._tree.collides(withId);\n    };\nexport default RectangleCollisionChecker;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport RectangleCollisionChecker from '../Core/RectangleCollisionChecker.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport ShadowVolumeAppearance from '../Scene/ShadowVolumeAppearance.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(primitives, classificationType, appearanceType, materialProperty, usingSphericalTextureCoordinates, zIndex) {\n        this.primitives = primitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n        this.zIndex = zIndex;\n        this.rectangleCollisionCheck = new RectangleCollisionChecker();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.overlapping = function(rectangle) {\n        return this.rectangleCollisionCheck.collides(rectangle);\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var geometryInstance = this.geometry.get(id);\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        material : this.material\n                        // translucent and closed properties overridden\n                    }),\n                    classificationType : this.classificationType\n                });\n\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryPerMaterialBatch(primitives, classificationType, appearanceType) {\n        this._items = [];\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n        this._appearanceType = appearanceType;\n    }\n\n    StaticGroundGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(geometryInstance.geometry.rectangle);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n        // * compatible material (same material or same color)\n        // * same type of texture coordinates (spherical vs. planar)\n        // * conservatively non-overlapping with any entities in the existing batch\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.usingSphericalTextureCoordinates === usingSphericalTextureCoordinates &&\n                item.zIndex === zIndex &&\n                !item.overlapping(geometryInstance.geometry.rectangle)) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._primitives, this._classificationType, this._appearanceType, updater.fillMaterialProperty, usingSphericalTextureCoordinates, zIndex);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGroundGeometryPerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport OffsetGeometryInstanceAttribute from '../Core/OffsetGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport Primitive from '../Scene/Primitive.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, width, shadows) {\n        this.translucent = translucent;\n        this.width = width;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantOutline || !updater.outlineColorProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new PerInstanceColorAppearance({\n                        flat : true,\n                        translucent : this.translucent,\n                        renderState : {\n                            lineWidth : this.width\n                        }\n                    }),\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.outlineColorProperty.isConstant || waitingOnCreate) {\n                    var outlineColorProperty = updater.outlineColorProperty;\n                    var outlineColor = Property.getValueOrDefault(outlineColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, outlineColor)) {\n                        attributes._lastColor = Color.clone(outlineColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantOutline || updater.isOutlineVisible(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticOutlineGeometryBatch(primitives, scene, shadows) {\n        this._primitives = primitives;\n        this._scene = scene;\n        this._shadows = shadows;\n        this._solidBatches = new AssociativeArray();\n        this._translucentBatches = new AssociativeArray();\n    }\n    StaticOutlineGeometryBatch.prototype.add = function(time, updater) {\n        var instance = updater.createOutlineGeometryInstance(time);\n        var width = this._scene.clampLineWidth(updater.outlineWidth);\n        var batches;\n        var batch;\n        if (instance.attributes.color.value[3] === 255) {\n            batches = this._solidBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, false, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        } else {\n            batches = this._translucentBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, true, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.remove = function(updater) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            if (solidBatches[i].remove(updater)) {\n                return;\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            if (translucentBatches[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.update = function(time) {\n        var i;\n        var x;\n        var updater;\n        var batch;\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        var itemsToRemove;\n        var isUpdated = true;\n        var needUpdate = false;\n\n        do {\n            needUpdate = false;\n            for (x = 0; x < solidBatchesLength; x++) {\n                batch = solidBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var solidsToMoveLength = itemsToRemove.length;\n                if (solidsToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < solidsToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n            for (x = 0; x < translucentBatchesLength; x++) {\n                batch = translucentBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var translucentToMoveLength = itemsToRemove.length;\n                if (translucentToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < translucentToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n        } while (needUpdate);\n\n        return isUpdated;\n    };\n\n    StaticOutlineGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            var solidBatch = solidBatches[i];\n            if (solidBatch.contains(updater)){\n                return solidBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            var translucentBatch = translucentBatches[i];\n            if (translucentBatch.contains(updater)){\n                return translucentBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticOutlineGeometryBatch.prototype.removeAllPrimitives = function() {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            solidBatches[i].removeAllPrimitives();\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            translucentBatches[i].removeAllPrimitives();\n        }\n    };\nexport default StaticOutlineGeometryBatch;\n","import Cartographic from './Cartographic.js';\nimport defined from './defined.js';\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\nimport CesiumMath from './Math.js';\nimport PolygonPipeline from './PolygonPipeline.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport WindingOrder from './WindingOrder.js';\n\n    /**\n     * private\n     */\n    var WallGeometryLibrary = {};\n\n    function latLonEquals(c0, c1) {\n        return ((CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14)) && (CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14)));\n    }\n\n    var scratchCartographic1 = new Cartographic();\n    var scratchCartographic2 = new Cartographic();\n    function removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n        var length = positions.length;\n        if (length < 2) {\n            return;\n        }\n\n        var hasBottomHeights = defined(bottomHeights);\n        var hasTopHeights = defined(topHeights);\n        var hasAllZeroHeights = true;\n\n        var cleanedPositions = new Array(length);\n        var cleanedTopHeights = new Array(length);\n        var cleanedBottomHeights = new Array(length);\n\n        var v0 = positions[0];\n        cleanedPositions[0] = v0;\n\n        var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n        if (hasTopHeights) {\n            c0.height = topHeights[0];\n        }\n\n        hasAllZeroHeights = hasAllZeroHeights && c0.height <= 0;\n\n        cleanedTopHeights[0] = c0.height;\n\n        if (hasBottomHeights) {\n            cleanedBottomHeights[0] = bottomHeights[0];\n        } else {\n            cleanedBottomHeights[0] = 0.0;\n        }\n\n        var index = 1;\n        for (var i = 1; i < length; ++i) {\n            var v1 = positions[i];\n            var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n            if (hasTopHeights) {\n                c1.height = topHeights[i];\n            }\n            hasAllZeroHeights = hasAllZeroHeights && c1.height <= 0;\n\n            if (!latLonEquals(c0, c1)) {\n                cleanedPositions[index] = v1; // Shallow copy!\n                cleanedTopHeights[index] = c1.height;\n\n                if (hasBottomHeights) {\n                    cleanedBottomHeights[index] = bottomHeights[i];\n                } else {\n                    cleanedBottomHeights[index] = 0.0;\n                }\n\n                Cartographic.clone(c1, c0);\n                ++index;\n            } else if (c0.height < c1.height) {\n                cleanedTopHeights[index - 1] = c1.height;\n            }\n        }\n\n        if (hasAllZeroHeights || index < 2) {\n            return;\n        }\n\n        cleanedPositions.length = index;\n        cleanedTopHeights.length = index;\n        cleanedBottomHeights.length = index;\n\n        return {\n            positions: cleanedPositions,\n            topHeights: cleanedTopHeights,\n            bottomHeights: cleanedBottomHeights\n        };\n    }\n\n    var positionsArrayScratch = new Array(2);\n    var heightsArrayScratch = new Array(2);\n    var generateArcOptionsScratch = {\n        positions : undefined,\n        height : undefined,\n        granularity : undefined,\n        ellipsoid : undefined\n    };\n\n    /**\n     * @private\n     */\n    WallGeometryLibrary.computePositions = function(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {\n        var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);\n\n        if (!defined(o)) {\n            return;\n        }\n\n        wallPositions = o.positions;\n        maximumHeights = o.topHeights;\n        minimumHeights = o.bottomHeights;\n\n        if (wallPositions.length >= 3) {\n            // Order positions counter-clockwise\n            var tangentPlane = EllipsoidTangentPlane.fromPoints(wallPositions, ellipsoid);\n            var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);\n\n            if (PolygonPipeline.computeWindingOrder2D(positions2D) === WindingOrder.CLOCKWISE) {\n                wallPositions.reverse();\n                maximumHeights.reverse();\n                minimumHeights.reverse();\n            }\n        }\n\n        var length = wallPositions.length;\n        var numCorners = length - 2;\n        var topPositions;\n        var bottomPositions;\n\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var generateArcOptions = generateArcOptionsScratch;\n        generateArcOptions.minDistance = minDistance;\n        generateArcOptions.ellipsoid = ellipsoid;\n\n        if (duplicateCorners) {\n            var count = 0;\n            var i;\n\n            for (i = 0; i < length - 1; i++) {\n                count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i+1], minDistance) + 1;\n            }\n\n            topPositions = new Float64Array(count * 3);\n            bottomPositions = new Float64Array(count * 3);\n\n            var generateArcPositions = positionsArrayScratch;\n            var generateArcHeights = heightsArrayScratch;\n            generateArcOptions.positions = generateArcPositions;\n            generateArcOptions.height = generateArcHeights;\n\n            var offset = 0;\n            for (i = 0; i < length - 1; i++) {\n                generateArcPositions[0] = wallPositions[i];\n                generateArcPositions[1] = wallPositions[i + 1];\n\n                generateArcHeights[0] = maximumHeights[i];\n                generateArcHeights[1] = maximumHeights[i + 1];\n\n                var pos = PolylinePipeline.generateArc(generateArcOptions);\n                topPositions.set(pos, offset);\n\n                generateArcHeights[0] = minimumHeights[i];\n                generateArcHeights[1] = minimumHeights[i + 1];\n\n                bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);\n\n                offset += pos.length;\n            }\n        } else {\n            generateArcOptions.positions = wallPositions;\n            generateArcOptions.height = maximumHeights;\n            topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n\n            generateArcOptions.height = minimumHeights;\n            bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n        }\n\n        return {\n            bottomPositions: bottomPositions,\n            topPositions: topPositions,\n            numCorners: numCorners\n        };\n    };\nexport default WallGeometryLibrary;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n    var scratchCartesian3Position3 = new Cartesian3();\n    var scratchCartesian3Position4 = new Cartesian3();\n    var scratchCartesian3Position5 = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\n     *\n     * @example\n     * // create a wall that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     */\n    function WallGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex] = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallGeometry} [result] The object into which to store the result.\n     * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\n     */\n    WallGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @returns {WallGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     *\n     * @see WallGeometry#createGeometry\n     */\n    WallGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid,\n            vertexFormat : options.vertexFormat\n        };\n        return new WallGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallGeometry} wallGeometry A description of the wall.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var vertexFormat = wallGeometry._vertexFormat;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n        var numCorners = pos.numCorners;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = vertexFormat.position ? new Float64Array(size) : undefined;\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var recomputeNormal = true;\n        length /= 3;\n        var i;\n        var s = 0;\n        var ds = 1/(length - wallPositions.length + 1);\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n            if (vertexFormat.position) {\n                // insert the lower point\n                positions[positionIndex++] = bottomPosition.x;\n                positions[positionIndex++] = bottomPosition.y;\n                positions[positionIndex++] = bottomPosition.z;\n\n                // insert the upper point\n                positions[positionIndex++] = topPosition.x;\n                positions[positionIndex++] = topPosition.y;\n                positions[positionIndex++] = topPosition.z;\n            }\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 0.0;\n\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 1.0;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                var nextPosition;\n                var nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);\n                var groundPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position2), scratchCartesian3Position2);\n                if (i + 1 < length) {\n                    nextPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position3), scratchCartesian3Position3);\n                    nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);\n                }\n\n                if (recomputeNormal) {\n                    var scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);\n                    var scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);\n                    normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(nextPosition, groundPosition, CesiumMath.EPSILON10)) {\n                    recomputeNormal = true;\n                } else {\n                    s += ds;\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.subtract(nextPosition, groundPosition, tangent), tangent);\n                    }\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        // prepare the side walls, two triangles for each wall\n        //\n        //    A (i+1)  B (i+3) E\n        //    +--------+-------+\n        //    |      / |      /|    triangles:  A C B\n        //    |     /  |     / |                B C D\n        //    |    /   |    /  |\n        //    |   /    |   /   |\n        //    |  /     |  /    |\n        //    | /      | /     |\n        //    +--------+-------+\n        //    C (i)    D (i+2) F\n        //\n\n        var numVertices = size / 3;\n        size -= 6 * (numCorners + 1);\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\nexport default WallGeometry;\n","import BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport WallGeometryLibrary from './WallGeometryLibrary.js';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n\n    /**\n     * A description of a wall outline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @example\n     * // create a wall outline that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     */\n    function WallOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallOutlineGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallOutlineGeometry} [result] The object into which to store the result.\n     * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\n     */\n    WallOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a walloutline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @returns {WallOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     *\n     * @see WallOutlineGeometry#createGeometry\n     */\n    WallOutlineGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid\n        };\n        return new WallOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallOutlineGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = new Float64Array(size);\n        var positionIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        length /= 3;\n        var i;\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n\n            // insert the lower point\n            positions[positionIndex++] = bottomPosition.x;\n            positions[positionIndex++] = bottomPosition.y;\n            positions[positionIndex++] = bottomPosition.z;\n\n            // insert the upper point\n            positions[positionIndex++] = topPosition.x;\n            positions[positionIndex++] = topPosition.y;\n            positions[positionIndex++] = topPosition.z;\n        }\n\n        var attributes = new GeometryAttributes({\n            position : new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            })\n        });\n\n        var numVertices = size / 3;\n        size = 2 * numVertices - 4 + numVertices;\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        indices[edgeIndex++] = numVertices - 2;\n        indices[edgeIndex++] = numVertices - 1;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\nexport default WallOutlineGeometry;\n","import Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defined from '../Core/defined.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport WallGeometry from '../Core/WallGeometry.js';\nimport WallOutlineGeometry from '../Core/WallOutlineGeometry.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryUpdater from './DynamicGeometryUpdater.js';\nimport GeometryUpdater from './GeometryUpdater.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n\n    function WallGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.minimumHeights = undefined;\n        this.maximumHeights = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for walls.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias WallGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function WallGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new WallGeometryOptions(entity),\n            geometryPropertyName : 'wall',\n            observedPropertyNames : ['availability', 'wall']\n        });\n\n        this._onEntityPropertyChanged(entity, 'wall', entity.wall, undefined);\n    }\n\n    if (defined(Object.create)) {\n        WallGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        WallGeometryUpdater.prototype.constructor = WallGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    WallGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    WallGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    WallGeometryUpdater.prototype._isHidden = function(entity, wall) {\n        return !defined(wall.positions) || GeometryUpdater.prototype._isHidden.call(this, entity, wall);\n    };\n\n    WallGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    WallGeometryUpdater.prototype._isDynamic = function(entity, wall) {\n        return !wall.positions.isConstant || //\n               !Property.isConstant(wall.minimumHeights) || //\n               !Property.isConstant(wall.maximumHeights) || //\n               !Property.isConstant(wall.outlineWidth) || //\n               !Property.isConstant(wall.granularity);\n    };\n\n    WallGeometryUpdater.prototype._setStaticOptions = function(entity, wall) {\n        var minimumHeights = wall.minimumHeights;\n        var maximumHeights = wall.maximumHeights;\n        var granularity = wall.granularity;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = wall.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.minimumHeights = defined(minimumHeights) ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights) : undefined;\n        options.maximumHeights = defined(maximumHeights) ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights) : undefined;\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    WallGeometryUpdater.DynamicGeometryUpdater = DynamicWallGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicWallGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicWallGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicWallGeometryUpdater.prototype.constructor = DynamicWallGeometryUpdater;\n    }\n\n    DynamicWallGeometryUpdater.prototype._isHidden = function(entity, wall, time) {\n        return  !defined(this._options.positions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, wall, time);\n    };\n\n    DynamicWallGeometryUpdater.prototype._setOptions = function(entity, wall, time) {\n        var options = this._options;\n        options.positions = Property.getValueOrUndefined(wall.positions, time, options.positions);\n        options.minimumHeights = Property.getValueOrUndefined(wall.minimumHeights, time, options.minimumHeights);\n        options.maximumHeights = Property.getValueOrUndefined(wall.maximumHeights, time, options.maximumHeights);\n        options.granularity = Property.getValueOrUndefined(wall.granularity, time);\n    };\nexport default WallGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport Event from '../Core/Event.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport MaterialAppearance from '../Scene/MaterialAppearance.js';\nimport PerInstanceColorAppearance from '../Scene/PerInstanceColorAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport BoxGeometryUpdater from './BoxGeometryUpdater.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport CorridorGeometryUpdater from './CorridorGeometryUpdater.js';\nimport CylinderGeometryUpdater from './CylinderGeometryUpdater.js';\nimport DynamicGeometryBatch from './DynamicGeometryBatch.js';\nimport EllipseGeometryUpdater from './EllipseGeometryUpdater.js';\nimport EllipsoidGeometryUpdater from './EllipsoidGeometryUpdater.js';\nimport Entity from './Entity.js';\nimport PlaneGeometryUpdater from './PlaneGeometryUpdater.js';\nimport PolygonGeometryUpdater from './PolygonGeometryUpdater.js';\nimport PolylineVolumeGeometryUpdater from './PolylineVolumeGeometryUpdater.js';\nimport RectangleGeometryUpdater from './RectangleGeometryUpdater.js';\nimport StaticGeometryColorBatch from './StaticGeometryColorBatch.js';\nimport StaticGeometryPerMaterialBatch from './StaticGeometryPerMaterialBatch.js';\nimport StaticGroundGeometryColorBatch from './StaticGroundGeometryColorBatch.js';\nimport StaticGroundGeometryPerMaterialBatch from './StaticGroundGeometryPerMaterialBatch.js';\nimport StaticOutlineGeometryBatch from './StaticOutlineGeometryBatch.js';\nimport WallGeometryUpdater from './WallGeometryUpdater.js';\n\n    var emptyArray = [];\n\n    var geometryUpdaters = [BoxGeometryUpdater, CylinderGeometryUpdater, CorridorGeometryUpdater, EllipseGeometryUpdater, EllipsoidGeometryUpdater, PlaneGeometryUpdater,\n                            PolygonGeometryUpdater, PolylineVolumeGeometryUpdater, RectangleGeometryUpdater, WallGeometryUpdater];\n\n    function GeometryUpdaterSet(entity, scene) {\n        this.entity = entity;\n        this.scene = scene;\n        var updaters = new Array(geometryUpdaters.length);\n        var geometryChanged = new Event();\n        function raiseEvent(geometry) {\n            geometryChanged.raiseEvent(geometry);\n        }\n        var eventHelper = new EventHelper();\n        for (var i = 0; i < updaters.length; i++) {\n            var updater = new geometryUpdaters[i](entity, scene);\n            eventHelper.add(updater.geometryChanged, raiseEvent);\n            updaters[i] = updater;\n        }\n        this.updaters = updaters;\n        this.geometryChanged = geometryChanged;\n        this.eventHelper = eventHelper;\n\n        this._removeEntitySubscription = entity.definitionChanged.addEventListener(GeometryUpdaterSet.prototype._onEntityPropertyChanged, this);\n    }\n\n    GeometryUpdaterSet.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i]._onEntityPropertyChanged(entity, propertyName, newValue, oldValue);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.forEach = function (callback) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            callback(updaters[i]);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.destroy = function() {\n        this.eventHelper.removeAll();\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i].destroy();\n        }\n        this._removeEntitySubscription();\n        destroyObject(this);\n    };\n\n    /**\n     * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n     * @alias GeometryVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function GeometryVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        primitives = defaultValue(primitives, scene.primitives);\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._outlineBatches = new Array(numberOfShadowModes*2);\n        this._closedColorBatches = new Array(numberOfShadowModes*2);\n        this._closedMaterialBatches = new Array(numberOfShadowModes*2);\n        this._openColorBatches = new Array(numberOfShadowModes*2);\n        this._openMaterialBatches = new Array(numberOfShadowModes*2);\n\n        var supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(scene);\n        this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;\n\n        var i;\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._outlineBatches[i] = new StaticOutlineGeometryBatch(primitives, scene, i, false);\n            this._outlineBatches[numberOfShadowModes + i] = new StaticOutlineGeometryBatch(primitives, scene, i, true);\n\n            this._closedColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, true);\n            this._closedColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, false);\n\n            this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, true);\n            this._closedMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, false);\n\n            this._openColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, true);\n            this._openColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, false);\n\n            this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, true);\n            this._openMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, false);\n        }\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        var groundColorBatches = new Array(numberOfClassificationTypes);\n        var groundMaterialBatches = [];\n        if (supportsMaterialsforEntitiesOnTerrain) {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundMaterialBatches.push(new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, MaterialAppearance));\n                groundColorBatches[i] = new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, PerInstanceColorAppearance);\n            }\n        } else {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n            }\n        }\n\n        this._groundColorBatches = groundColorBatches;\n        this._groundMaterialBatches = groundMaterialBatches;\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaterSets = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    GeometryVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updaterSet;\n        var that = this;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updaterSet.entity === entity) {\n                updaterSet.forEach(function(updater) {\n                    that._removeUpdater(updater);\n                    that._insertUpdaterIntoBatch(time, updater);\n                });\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n            updaterSet.forEach(this._removeUpdater.bind(this));\n            updaterSet.destroy();\n            this._updaterSets.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updaterSet = new GeometryUpdaterSet(entity, this._scene);\n            this._updaterSets.set(id, updaterSet);\n            updaterSet.forEach(function(updater) {\n                that._insertUpdaterIntoBatch(time, updater);\n            });\n            this._subscriptions.set(id, updaterSet.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    GeometryVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n\n        var id = entity.id;\n        var updaters = this._updaterSets.get(id).updaters;\n\n        for (var j = 0; j < updaters.length; j++) {\n            var updater = updaters[j];\n            for (var i = 0; i < batchesLength; i++) {\n                state = batches[i].getBoundingSphere(updater, tmp);\n                if (state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    GeometryVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n\n        var updaterSets = this._updaterSets.values;\n        length = updaterSets.length;\n        for (i = 0; i < length; i++) {\n            updaterSets[i].destroy();\n        }\n        this._updaterSets.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._removeUpdater = function(updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = this._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._insertUpdaterIntoBatch = function(time, updater) {\n        if (updater.isDynamic) {\n            this._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.outlineEnabled || updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        if (updater.outlineEnabled) {\n            if (defined(updater.terrainOffsetProperty)) {\n                this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._outlineBatches[shadows].add(time, updater);\n            }\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.onTerrain) {\n                var classificationType = updater.classificationTypeProperty.getValue(time);\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    this._groundColorBatches[classificationType].add(time, updater);\n                } else {\n                    // If unsupported, updater will not be on terrain.\n                    this._groundMaterialBatches[classificationType].add(time, updater);\n                }\n            } else if (updater.isClosed) {\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    if (defined(updater.terrainOffsetProperty)) {\n                        this._closedColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                    } else {\n                        this._closedColorBatches[shadows].add(time, updater);\n                    }\n                } else if (defined(updater.terrainOffsetProperty)) {\n                    this._closedMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._closedMaterialBatches[shadows].add(time, updater);\n                }\n            } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                if (defined(updater.terrainOffsetProperty)) {\n                    this._openColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._openColorBatches[shadows].add(time, updater);\n                }\n            } else if (defined(updater.terrainOffsetProperty)) {\n                this._openMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._openMaterialBatches[shadows].add(time, updater);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\nexport default GeometryVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport HorizontalOrigin from '../Scene/HorizontalOrigin.js';\nimport LabelStyle from '../Scene/LabelStyle.js';\nimport VerticalOrigin from '../Scene/VerticalOrigin.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultScale = 1.0;\n    var defaultFont = '30px sans-serif';\n    var defaultStyle = LabelStyle.FILL;\n    var defaultFillColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 1.0;\n    var defaultShowBackground = false;\n    var defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\n    var defaultBackgroundPadding = new Cartesian2(7, 5);\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n\n    var positionScratch = new Cartesian3();\n    var fillColorScratch = new Color();\n    var outlineColorScratch = new Color();\n    var backgroundColorScratch = new Color();\n    var backgroundPaddingScratch = new Cartesian2();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.label = undefined;\n        this.index = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps the {@link LabelGraphics} instance\n     * in {@link Entity#label} to a {@link Label}.\n     * @alias LabelVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function LabelVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    LabelVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var labelGraphics = entity._label;\n            var text;\n            var label = item.label;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                text = Property.getValueOrUndefined(labelGraphics._text, time);\n                show = defined(position) && defined(text);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var updateClamping = false;\n            var heightReference = Property.getValueOrDefault(labelGraphics._heightReference, time, defaultHeightReference);\n\n            if (!defined(label)) {\n                label = cluster.getLabel(entity);\n                label.id = entity;\n                item.label = label;\n\n                // If this new label happens to have a position and height reference that match our new values,\n                // label._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(label.position, position) && label.heightReference === heightReference;\n            }\n\n            label.show = true;\n            label.position = position;\n            label.text = text;\n            label.scale = Property.getValueOrDefault(labelGraphics._scale, time, defaultScale);\n            label.font = Property.getValueOrDefault(labelGraphics._font, time, defaultFont);\n            label.style = Property.getValueOrDefault(labelGraphics._style, time, defaultStyle);\n            label.fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultFillColor, fillColorScratch);\n            label.outlineColor = Property.getValueOrDefault(labelGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n            label.outlineWidth = Property.getValueOrDefault(labelGraphics._outlineWidth, time, defaultOutlineWidth);\n            label.showBackground = Property.getValueOrDefault(labelGraphics._showBackground, time, defaultShowBackground);\n            label.backgroundColor = Property.getValueOrDefault(labelGraphics._backgroundColor, time, defaultBackgroundColor, backgroundColorScratch);\n            label.backgroundPadding = Property.getValueOrDefault(labelGraphics._backgroundPadding, time, defaultBackgroundPadding, backgroundPaddingScratch);\n            label.pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            label.eyeOffset = Property.getValueOrDefault(labelGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            label.heightReference = heightReference;\n            label.horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            label.verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            label.translucencyByDistance = Property.getValueOrUndefined(labelGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(labelGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            label.scaleByDistance = Property.getValueOrUndefined(labelGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            label.distanceDisplayCondition = Property.getValueOrUndefined(labelGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            label.disableDepthTestDistance = Property.getValueOrUndefined(labelGraphics._disableDepthTestDistance, time);\n\n            if (updateClamping) {\n                label._updateClamping();\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    LabelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.label)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var label = item.label;\n        result.center = Cartesian3.clone(defaultValue(label._clampedPosition, label.position), result.center);\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    LabelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    LabelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeLabel(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    LabelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.label = undefined;\n            cluster.removeLabel(entity);\n        }\n    }\nexport default LabelVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Axis from '../Scene/Axis.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Cartesian2 from '../Core/Cartesian2.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport Resource from '../Core/Resource.js';\nimport ColorBlendMode from '../Scene/ColorBlendMode.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport Model from '../Scene/Model.js';\nimport ModelAnimationLoop from '../Scene/ModelAnimationLoop.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultScale = 1.0;\n    var defaultMinimumPixelSize = 0.0;\n    var defaultIncrementallyLoadTextures = true;\n    var defaultClampAnimations = true;\n    var defaultShadows = ShadowMode.ENABLED;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultSilhouetteColor = Color.RED;\n    var defaultSilhouetteSize = 0.0;\n    var defaultColor = Color.WHITE;\n    var defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\n    var defaultColorBlendAmount = 0.5;\n    var defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n    var defaultUpAxis = Axis.Y;\n\n    var modelMatrixScratch = new Matrix4();\n    var nodeMatrixScratch = new Matrix4();\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n     * @alias ModelVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function ModelVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._primitives = scene.primitives;\n        this._entityCollection = entityCollection;\n        this._modelHash = {};\n        this._entitiesToVisualize = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates models created this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    ModelVisualizer.prototype.update = function(time) {\n        \n\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (var i = 0, len = entities.length; i < len; i++) {\n            var entity = entities[i];\n            var modelGraphics = entity._model;\n\n            var resource;\n            var modelData = modelHash[entity.id];\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);\n\n            var modelMatrix;\n            if (show) {\n                modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n                resource = Resource.createIfNeeded(Property.getValueOrUndefined(modelGraphics._uri, time));\n                show = defined(modelMatrix) && defined(resource);\n            }\n\n            if (!show) {\n                if (defined(modelData)) {\n                    modelData.modelPrimitive.show = false;\n                }\n                continue;\n            }\n\n            var model = defined(modelData) ? modelData.modelPrimitive : undefined;\n            if (!defined(model) || resource.url !== modelData.url) {\n                if (defined(model)) {\n                    primitives.removeAndDestroy(model);\n                    delete modelHash[entity.id];\n                }\n                model = Model.fromGltf({\n                    url : resource,\n                    incrementallyLoadTextures : Property.getValueOrDefault(modelGraphics._incrementallyLoadTextures, time, defaultIncrementallyLoadTextures),\n                    scene : this._scene\n                });\n                model.id = entity;\n                primitives.add(model);\n\n                modelData = {\n                    modelPrimitive : model,\n                    url : resource.url,\n                    animationsRunning : false,\n                    nodeTransformationsScratch : {},\n                    articulationsScratch : {},\n                    loadFail : false\n                };\n                modelHash[entity.id] = modelData;\n\n                checkModelLoad(model, entity, modelHash);\n            }\n\n            model.show = true;\n            model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);\n            model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);\n            model.maximumScale = Property.getValueOrUndefined(modelGraphics._maximumScale, time);\n            model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n            model.shadows = Property.getValueOrDefault(modelGraphics._shadows, time, defaultShadows);\n            model.heightReference = Property.getValueOrDefault(modelGraphics._heightReference, time, defaultHeightReference);\n            model.distanceDisplayCondition = Property.getValueOrUndefined(modelGraphics._distanceDisplayCondition, time);\n            model.silhouetteColor = Property.getValueOrDefault(modelGraphics._silhouetteColor, time, defaultSilhouetteColor, model._silhouetteColor);\n            model.silhouetteSize = Property.getValueOrDefault(modelGraphics._silhouetteSize, time, defaultSilhouetteSize);\n            model.color = Property.getValueOrDefault(modelGraphics._color, time, defaultColor, model._color);\n            model.colorBlendMode = Property.getValueOrDefault(modelGraphics._colorBlendMode, time, defaultColorBlendMode);\n            model.colorBlendAmount = Property.getValueOrDefault(modelGraphics._colorBlendAmount, time, defaultColorBlendAmount);\n            model.clippingPlanes = Property.getValueOrUndefined(modelGraphics._clippingPlanes, time);\n            model.clampAnimations = Property.getValueOrDefault(modelGraphics._clampAnimations, time, defaultClampAnimations);\n            model.imageBasedLightingFactor = Property.getValueOrDefault(modelGraphics._imageBasedLightingFactor, time, defaultImageBasedLightingFactor);\n            model.lightColor = Property.getValueOrUndefined(modelGraphics._lightColor, time);\n            model._upAxis = Property.getValueOrDefault(modelGraphics._upAxis, time, defaultUpAxis);\n            model._forwardAxis = Property.getValueOrUndefined(modelGraphics._forwardAxis, time);\n\n            if (model.ready) {\n                var runAnimations = Property.getValueOrDefault(modelGraphics._runAnimations, time, true);\n                if (modelData.animationsRunning !== runAnimations) {\n                    if (runAnimations) {\n                        model.activeAnimations.addAll({\n                            loop : ModelAnimationLoop.REPEAT\n                        });\n                    } else {\n                        model.activeAnimations.removeAll();\n                    }\n                    modelData.animationsRunning = runAnimations;\n                }\n\n                // Apply node transformations\n                var nodeTransformations = Property.getValueOrUndefined(modelGraphics._nodeTransformations, time, modelData.nodeTransformationsScratch);\n                if (defined(nodeTransformations)) {\n                    var nodeNames = Object.keys(nodeTransformations);\n                    for (var nodeIndex = 0, nodeLength = nodeNames.length; nodeIndex < nodeLength; ++nodeIndex) {\n                        var nodeName = nodeNames[nodeIndex];\n\n                        var nodeTransformation = nodeTransformations[nodeName];\n                        if (!defined(nodeTransformation)) {\n                            continue;\n                        }\n\n                        var modelNode = model.getNode(nodeName);\n                        if (!defined(modelNode)) {\n                            continue;\n                        }\n\n                        var transformationMatrix = Matrix4.fromTranslationRotationScale(nodeTransformation, nodeMatrixScratch);\n                        modelNode.matrix = Matrix4.multiply(modelNode.originalMatrix, transformationMatrix, transformationMatrix);\n                    }\n                }\n\n                // Apply articulations\n                var anyArticulationUpdated = false;\n                var articulations = Property.getValueOrUndefined(modelGraphics._articulations, time, modelData.articulationsScratch);\n                if (defined(articulations)) {\n                    var articulationStageKeys = Object.keys(articulations);\n                    for (var s = 0, numKeys = articulationStageKeys.length; s < numKeys; ++s) {\n                        var key = articulationStageKeys[s];\n\n                        var articulationStageValue = articulations[key];\n                        if (!defined(articulationStageValue)) {\n                            continue;\n                        }\n\n                        anyArticulationUpdated = true;\n                        model.setArticulationStage(key, articulationStageValue);\n                    }\n                }\n\n                if (anyArticulationUpdated) {\n                    model.applyArticulations();\n                }\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    ModelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    ModelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n        for (var i = entities.length - 1; i > -1; i--) {\n            removeModel(this, entities[i], modelHash, primitives);\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    ModelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var modelData = this._modelHash[entity.id];\n        if (!defined(modelData) || modelData.loadFail) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var model = modelData.modelPrimitive;\n        if (!defined(model) || !model.show) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (!model.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        if (model.heightReference === HeightReference.NONE) {\n            BoundingSphere.transform(model.boundingSphere, model.modelMatrix, result);\n        } else {\n            if (!defined(model._clampedModelMatrix) || model._heightChanged) {\n                return BoundingSphereState.PENDING;\n            }\n            BoundingSphere.transform(model.boundingSphere, model._clampedModelMatrix, result);\n        }\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * @private\n     */\n    ModelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var entities = this._entitiesToVisualize;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                entities.set(entity.id, entity);\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                clearNodeTransformationsArticulationsScratch(entity, modelHash);\n                entities.set(entity.id, entity);\n            } else {\n                removeModel(this, entity, modelHash, primitives);\n                entities.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            removeModel(this, entity, modelHash, primitives);\n            entities.remove(entity.id);\n        }\n    };\n\n    function removeModel(visualizer, entity, modelHash, primitives) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            primitives.removeAndDestroy(modelData.modelPrimitive);\n            delete modelHash[entity.id];\n        }\n    }\n\n    function clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            modelData.nodeTransformationsScratch = {};\n            modelData.articulationsScratch = {};\n        }\n    }\n\n    function checkModelLoad(model, entity, modelHash){\n        model.readyPromise.otherwise(function(error){\n            console.error(error);\n            modelHash[entity.id].loadFail = true;\n        });\n    }\nexport default ModelVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport JulianDate from '../Core/JulianDate.js';\nimport Matrix3 from '../Core/Matrix3.js';\nimport Matrix4 from '../Core/Matrix4.js';\nimport ReferenceFrame from '../Core/ReferenceFrame.js';\nimport TimeInterval from '../Core/TimeInterval.js';\nimport Transforms from '../Core/Transforms.js';\nimport PolylineCollection from '../Scene/PolylineCollection.js';\nimport SceneMode from '../Scene/SceneMode.js';\nimport CompositePositionProperty from './CompositePositionProperty.js';\nimport ConstantPositionProperty from './ConstantPositionProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\nimport ReferenceProperty from './ReferenceProperty.js';\nimport SampledPositionProperty from './SampledPositionProperty.js';\nimport ScaledPositionProperty from './ScaledPositionProperty.js';\nimport TimeIntervalCollectionPositionProperty from './TimeIntervalCollectionPositionProperty.js';\n\n    var defaultResolution = 60.0;\n    var defaultWidth = 1.0;\n\n    var scratchTimeInterval = new TimeInterval();\n    var subSampleCompositePropertyScratch = new TimeInterval();\n    var subSampleIntervalPropertyScratch = new TimeInterval();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.polyline = undefined;\n        this.index = undefined;\n        this.updater = undefined;\n    }\n\n    function subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var r = startingIndex;\n        //Always step exactly on start (but only use it if it exists.)\n        var tmp;\n        tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n\n        //Iterate over all interval times and add the ones that fall in our\n        //time range.  Note that times can contain data outside of\n        //the intervals range.  This is by design for use with interpolation.\n        var t = 0;\n        var len = times.length;\n        var current = times[t];\n        var loopStop = stop;\n        var sampling = false;\n        var sampleStepsToTake;\n        var sampleStepsTaken;\n        var sampleStepSize;\n\n        while (t < len) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n                steppedOnNow = true;\n            }\n            if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {\n                tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n            }\n\n            if (t < (len - 1)) {\n                if (maximumStep > 0 && !sampling) {\n                    var next = times[t + 1];\n                    var secondsUntilNext = JulianDate.secondsDifference(next, current);\n                    sampling = secondsUntilNext > maximumStep;\n\n                    if (sampling) {\n                        sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n                        sampleStepsTaken = 0;\n                        sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n                        sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n                    }\n                }\n\n                if (sampling && sampleStepsTaken < sampleStepsToTake) {\n                    current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());\n                    sampleStepsTaken++;\n                    continue;\n                }\n            }\n            sampling = false;\n            t++;\n            current = times[t];\n        }\n\n        //Always step exactly on stop (but only use it if it exists.)\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        return r;\n    }\n\n    function subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp;\n        var i = 0;\n        var index = startingIndex;\n        var time = start;\n        var stepSize = Math.max(maximumStep, 60);\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n        while (JulianDate.lessThan(time, stop)) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n                steppedOnNow = true;\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n            tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n            if (defined(tmp)) {\n                result[index] = tmp;\n                index++;\n            }\n            i++;\n            time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n        }\n        //Always sample stop.\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n        if (defined(tmp)) {\n            result[index] = tmp;\n            index++;\n        }\n        return index;\n    }\n\n    function subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleIntervalPropertyScratch.start = start;\n        subSampleIntervalPropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {\n                var time = interval.start;\n                if (!interval.isStartIncluded) {\n                    if (interval.isStopIncluded) {\n                        time = interval.stop;\n                    } else {\n                        time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());\n                    }\n                }\n                var tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n        }\n        return index;\n    }\n\n    function subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);\n        if (defined(tmp)) {\n            result[startingIndex++] = tmp;\n        }\n        return startingIndex;\n    }\n\n    function subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleCompositePropertyScratch.start = start;\n        subSampleCompositePropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {\n                var intervalStart = interval.start;\n                var intervalStop = interval.stop;\n\n                var sampleStart = start;\n                if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n                    sampleStart = intervalStart;\n                }\n\n                var sampleStop = stop;\n                if (JulianDate.lessThan(intervalStop, sampleStop)) {\n                    sampleStop = intervalStop;\n                }\n\n                index = reallySubSample(interval.data, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);\n            }\n        }\n        return index;\n    }\n\n    function reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, index, result) {\n        //Unwrap any references until we have the actual property.\n        while (property instanceof ReferenceProperty) {\n            property = property.resolvedProperty;\n        }\n\n        if (property instanceof SampledPositionProperty) {\n            var times = property._property._times;\n            index = subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof CompositePositionProperty) {\n            index = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n            index = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof ConstantPositionProperty ||\n                   (property instanceof ScaledPositionProperty && Property.isConstant(property))) {\n            index = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else {\n            //Fallback to generic sampling.\n            index = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        }\n        return index;\n    }\n\n    function subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var length = reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);\n        result.length = length;\n        return result;\n    }\n\n    var toFixedScratch = new Matrix3();\n    function PolylineUpdater(scene, referenceFrame) {\n        this._unusedIndexes = [];\n        this._polylineCollection = new PolylineCollection();\n        this._scene = scene;\n        this._referenceFrame = referenceFrame;\n        scene.primitives.add(this._polylineCollection);\n    }\n\n    PolylineUpdater.prototype.update = function(time) {\n        if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n            var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);\n            if (!defined(toFixed)) {\n                toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);\n            }\n            Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);\n        }\n    };\n\n    PolylineUpdater.prototype.updateObject = function(time, item) {\n        var entity = item.entity;\n        var pathGraphics = entity._path;\n        var positionProperty = entity._position;\n\n        var sampleStart;\n        var sampleStop;\n        var showProperty = pathGraphics._show;\n        var polyline = item.polyline;\n        var show = entity.isShowing && (!defined(showProperty) || showProperty.getValue(time));\n\n        //While we want to show the path, there may not actually be anything to show\n        //depending on lead/trail settings.  Compute the interval of the path to\n        //show and check against actual availability.\n        if (show) {\n            var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n            var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);\n            var availability = entity._availability;\n            var hasAvailability = defined(availability);\n            var hasLeadTime = defined(leadTime);\n            var hasTrailTime = defined(trailTime);\n\n            //Objects need to have either defined availability or both a lead and trail time in order to\n            //draw a path (since we can't draw \"infinite\" paths.\n            show = hasAvailability || (hasLeadTime && hasTrailTime);\n\n            //The final step is to compute the actual start/stop times of the path to show.\n            //If current time is outside of the availability interval, there's a chance that\n            //we won't have to draw anything anyway.\n            if (show) {\n                if (hasTrailTime) {\n                    sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n                }\n                if (hasLeadTime) {\n                    sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n                }\n\n                if (hasAvailability) {\n                    var start = availability.start;\n                    var stop = availability.stop;\n\n                    if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n                        sampleStart = start;\n                    }\n\n                    if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n                        sampleStop = stop;\n                    }\n                }\n                show = JulianDate.lessThan(sampleStart, sampleStop);\n            }\n        }\n\n        if (!show) {\n            //don't bother creating or updating anything else\n            if (defined(polyline)) {\n                this._unusedIndexes.push(item.index);\n                item.polyline = undefined;\n                polyline.show = false;\n                item.index = undefined;\n            }\n            return;\n        }\n\n        if (!defined(polyline)) {\n            var unusedIndexes = this._unusedIndexes;\n            var length = unusedIndexes.length;\n            if (length > 0) {\n                var index = unusedIndexes.pop();\n                polyline = this._polylineCollection.get(index);\n                item.index = index;\n            } else {\n                item.index = this._polylineCollection.length;\n                polyline = this._polylineCollection.add();\n            }\n            polyline.id = entity;\n            item.polyline = polyline;\n        }\n\n        var resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);\n\n        polyline.show = true;\n        polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions.slice());\n        polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);\n        polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);\n        polyline.distanceDisplayCondition = Property.getValueOrUndefined(pathGraphics._distanceDisplayCondition, time, polyline.distanceDisplayCondition);\n    };\n\n    PolylineUpdater.prototype.removeObject = function(item) {\n        var polyline = item.polyline;\n        if (defined(polyline)) {\n            this._unusedIndexes.push(item.index);\n            item.polyline = undefined;\n            polyline.show = false;\n            polyline.id = undefined;\n            item.index = undefined;\n        }\n    };\n\n    PolylineUpdater.prototype.destroy = function() {\n        this._scene.primitives.remove(this._polylineCollection);\n        return destroyObject(this);\n    };\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n     * @alias PathVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PathVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._updaters = {};\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PathVisualizer.prototype.update = function(time) {\n        \n\n        var updaters = this._updaters;\n        for (var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].update(time);\n            }\n        }\n\n        var items = this._items.values;\n        if (items.length === 0 && defined(this._updaters) && Object.keys(this._updaters).length > 0) {\n            for (var u in updaters) {\n                if (updaters.hasOwnProperty(u)) {\n                    updaters[u].destroy();\n                }\n            }\n            this._updaters = {};\n        }\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var positionProperty = entity._position;\n\n            var lastUpdater = item.updater;\n\n            var frameToVisualize = ReferenceFrame.FIXED;\n            if (this._scene.mode === SceneMode.SCENE3D) {\n                frameToVisualize = positionProperty.referenceFrame;\n            }\n\n            var currentUpdater = this._updaters[frameToVisualize];\n\n            if ((lastUpdater === currentUpdater) && (defined(currentUpdater))) {\n                currentUpdater.updateObject(time, item);\n                continue;\n            }\n\n            if (defined(lastUpdater)) {\n                lastUpdater.removeObject(item);\n            }\n\n            if (!defined(currentUpdater)) {\n                currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n                currentUpdater.update(time);\n                this._updaters[frameToVisualize] = currentUpdater;\n            }\n\n            item.updater = currentUpdater;\n            if (defined(currentUpdater)) {\n                currentUpdater.updateObject(time, item);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PathVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PathVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        var updaters = this._updaters;\n        for ( var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].destroy();\n            }\n        }\n\n        return destroyObject(this);\n    };\n\n    PathVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var item;\n        var items = this._items;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                item = items.get(entity.id);\n                if (defined(item)) {\n                    if (defined(item.updater)) {\n                        item.updater.removeObject(item);\n                    }\n                    items.remove(entity.id);\n                }\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            item = items.get(entity.id);\n            if (defined(item)) {\n                if (defined(item.updater)) {\n                    item.updater.removeObject(item);\n                }\n                items.remove(entity.id);\n            }\n        }\n    };\n\n    //for testing\n    PathVisualizer._subSample = subSample;\nexport default PathVisualizer;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Cartesian3 from '../Core/Cartesian3.js';\nimport Color from '../Core/Color.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport NearFarScalar from '../Core/NearFarScalar.js';\nimport createBillboardPointCallback from '../Scene/createBillboardPointCallback.js';\nimport HeightReference from '../Scene/HeightReference.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport Property from './Property.js';\n\n    var defaultColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 0.0;\n    var defaultPixelSize = 1.0;\n    var defaultDisableDepthTestDistance = 0.0;\n\n    var colorScratch = new Color();\n    var positionScratch = new Cartesian3();\n    var outlineColorScratch = new Color();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.pointPrimitive = undefined;\n        this.billboard = undefined;\n        this.color = undefined;\n        this.outlineColor = undefined;\n        this.pixelSize = undefined;\n        this.outlineWidth = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n     * @alias PointVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PointVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PointVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var pointGraphics = entity._point;\n            var pointPrimitive = item.pointPrimitive;\n            var billboard = item.billboard;\n            var heightReference = Property.getValueOrDefault(pointGraphics._heightReference, time, HeightReference.NONE);\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                show = defined(position);\n            }\n            if (!show) {\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var needsRedraw = false;\n            var updateClamping = false;\n            if ((heightReference !== HeightReference.NONE) && !defined(billboard)) {\n                if (defined(pointPrimitive)) {\n                    returnPrimitive(item, entity, cluster);\n                    pointPrimitive = undefined;\n                }\n\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n                needsRedraw = true;\n\n                // If this new billboard happens to have a position and height reference that match our new values,\n                // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(billboard.position, position) && billboard.heightReference === heightReference;\n            } else if ((heightReference === HeightReference.NONE) && !defined(pointPrimitive)) {\n                if (defined(billboard)) {\n                    returnPrimitive(item, entity, cluster);\n                    billboard = undefined;\n                }\n\n                pointPrimitive = cluster.getPoint(entity);\n                pointPrimitive.id = entity;\n                item.pointPrimitive = pointPrimitive;\n            }\n\n            if (defined(pointPrimitive)) {\n                pointPrimitive.show = true;\n                pointPrimitive.position = position;\n                pointPrimitive.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                pointPrimitive.color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                pointPrimitive.outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                pointPrimitive.outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);\n                pointPrimitive.pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);\n                pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n            } else if (defined(billboard)) {\n                billboard.show = true;\n                billboard.position = position;\n                billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                billboard.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                billboard.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                billboard.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n                billboard.heightReference = heightReference;\n\n                var newColor = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                var newOutlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                var newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));\n                var newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));\n\n                if (newOutlineWidth > 0) {\n                    billboard.scale = 1.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 newPixelSize !== item.pixelSize || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                } else {\n                    billboard.scale = newPixelSize / 50.0;\n                    newPixelSize = 50.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                }\n\n                if (needsRedraw) {\n                    item.color = Color.clone(newColor, item.color);\n                    item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n                    item.pixelSize = newPixelSize;\n                    item.outlineWidth = newOutlineWidth;\n\n                    var centerAlpha = newColor.alpha;\n                    var cssColor = newColor.toCssColorString();\n                    var cssOutlineColor = newOutlineColor.toCssColorString();\n                    var textureId = JSON.stringify([cssColor, newPixelSize, cssOutlineColor, newOutlineWidth]);\n\n                    billboard.setImage(textureId, createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));\n                }\n\n                if (updateClamping) {\n                    billboard._updateClamping();\n                }\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PointVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !(defined(item.pointPrimitive) || defined(item.billboard))) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (defined(item.pointPrimitive)) {\n            result.center = Cartesian3.clone(item.pointPrimitive.position, result.center);\n        } else {\n            var billboard = item.billboard;\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PointVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PointVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removePoint(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    PointVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            var pointPrimitive = item.pointPrimitive;\n            if (defined(pointPrimitive)) {\n                item.pointPrimitive = undefined;\n                cluster.removePoint(entity);\n                return;\n            }\n            var billboard = item.billboard;\n            if (defined(billboard)) {\n                item.billboard = undefined;\n                cluster.removeBillboard(entity);\n            }\n        }\n    }\nexport default PointVisualizer;\n","import ArcType from './ArcType.js';\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\nimport BoundingSphere from './BoundingSphere.js';\nimport Cartesian3 from './Cartesian3.js';\nimport Color from './Color.js';\nimport ComponentDatatype from './ComponentDatatype.js';\nimport defaultValue from './defaultValue.js';\nimport defined from './defined.js';\nimport DeveloperError from './DeveloperError.js';\nimport Ellipsoid from './Ellipsoid.js';\nimport Geometry from './Geometry.js';\nimport GeometryAttribute from './GeometryAttribute.js';\nimport GeometryAttributes from './GeometryAttributes.js';\nimport GeometryType from './GeometryType.js';\nimport IndexDatatype from './IndexDatatype.js';\nimport CesiumMath from './Math.js';\nimport PolylinePipeline from './PolylinePipeline.js';\nimport PrimitiveType from './PrimitiveType.js';\nimport VertexFormat from './VertexFormat.js';\n\n    var scratchInterpolateColorsArray = [];\n\n    function interpolateColors(p0, p1, color0, color1, numPoints) {\n        var colors = scratchInterpolateColorsArray;\n        colors.length = numPoints;\n        var i;\n\n        var r0 = color0.red;\n        var g0 = color0.green;\n        var b0 = color0.blue;\n        var a0 = color0.alpha;\n\n        var r1 = color1.red;\n        var g1 = color1.green;\n        var b1 = color1.blue;\n        var a1 = color1.alpha;\n\n        if (Color.equals(color0, color1)) {\n            for (i = 0; i < numPoints; i++) {\n                colors[i] = Color.clone(color0);\n            }\n            return colors;\n        }\n\n        var redPerVertex = (r1 - r0) / numPoints;\n        var greenPerVertex = (g1 - g0) / numPoints;\n        var bluePerVertex = (b1 - b0) / numPoints;\n        var alphaPerVertex = (a1 - a0) / numPoints;\n\n        for (i = 0; i < numPoints; i++) {\n            colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);\n        }\n\n        return colors;\n    }\n\n    /**\n     * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n     * and each additional position defines a line segment from the previous position. The polyline is capable of\n     * displaying with a material.\n     *\n     * @alias PolylineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n     * @param {Number} [options.width=1.0] The width in pixels.\n     * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n     * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @exception {DeveloperError} At least two positions are required.\n     * @exception {DeveloperError} width must be greater than or equal to one.\n     * @exception {DeveloperError} colors has an invalid length.\n     *\n     * @see PolylineGeometry#createGeometry\n     *\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n     *\n     * @example\n     * // A polyline with two connected line segments\n     * var polyline = new Cesium.PolylineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     0.0, 0.0,\n     *     5.0, 0.0,\n     *     5.0, 5.0\n     *   ]),\n     *   width : 10.0\n     * });\n     * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n     */\n    function PolylineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var colors = options.colors;\n        var width = defaultValue(options.width, 1.0);\n        var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n        \n\n        this._positions = positions;\n        this._colors = colors;\n        this._width = width;\n        this._colorsPerVertex = colorsPerVertex;\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createPolylineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var colors = value._colors;\n        length = defined(colors) ? colors.length : 0.0;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            Color.pack(colors[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        colors : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        colorsPerVertex : undefined,\n        arcType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n     */\n    PolylineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var colors = length > 0 ? new Array(length) : undefined;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            colors[i] = Color.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var colorsPerVertex = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.colors = colors;\n            scratchOptions.width = width;\n            scratchOptions.colorsPerVertex = colorsPerVertex;\n            scratchOptions.arcType = arcType;\n            scratchOptions.granularity = granularity;\n            return new PolylineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._colors = colors;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._colorsPerVertex = colorsPerVertex;\n        result._arcType = arcType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var scratchCartesian3 = new Cartesian3();\n    var scratchPosition = new Cartesian3();\n    var scratchPrevPosition = new Cartesian3();\n    var scratchNextPosition = new Cartesian3();\n\n    /**\n     * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineGeometry.createGeometry = function(polylineGeometry) {\n        var width = polylineGeometry._width;\n        var vertexFormat = polylineGeometry._vertexFormat;\n        var colors = polylineGeometry._colors;\n        var colorsPerVertex = polylineGeometry._colorsPerVertex;\n        var arcType = polylineGeometry._arcType;\n        var granularity = polylineGeometry._granularity;\n        var ellipsoid = polylineGeometry._ellipsoid;\n\n        var i;\n        var j;\n        var k;\n\n        var positions = arrayRemoveDuplicates(polylineGeometry._positions, Cartesian3.equalsEpsilon);\n        var positionsLength = positions.length;\n\n        // A width of a pixel or less is not a valid geometry, but in order to support external data\n        // that may have errors we treat this as an empty geometry.\n        if (positionsLength < 2 || width <= 0.0) {\n            return undefined;\n        }\n\n        if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n            var subdivisionSize;\n            var numberOfPointsFunction;\n            if (arcType === ArcType.GEODESIC) {\n                subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n                numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n            } else {\n                subdivisionSize = granularity;\n                numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n            }\n\n            var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n            if (defined(colors)) {\n                var colorLength = 1;\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    colorLength += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize);\n                }\n\n                var newColors = new Array(colorLength);\n                var newColorIndex = 0;\n\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    var p0 = positions[i];\n                    var p1 = positions[i + 1];\n                    var c0 = colors[i];\n\n                    var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n                    if (colorsPerVertex && i < colorLength) {\n                        var c1 = colors[i + 1];\n                        var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n                        var interpolatedColorsLength = interpolatedColors.length;\n                        for (j = 0; j < interpolatedColorsLength; ++j) {\n                            newColors[newColorIndex++] = interpolatedColors[j];\n                        }\n                    } else {\n                        for (j = 0; j < numColors; ++j) {\n                            newColors[newColorIndex++] = Color.clone(c0);\n                        }\n                    }\n                }\n\n                newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n                colors = newColors;\n\n                scratchInterpolateColorsArray.length = 0;\n            }\n\n            if (arcType === ArcType.GEODESIC) {\n                positions = PolylinePipeline.generateCartesianArc({\n                    positions: positions,\n                    minDistance: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            } else {\n                positions = PolylinePipeline.generateCartesianRhumbArc({\n                    positions: positions,\n                    granularity: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            }\n        }\n\n        positionsLength = positions.length;\n        var size = positionsLength * 4.0 - 4.0;\n\n        var finalPositions = new Float64Array(size * 3);\n        var prevPositions = new Float64Array(size * 3);\n        var nextPositions = new Float64Array(size * 3);\n        var expandAndWidth = new Float32Array(size * 2);\n        var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n        var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n        var positionIndex = 0;\n        var expandAndWidthIndex = 0;\n        var stIndex = 0;\n        var colorIndex = 0;\n        var position;\n\n        for (j = 0; j < positionsLength; ++j) {\n            if (j === 0) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[0], positions[1], position);\n                Cartesian3.add(positions[0], position, position);\n            } else {\n                position = positions[j - 1];\n            }\n\n            Cartesian3.clone(position, scratchPrevPosition);\n            Cartesian3.clone(positions[j], scratchPosition);\n\n            if (j === positionsLength - 1) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n                Cartesian3.add(positions[positionsLength - 1], position, position);\n            } else {\n                position = positions[j + 1];\n            }\n\n            Cartesian3.clone(position, scratchNextPosition);\n\n            var color0, color1;\n            if (defined(finalColors)) {\n                if (j !== 0 && !colorsPerVertex) {\n                    color0 = colors[j - 1];\n                } else {\n                    color0 = colors[j];\n                }\n\n                if (j !== positionsLength - 1) {\n                    color1 = colors[j];\n                }\n            }\n\n            var startK = j === 0 ? 2 : 0;\n            var endK = j === positionsLength - 1 ? 2 : 4;\n\n            for (k = startK; k < endK; ++k) {\n                Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n                Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n                Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n                positionIndex += 3;\n\n                var direction = (k - 2 < 0) ? -1.0 : 1.0;\n                expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;       // expand direction\n                expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n                if (vertexFormat.st) {\n                    st[stIndex++] = j / (positionsLength - 1);\n                    st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n                }\n\n                if (defined(finalColors)) {\n                    var color = (k < 2) ? color0 : color1;\n\n                    finalColors[colorIndex++] = Color.floatToByte(color.red);\n                    finalColors[colorIndex++] = Color.floatToByte(color.green);\n                    finalColors[colorIndex++] = Color.floatToByte(color.blue);\n                    finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        attributes.prevPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : prevPositions\n        });\n\n        attributes.nextPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : nextPositions\n        });\n\n        attributes.expandAndWidth = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 2,\n            values : expandAndWidth\n        });\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (defined(finalColors)) {\n            attributes.color = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 4,\n                values : finalColors,\n                normalize : true\n            });\n        }\n\n        var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n        var index = 0;\n        var indicesIndex = 0;\n        var length = positionsLength - 1.0;\n        for (j = 0; j < length; ++j) {\n            indices[indicesIndex++] = index;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 1;\n\n            indices[indicesIndex++] = index + 1;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 3;\n\n            index += 4;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : BoundingSphere.fromPoints(positions),\n            geometryType : GeometryType.POLYLINES\n        });\n    };\nexport default PolylineGeometry;\n","import ArcType from '../Core/ArcType.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport DeveloperError from '../Core/DeveloperError.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport Event from '../Core/Event.js';\nimport GeometryInstance from '../Core/GeometryInstance.js';\nimport GroundPolylineGeometry from '../Core/GroundPolylineGeometry.js';\nimport Iso8601 from '../Core/Iso8601.js';\nimport oneTimeWarning from '../Core/oneTimeWarning.js';\nimport PolylineGeometry from '../Core/PolylineGeometry.js';\nimport PolylinePipeline from '../Core/PolylinePipeline.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport Entity from '../DataSources/Entity.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport PolylineCollection from '../Scene/PolylineCollection.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport ConstantProperty from './ConstantProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    //We use this object to create one polyline collection per-scene.\n    var polylineCollections = {};\n\n    var scratchColor = new Color();\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    function GeometryOptions() {\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    function GroundGeometryOptions() {\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polylines.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineGeometryUpdater(entity, scene) {\n        \n\n        this._entity = entity;\n        this._scene = scene;\n        this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);\n        this._fillEnabled = false;\n        this._dynamic = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._depthFailMaterialProperty = undefined;\n        this._geometryOptions = new GeometryOptions();\n        this._groundGeometryOptions = new GroundGeometryOptions();\n        this._id = 'polyline-' + entity.id;\n        this._clampToGround = false;\n        this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n\n        this._zIndex = 0;\n\n        this._onEntityPropertyChanged(entity, 'polyline', entity.polyline, undefined);\n    }\n\n    defineProperties(PolylineGeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof PolylineGeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id: {\n            get: function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled || (!defined(this._entity.availability) && Property.isConstant(this._showProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry when it fails the depth test.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        depthFailMaterialProperty : {\n            get : function() {\n                return this._depthFailMaterialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            value : false\n        },\n        /**\n         * Gets a value indicating if outline visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            value : true\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            value : undefined\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from each light source.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            value : false\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the path of the line.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {ArcType}\n         * @readonly\n         */\n        arcType : {\n            get : function() {\n                return this._arcType;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the geometry is clamped to the ground.\n         * Returns false if polylines on terrain is not supported.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        clampToGround : {\n            get : function() {\n                return this._clampToGround && this._supportsPolylinesOnTerrain;\n            }\n        },\n\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof PolylineGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isOutlineVisible = function(time) {\n        return false;\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute\n        };\n\n        var currentColor;\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (this.clampToGround) {\n            return new GeometryInstance({\n                id : entity,\n                geometry : new GroundPolylineGeometry(this._groundGeometryOptions),\n                attributes : attributes\n            });\n        }\n\n        if (defined(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._depthFailMaterialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineGeometry(this._geometryOptions),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    PolylineGeometryUpdater.prototype.destroy = function() {\n        this._entitySubscription();\n        destroyObject(this);\n    };\n\n    PolylineGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (!(propertyName === 'availability' || propertyName === 'polyline')) {\n            return;\n        }\n\n        var polyline = this._entity.polyline;\n\n        if (!defined(polyline)) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var positionsProperty = polyline.positions;\n\n        var show = polyline.show;\n        if ((defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE)) || //\n            (!defined(positionsProperty))) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var zIndex = polyline.zIndex;\n        var material = defaultValue(polyline.material, defaultMaterial);\n        var isColorMaterial = material instanceof ColorMaterialProperty;\n        this._materialProperty = material;\n        this._depthFailMaterialProperty = polyline.depthFailMaterial;\n        this._showProperty = defaultValue(show, defaultShow);\n        this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(polyline.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(polyline.classificationType, defaultClassificationType);\n        this._fillEnabled = true;\n        this._zIndex = defaultValue(zIndex, defaultZIndex);\n\n        var width = polyline.width;\n        var arcType = polyline.arcType;\n        var clampToGround = polyline.clampToGround;\n        var granularity = polyline.granularity;\n\n        if (!positionsProperty.isConstant || !Property.isConstant(width) ||\n            !Property.isConstant(arcType) || !Property.isConstant(granularity) ||\n            !Property.isConstant(clampToGround) || !Property.isConstant(zIndex)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            var geometryOptions = this._geometryOptions;\n            var positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, geometryOptions.positions);\n\n            //Because of the way we currently handle reference properties,\n            //we can't automatically assume the positions are always valid.\n            if (!defined(positions) || positions.length < 2) {\n                if (this._fillEnabled) {\n                    this._fillEnabled = false;\n                    this._geometryChanged.raiseEvent(this);\n                }\n                return;\n            }\n\n            var vertexFormat;\n            if (isColorMaterial && (!defined(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n            } else {\n                vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n            }\n\n            geometryOptions.vertexFormat = vertexFormat;\n            geometryOptions.positions = positions;\n            geometryOptions.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.arcType = defined(arcType) ? arcType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n\n            var groundGeometryOptions = this._groundGeometryOptions;\n            groundGeometryOptions.positions = positions;\n            groundGeometryOptions.width = geometryOptions.width;\n            groundGeometryOptions.arcType = geometryOptions.arcType;\n            groundGeometryOptions.granularity = geometryOptions.granularity;\n\n            this._clampToGround = defined(clampToGround) ? clampToGround.getValue(Iso8601.MINIMUM_VALUE) : false;\n\n            if (!this._clampToGround && defined(zIndex)) {\n                oneTimeWarning('Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.');\n            }\n\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    PolylineGeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n    };\n\n    /**\n     * @private\n     */\n    var generateCartesianArcOptions = {\n        positions : undefined,\n        granularity : undefined,\n        height : undefined,\n        ellipsoid : undefined\n    };\n\n    function DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n        this._line = undefined;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._groundPolylinePrimitive = undefined;\n        this._material = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._positions = [];\n    }\n\n    function getLine(dynamicGeometryUpdater) {\n        if (defined(dynamicGeometryUpdater._line)) {\n            return dynamicGeometryUpdater._line;\n        }\n\n        var sceneId = dynamicGeometryUpdater._geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        var primitives = dynamicGeometryUpdater._primitives;\n        if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n            polylineCollection = new PolylineCollection();\n            polylineCollections[sceneId] = polylineCollection;\n            primitives.add(polylineCollection);\n        } else if (!primitives.contains(polylineCollection)) {\n            primitives.add(polylineCollection);\n        }\n\n        var line = polylineCollection.add();\n        line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n        dynamicGeometryUpdater._line = line;\n        return line;\n    }\n\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        var geometryUpdater = this._geometryUpdater;\n        var entity = geometryUpdater._entity;\n        var polyline = entity.polyline;\n\n        var positionsProperty = polyline.positions;\n        var positions = Property.getValueOrUndefined(positionsProperty, time, this._positions);\n\n        // Synchronize with geometryUpdater for GroundPolylinePrimitive\n        geometryUpdater._clampToGround = Property.getValueOrDefault(polyline._clampToGround, time, false);\n        geometryUpdater._groundGeometryOptions.positions = positions;\n        geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(polyline._width, time, 1);\n        geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(polyline._arcType, time, ArcType.GEODESIC);\n        geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(polyline._granularity, time, 9999);\n\n        var groundPrimitives = this._groundPrimitives;\n\n        if (defined(this._groundPolylinePrimitive)) {\n            groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n            this._groundPolylinePrimitive = undefined;\n        }\n\n        if (geometryUpdater.clampToGround) {\n            if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n                return;\n            }\n\n            if (!defined(positions) || positions.length < 2) {\n                return;\n            }\n\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var appearance;\n            if (fillMaterialProperty instanceof ColorMaterialProperty) {\n                appearance = new PolylineColorAppearance();\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                appearance = new PolylineMaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent()\n                });\n                this._material = material;\n            }\n\n            this._groundPolylinePrimitive = groundPrimitives.add(new GroundPolylinePrimitive({\n                geometryInstances : geometryUpdater.createFillGeometryInstance(time),\n                appearance : appearance,\n                classificationType : geometryUpdater.classificationTypeProperty.getValue(time),\n                asynchronous : false\n            }), Property.getValueOrUndefined(geometryUpdater.zIndex, time));\n\n            // Hide the polyline in the collection, if any\n            if (defined(this._line)) {\n                this._line.show = false;\n            }\n            return;\n        }\n\n        var line = getLine(this);\n\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n            line.show = false;\n            return;\n        }\n\n        if (!defined(positions) || positions.length < 2) {\n            line.show = false;\n            return;\n        }\n\n        var arcType = ArcType.GEODESIC;\n        arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n\n        var globe = geometryUpdater._scene.globe;\n        if (arcType !== ArcType.NONE && defined(globe)) {\n            generateCartesianArcOptions.ellipsoid = globe.ellipsoid;\n            generateCartesianArcOptions.positions = positions;\n            generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);\n            generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, globe.ellipsoid);\n            if (arcType === ArcType.GEODESIC) {\n                positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);\n            } else {\n                positions = PolylinePipeline.generateCartesianRhumbArc(generateCartesianArcOptions);\n            }\n        }\n\n        line.show = true;\n        line.positions = positions.slice();\n        line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);\n        line.width = Property.getValueOrDefault(polyline._width, time, 1);\n        line.distanceDisplayCondition = Property.getValueOrUndefined(polyline._distanceDisplayCondition, time, line.distanceDisplayCondition);\n    };\n\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n\n        if (!this._geometryUpdater.clampToGround) {\n            var line = getLine(this);\n            if (line.show && line.positions.length > 0) {\n                BoundingSphere.fromPoints(line.positions, result);\n                return BoundingSphereState.DONE;\n            }\n        } else {\n            var groundPolylinePrimitive = this._groundPolylinePrimitive;\n            if (defined(groundPolylinePrimitive) && groundPolylinePrimitive.show && groundPolylinePrimitive.ready) {\n                var attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(this._geometryUpdater._entity);\n                if (defined(attributes) && defined(attributes.boundingSphere)) {\n                    BoundingSphere.clone(attributes.boundingSphere, result);\n                    return BoundingSphereState.DONE;\n                }\n            }\n\n            if ((defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready)) {\n                return BoundingSphereState.PENDING;\n            }\n\n            return BoundingSphereState.DONE;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var geometryUpdater = this._geometryUpdater;\n        var sceneId = geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        if (defined(polylineCollection)) {\n            polylineCollection.remove(this._line);\n            if (polylineCollection.length === 0) {\n                this._primitives.removeAndDestroy(polylineCollection);\n                delete polylineCollections[sceneId];\n            }\n        }\n        if (defined(this._groundPolylinePrimitive)) {\n            this._groundPrimitives.remove(this._groundPolylinePrimitive);\n        }\n        destroyObject(this);\n    };\nexport default PolylineGeometryUpdater;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport Color from '../Core/Color.js';\nimport ColorGeometryInstanceAttribute from '../Core/ColorGeometryInstanceAttribute.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport DistanceDisplayCondition from '../Core/DistanceDisplayCondition.js';\nimport DistanceDisplayConditionGeometryInstanceAttribute from '../Core/DistanceDisplayConditionGeometryInstanceAttribute.js';\nimport ShowGeometryInstanceAttribute from '../Core/ShowGeometryInstanceAttribute.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport MaterialProperty from './MaterialProperty.js';\nimport Property from './Property.js';\n\n    var scratchColor = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(orderedGroundPrimitives, classificationType, materialProperty, zIndex, asynchronous) {\n        var appearanceType;\n        if (materialProperty instanceof ColorMaterialProperty) {\n            appearanceType = PolylineColorAppearance;\n        } else {\n            appearanceType = PolylineMaterialAppearance;\n        }\n\n        this.orderedGroundPrimitives = orderedGroundPrimitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPolylinePrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.zIndex = zIndex;\n\n        this._asynchronous = asynchronous;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        orderedGroundPrimitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPolylinePrimitive({\n                    show : false,\n                    asynchronous : this._asynchronous,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType(),\n                    classificationType : this.classificationType\n                });\n\n                if (this.appearanceType === PolylineMaterialAppearance) {\n                    this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                    primitive.appearance.material = this.material;\n                }\n\n                orderedGroundPrimitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    orderedGroundPrimitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    orderedGroundPrimitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                orderedGroundPrimitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (this.appearanceType === PolylineMaterialAppearance) {\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                this.primitive.appearance.material = this.material;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, scratchColor);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        if (defined(primitive)) {\n            orderedGroundPrimitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            orderedGroundPrimitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundPolylinePerMaterialBatch(orderedGroundPrimitives, classificationType, asynchronous) {\n        this._items = [];\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._classificationType = classificationType;\n        this._asynchronous = defaultValue(asynchronous, true);\n    }\n\n    StaticGroundPolylinePerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater has the same material or a material representable with per-instance color.\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.zIndex === zIndex) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._orderedGroundPrimitives, this._classificationType, updater.fillMaterialProperty, zIndex, this._asynchronous);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\nexport default StaticGroundPolylinePerMaterialBatch;\n","import AssociativeArray from '../Core/AssociativeArray.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport ClassificationType from '../Scene/ClassificationType.js';\nimport PolylineColorAppearance from '../Scene/PolylineColorAppearance.js';\nimport PolylineMaterialAppearance from '../Scene/PolylineMaterialAppearance.js';\nimport ShadowMode from '../Scene/ShadowMode.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport ColorMaterialProperty from './ColorMaterialProperty.js';\nimport DynamicGeometryBatch from './DynamicGeometryBatch.js';\nimport PolylineGeometryUpdater from './PolylineGeometryUpdater.js';\nimport StaticGeometryColorBatch from './StaticGeometryColorBatch.js';\nimport StaticGeometryPerMaterialBatch from './StaticGeometryPerMaterialBatch.js';\nimport StaticGroundPolylinePerMaterialBatch from './StaticGroundPolylinePerMaterialBatch.js';\n\n    var emptyArray = [];\n\n    function removeUpdater(that, updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = that._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    }\n\n    function insertUpdaterIntoBatch(that, time, updater) {\n        if (updater.isDynamic) {\n            that._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        if (updater.clampToGround && updater.fillEnabled) { // Also checks for support\n            var classificationType = updater.classificationTypeProperty.getValue(time);\n            that._groundBatches[classificationType].add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var multiplier = 0;\n        if (defined(updater.depthFailMaterialProperty)) {\n            multiplier = updater.depthFailMaterialProperty instanceof ColorMaterialProperty ? 1 : 2;\n        }\n\n        var index;\n        if (defined(shadows)) {\n            index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                that._colorBatches[index].add(time, updater);\n            } else {\n                that._materialBatches[index].add(time, updater);\n            }\n        }\n    }\n\n    /**\n     * A visualizer for polylines represented by {@link Primitive} instances.\n     * @alias PolylineVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function PolylineVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n        primitives = defaultValue(primitives, scene.primitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var i;\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._colorBatches = new Array(numberOfShadowModes * 3);\n        this._materialBatches = new Array(numberOfShadowModes * 3);\n\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._colorBatches[i] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, undefined, false, i); // no depth fail appearance\n            this._materialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, undefined, false, i);\n\n            this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineColorAppearance, false, i); //depth fail appearance variations\n            this._materialBatches[i + numberOfShadowModes] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineColorAppearance, false, i);\n\n            this._colorBatches[i + numberOfShadowModes * 2] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineMaterialAppearance, false, i);\n            this._materialBatches[i + numberOfShadowModes * 2] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineMaterialAppearance, false, i);\n        }\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        this._groundBatches = new Array(numberOfClassificationTypes);\n\n        for (i = 0; i < numberOfClassificationTypes; ++i) {\n            this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(groundPrimitives, i);\n        }\n\n        this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaters = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    PolylineVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updater;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updater.entity === entity) {\n                removeUpdater(this, updater);\n                insertUpdaterIntoBatch(this, time, updater);\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n            removeUpdater(this, updater);\n            updater.destroy();\n            this._updaters.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updater = new PolylineGeometryUpdater(entity, this._scene);\n            this._updaters.set(id, updater);\n            insertUpdaterIntoBatch(this, time, updater);\n            this._subscriptions.set(id, updater.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PolylineVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n        var updater = this._updaters.get(entity.id);\n        for (var i = 0; i < batchesLength; i++) {\n            state = batches[i].getBoundingSphere(updater, tmp);\n            if (state === BoundingSphereState.PENDING) {\n                return BoundingSphereState.PENDING;\n            } else if (state === BoundingSphereState.DONE) {\n                boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                count++;\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PolylineVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\nexport default PolylineVisualizer;\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\nimport BoundingSphere from '../Core/BoundingSphere.js';\nimport Check from '../Core/Check.js';\nimport createGuid from '../Core/createGuid.js';\nimport defaultValue from '../Core/defaultValue.js';\nimport defined from '../Core/defined.js';\nimport defineProperties from '../Core/defineProperties.js';\nimport destroyObject from '../Core/destroyObject.js';\nimport EventHelper from '../Core/EventHelper.js';\nimport GroundPolylinePrimitive from '../Scene/GroundPolylinePrimitive.js';\nimport GroundPrimitive from '../Scene/GroundPrimitive.js';\nimport OrderedGroundPrimitiveCollection from '../Scene/OrderedGroundPrimitiveCollection.js';\nimport PrimitiveCollection from '../Scene/PrimitiveCollection.js';\nimport BillboardVisualizer from './BillboardVisualizer.js';\nimport BoundingSphereState from './BoundingSphereState.js';\nimport CustomDataSource from './CustomDataSource.js';\nimport GeometryVisualizer from './GeometryVisualizer.js';\nimport LabelVisualizer from './LabelVisualizer.js';\nimport ModelVisualizer from './ModelVisualizer.js';\nimport PathVisualizer from './PathVisualizer.js';\nimport PointVisualizer from './PointVisualizer.js';\nimport PolylineVisualizer from './PolylineVisualizer.js';\n\n    /**\n     * Visualizes a collection of {@link DataSource} instances.\n     * @alias DataSourceDisplay\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Scene} options.scene The scene in which to display the data.\n     * @param {DataSourceCollection} options.dataSourceCollection The data sources to display.\n     * @param {DataSourceDisplay~VisualizersCallback} [options.visualizersCallback=DataSourceDisplay.defaultVisualizersCallback]\n     *        A function which creates an array of visualizers used for visualization.\n     *        If undefined, all standard visualizers are used.\n     */\n    function DataSourceDisplay(options) {\n        \n\n        this._displayID = createGuid();\n\n        GroundPrimitive.initializeTerrainHeights();\n        GroundPolylinePrimitive.initializeTerrainHeights();\n\n        var scene = options.scene;\n        var dataSourceCollection = options.dataSourceCollection;\n\n        this._eventHelper = new EventHelper();\n        this._eventHelper.add(dataSourceCollection.dataSourceAdded, this._onDataSourceAdded, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceRemoved, this._onDataSourceRemoved, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceMoved, this._onDataSourceMoved, this);\n        this._eventHelper.add(scene.postRender, this._postRender, this);\n\n        this._dataSourceCollection = dataSourceCollection;\n        this._scene = scene;\n        this._visualizersCallback = defaultValue(options.visualizersCallback, DataSourceDisplay.defaultVisualizersCallback);\n\n        var primitivesAdded = false;\n        var primitives = new PrimitiveCollection();\n        var groundPrimitives = new PrimitiveCollection();\n\n        if (dataSourceCollection.length > 0) {\n            scene.primitives.add(primitives);\n            scene.groundPrimitives.add(groundPrimitives);\n            primitivesAdded = true;\n        }\n\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n\n        for (var i = 0, len = dataSourceCollection.length; i < len; i++) {\n            this._onDataSourceAdded(dataSourceCollection, dataSourceCollection.get(i));\n        }\n\n        var defaultDataSource = new CustomDataSource();\n        this._onDataSourceAdded(undefined, defaultDataSource);\n        this._defaultDataSource = defaultDataSource;\n\n        var removeDefaultDataSourceListener;\n        var removeDataSourceCollectionListener;\n        if (!primitivesAdded) {\n            var that = this;\n            var addPrimitives = function() {\n                scene.primitives.add(primitives);\n                scene.groundPrimitives.add(groundPrimitives);\n                removeDefaultDataSourceListener();\n                removeDataSourceCollectionListener();\n                that._removeDefaultDataSourceListener = undefined;\n                that._removeDataSourceCollectionListener = undefined;\n            };\n            removeDefaultDataSourceListener = defaultDataSource.entities.collectionChanged.addEventListener(addPrimitives);\n            removeDataSourceCollectionListener = dataSourceCollection.dataSourceAdded.addEventListener(addPrimitives);\n        }\n\n        this._removeDefaultDataSourceListener = removeDefaultDataSourceListener;\n        this._removeDataSourceCollectionListener = removeDataSourceCollectionListener;\n\n        this._ready = false;\n    }\n\n    /**\n     * Gets or sets the default function which creates an array of visualizers used for visualization.\n     * By default, this function uses all standard visualizers.\n     *\n     * @type {DataSourceDisplay~VisualizersCallback}\n     */\n    DataSourceDisplay.defaultVisualizersCallback = function(scene, entityCluster, dataSource) {\n        var entities = dataSource.entities;\n        return [new BillboardVisualizer(entityCluster, entities),\n                new GeometryVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives),\n                new LabelVisualizer(entityCluster, entities),\n                new ModelVisualizer(scene, entities),\n                new PointVisualizer(entityCluster, entities),\n                new PathVisualizer(scene, entities),\n                new PolylineVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives)];\n    };\n\n    defineProperties(DataSourceDisplay.prototype, {\n        /**\n         * Gets the scene associated with this display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {Scene}\n         */\n        scene : {\n            get : function() {\n                return this._scene;\n            }\n        },\n        /**\n         * Gets the collection of data sources to display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {DataSourceCollection}\n         */\n        dataSources : {\n            get : function() {\n                return this._dataSourceCollection;\n            }\n        },\n        /**\n         * Gets the default data source instance which can be used to\n         * manually create and visualize entities not tied to\n         * a specific data source. This instance is always available\n         * and does not appear in the list dataSources collection.\n         * @memberof DataSourceDisplay.prototype\n         * @type {CustomDataSource}\n         */\n        defaultDataSource : {\n            get : function() {\n                return this._defaultDataSource;\n            }\n        },\n\n        /**\n         * Gets a value indicating whether or not all entities in the data source are ready\n         * @memberof DataSourceDisplay.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        ready : {\n            get : function() {\n                return this._ready;\n            }\n        }\n    });\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see DataSourceDisplay#destroy\n     */\n    DataSourceDisplay.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n     * <br /><br />\n     * Once an object is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * dataSourceDisplay = dataSourceDisplay.destroy();\n     *\n     * @see DataSourceDisplay#isDestroyed\n     */\n    DataSourceDisplay.prototype.destroy = function() {\n        this._eventHelper.removeAll();\n\n        var dataSourceCollection = this._dataSourceCollection;\n        for (var i = 0, length = dataSourceCollection.length; i < length; ++i) {\n            this._onDataSourceRemoved(this._dataSourceCollection, dataSourceCollection.get(i));\n        }\n        this._onDataSourceRemoved(undefined, this._defaultDataSource);\n\n        if (defined(this._removeDefaultDataSourceListener)) {\n            this._removeDefaultDataSourceListener();\n            this._removeDataSourceCollectionListener();\n        } else {\n            this._scene.primitives.remove(this._primitives);\n            this._scene.groundPrimitives.remove(this._groundPrimitives);\n        }\n\n        return destroyObject(this);\n    };\n\n    /**\n     * Updates the display to the provided time.\n     *\n     * @param {JulianDate} time The simulation time.\n     * @returns {Boolean} True if all data sources are ready to be displayed, false otherwise.\n     */\n    DataSourceDisplay.prototype.update = function(time) {\n        \n\n        if (!ApproximateTerrainHeights.initialized) {\n            this._ready = false;\n            return false;\n        }\n\n        var result = true;\n\n        var i;\n        var x;\n        var visualizers;\n        var vLength;\n        var dataSources = this._dataSourceCollection;\n        var length = dataSources.length;\n        for (i = 0; i < length; i++) {\n            var dataSource = dataSources.get(i);\n            if (defined(dataSource.update)) {\n                result = dataSource.update(time) && result;\n            }\n\n            visualizers = dataSource._visualizersByDisplayID[this._displayID];\n            vLength = visualizers.length;\n            for (x = 0; x < vLength; x++) {\n                result = visualizers[x].update(time) && result;\n            }\n        }\n\n        visualizers = this._defaultDataSource._visualizersByDisplayID[this._displayID];\n        vLength = visualizers.length;\n        for (x = 0; x < vLength; x++) {\n            result = visualizers[x].update(time) && result;\n        }\n\n        this._ready = result;\n\n        return result;\n    };\n\n    DataSourceDisplay.prototype._postRender = function() {\n        // Adds credits for all datasources\n        var frameState = this._scene.frameState;\n        var dataSources = this._dataSourceCollection;\n        var length = dataSources.length;\n        for (var i = 0; i < length; i++) {\n            var dataSource = dataSources.get(i);\n\n            var credit = dataSource.credit;\n            if (defined(credit)) {\n                frameState.creditDisplay.addCredit(credit);\n            }\n\n            // Credits from the resource that the user can't remove\n            var credits = dataSource._resourceCredits;\n            if (defined(credits)) {\n                var creditCount = credits.length;\n                for (var c = 0; c < creditCount; c++) {\n                    frameState.creditDisplay.addCredit(credits[c]);\n                }\n            }\n        }\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {Boolean} allowPartial If true, pending bounding spheres are ignored and an answer will be returned from the currently available data.\n     *                               If false, the the function will halt and return pending if any of the bounding spheres are pending.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DataSourceDisplay.prototype.getBoundingSphere = function(entity, allowPartial, result) {\n        \n\n        if (!this._ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var i;\n        var length;\n        var dataSource = this._defaultDataSource;\n        if (!dataSource.entities.contains(entity)) {\n            dataSource = undefined;\n\n            var dataSources = this._dataSourceCollection;\n            length = dataSources.length;\n            for (i = 0; i < length; i++) {\n                var d = dataSources.get(i);\n                if (d.entities.contains(entity)) {\n                    dataSource = d;\n                    break;\n                }\n            }\n        }\n\n        if (!defined(dataSource)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var visualizers = dataSource._visualizers;\n        var visualizersLength = visualizers.length;\n\n        for (i = 0; i < visualizersLength; i++) {\n            var visualizer = visualizers[i];\n            if (defined(visualizer.getBoundingSphere)) {\n                state = visualizers[i].getBoundingSphere(entity, tmp);\n                if (!allowPartial && state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    DataSourceDisplay.prototype._onDataSourceAdded = function(dataSourceCollection, dataSource) {\n        var scene = this._scene;\n\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = displayPrimitives.add(new PrimitiveCollection());\n        var groundPrimitives = displayGroundPrimitives.add(new OrderedGroundPrimitiveCollection());\n\n        dataSource._primitives = primitives;\n        dataSource._groundPrimitives = groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        entityCluster._initialize(scene);\n\n        primitives.add(entityCluster);\n\n        var visualizers = this._visualizersCallback(scene, entityCluster, dataSource);\n\n        dataSource._visualizersByDisplayID = dataSource._visualizersByDisplayID || {};\n        dataSource._visualizersByDisplayID[this._displayID] = visualizers;\n\n        dataSource._visualizers = dataSource._visualizers || [];\n        dataSource._visualizers = dataSource._visualizers.concat(visualizers);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceRemoved = function(dataSourceCollection, dataSource) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        primitives.remove(entityCluster);\n\n        var visualizers = dataSource._visualizersByDisplayID[this._displayID];\n        if (!defined(visualizers)) {\n            return;\n        }\n\n        var length = visualizers.length;\n        for (var i = 0; i < length; i++) {\n            var visualizer = visualizers[i];\n            visualizer.destroy();\n\n            var index = dataSource._visualizers.indexOf(visualizer);\n            dataSource._visualizers.splice(index, 1);\n        }\n\n        delete dataSource._visualizersByDisplayID[this._displayID];\n\n        displayPrimitives.remove(primitives);\n        displayGroundPrimitives.remove(groundPrimitives);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceMoved = function(dataSource, newIndex, oldIndex) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        if (newIndex === oldIndex + 1) {\n            displayPrimitives.raise(primitives);\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else if (newIndex === oldIndex - 1) {\n            displayPrimitives.lower(primitives);\n            displayGroundPrimitives.lower(groundPrimitives);\n        } else if (newIndex === 0) {\n            displayPrimitives.lowerToBottom(primitives);\n            displayGroundPrimitives.lowerToBottom(groundPrimitives);\n            displayPrimitives.raise(primitives); // keep defaultDataSource primitives at index 0 since it's not in the collection\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else {\n            displayPrimitives.raiseToTop(primitives);\n            displayGroundPrimitives.raiseToTop(groundPrimitives);\n        }\n    };\n\n    /**\n     * A function which creates an array of visualizers used for visualization.\n     * @callback DataSourceDisplay~VisualizersCallback\n     *\n     * @param {Scene} scene The scene to create visualizers for.\n     * @param {DataSource} dataSource The data source to create visualizers for.\n     * @returns {Visualizer[]} An array of visualizers used for visualization.\n     *\n     * @example\n     * function createVisualizers(scene, dataSource) {\n     *     return [new Cesium.BillboardVisualizer(scene, dataSource.entities)];\n     * }\n     */\nexport default DataSourceDisplay;\n"],"sourceRoot":""}